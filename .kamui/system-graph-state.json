{
  "schemaVersion": 1,
  "projectPath": "/Users/yuyafujita/Projects/koma-fill",
  "projectRootName": "koma-fill",
  "graphRenderingMode": "normal",
  "linkDisplayMode": "all",
  "graphStats": {
    "totalNodes": 80,
    "folders": 26,
    "files": 54,
    "images": 0,
    "videos": 0,
    "audio": 0,
    "code": 35,
    "text": 5,
    "html": 1,
    "yaml": 0,
    "json": 8,
    "other": 5,
    "totalLines": 0,
    "maxLines": 0
  },
  "directoryTree": {
    "name": "koma-fill",
    "type": "directory",
    "path": "koma-fill",
    "children": [
      {
        "name": ".kamui",
        "type": "directory",
        "path": ".kamui",
        "children": [],
        "hasMore": true
      },
      {
        "name": ".worktrees",
        "type": "directory",
        "path": ".worktrees",
        "children": [],
        "hasMore": true
      },
      {
        "name": "backend",
        "type": "directory",
        "path": "backend",
        "children": [
          {
            "name": "data",
            "type": "directory",
            "path": "backend/data",
            "children": []
          },
          {
            "name": "src",
            "type": "directory",
            "path": "backend/src",
            "children": [
              {
                "name": "config",
                "type": "directory",
                "path": "backend/src/config",
                "children": [
                  {
                    "name": "constants.ts",
                    "type": "file",
                    "path": "backend/src/config/constants.ts"
                  }
                ]
              },
              {
                "name": "database",
                "type": "directory",
                "path": "backend/src/database",
                "children": [
                  {
                    "name": "connection.ts",
                    "type": "file",
                    "path": "backend/src/database/connection.ts"
                  },
                  {
                    "name": "schema.ts",
                    "type": "file",
                    "path": "backend/src/database/schema.ts"
                  }
                ]
              },
              {
                "name": "middleware",
                "type": "directory",
                "path": "backend/src/middleware",
                "children": [
                  {
                    "name": "errorHandler.ts",
                    "type": "file",
                    "path": "backend/src/middleware/errorHandler.ts"
                  }
                ]
              },
              {
                "name": "models",
                "type": "directory",
                "path": "backend/src/models",
                "children": [
                  {
                    "name": "types.ts",
                    "type": "file",
                    "path": "backend/src/models/types.ts"
                  }
                ]
              },
              {
                "name": "repositories",
                "type": "directory",
                "path": "backend/src/repositories",
                "children": [
                  {
                    "name": "keyImageRepository.ts",
                    "type": "file",
                    "path": "backend/src/repositories/keyImageRepository.ts"
                  },
                  {
                    "name": "panelRepository.ts",
                    "type": "file",
                    "path": "backend/src/repositories/panelRepository.ts"
                  },
                  {
                    "name": "projectRepository.ts",
                    "type": "file",
                    "path": "backend/src/repositories/projectRepository.ts"
                  }
                ]
              },
              {
                "name": "routes",
                "type": "directory",
                "path": "backend/src/routes",
                "children": [
                  {
                    "name": "manga.ts",
                    "type": "file",
                    "path": "backend/src/routes/manga.ts"
                  }
                ]
              },
              {
                "name": "services",
                "type": "directory",
                "path": "backend/src/services",
                "children": [
                  {
                    "name": "exportService.ts",
                    "type": "file",
                    "path": "backend/src/services/exportService.ts"
                  },
                  {
                    "name": "imageAnalysisService.ts",
                    "type": "file",
                    "path": "backend/src/services/imageAnalysisService.ts"
                  },
                  {
                    "name": "imageGenerationService.ts",
                    "type": "file",
                    "path": "backend/src/services/imageGenerationService.ts"
                  },
                  {
                    "name": "layoutEngine.ts",
                    "type": "file",
                    "path": "backend/src/services/layoutEngine.ts"
                  },
                  {
                    "name": "promptGenerationService.ts",
                    "type": "file",
                    "path": "backend/src/services/promptGenerationService.ts"
                  }
                ]
              },
              {
                "name": "utils",
                "type": "directory",
                "path": "backend/src/utils",
                "children": [
                  {
                    "name": "imageProcessor.ts",
                    "type": "file",
                    "path": "backend/src/utils/imageProcessor.ts"
                  }
                ]
              },
              {
                "name": "app.ts",
                "type": "file",
                "path": "backend/src/app.ts"
              },
              {
                "name": "index.ts",
                "type": "file",
                "path": "backend/src/index.ts"
              }
            ]
          },
          {
            "name": "uploads",
            "type": "directory",
            "path": "backend/uploads",
            "children": []
          },
          {
            "name": "package-lock.json",
            "type": "file",
            "path": "backend/package-lock.json"
          },
          {
            "name": "package.json",
            "type": "file",
            "path": "backend/package.json"
          },
          {
            "name": "tsconfig.json",
            "type": "file",
            "path": "backend/tsconfig.json"
          }
        ]
      },
      {
        "name": "docs",
        "type": "directory",
        "path": "docs",
        "children": [
          {
            "name": "API_SPEC.md",
            "type": "file",
            "path": "docs/API_SPEC.md"
          },
          {
            "name": "ARCHITECTURE.md",
            "type": "file",
            "path": "docs/ARCHITECTURE.md"
          },
          {
            "name": "KAMUI_FIX_PROMPTS.md",
            "type": "file",
            "path": "docs/KAMUI_FIX_PROMPTS.md"
          },
          {
            "name": "KAMUI_PROMPTS.md",
            "type": "file",
            "path": "docs/KAMUI_PROMPTS.md"
          }
        ]
      },
      {
        "name": "frontend",
        "type": "directory",
        "path": "frontend",
        "children": [
          {
            "name": "src",
            "type": "directory",
            "path": "frontend/src",
            "children": [
              {
                "name": "components",
                "type": "directory",
                "path": "frontend/src/components",
                "children": [
                  {
                    "name": "ExportOptions.tsx",
                    "type": "file",
                    "path": "frontend/src/components/ExportOptions.tsx"
                  },
                  {
                    "name": "ImageUploader.tsx",
                    "type": "file",
                    "path": "frontend/src/components/ImageUploader.tsx"
                  },
                  {
                    "name": "LayoutSelector.tsx",
                    "type": "file",
                    "path": "frontend/src/components/LayoutSelector.tsx"
                  },
                  {
                    "name": "PanelGrid.tsx",
                    "type": "file",
                    "path": "frontend/src/components/PanelGrid.tsx"
                  },
                  {
                    "name": "ProgressBar.tsx",
                    "type": "file",
                    "path": "frontend/src/components/ProgressBar.tsx"
                  },
                  {
                    "name": "StoryPromptEditor.tsx",
                    "type": "file",
                    "path": "frontend/src/components/StoryPromptEditor.tsx"
                  }
                ]
              },
              {
                "name": "hooks",
                "type": "directory",
                "path": "frontend/src/hooks",
                "children": [
                  {
                    "name": "useMangaGeneration.ts",
                    "type": "file",
                    "path": "frontend/src/hooks/useMangaGeneration.ts"
                  }
                ]
              },
              {
                "name": "pages",
                "type": "directory",
                "path": "frontend/src/pages",
                "children": [
                  {
                    "name": "CreateMangaPage.tsx",
                    "type": "file",
                    "path": "frontend/src/pages/CreateMangaPage.tsx"
                  },
                  {
                    "name": "PreviewPage.tsx",
                    "type": "file",
                    "path": "frontend/src/pages/PreviewPage.tsx"
                  }
                ]
              },
              {
                "name": "services",
                "type": "directory",
                "path": "frontend/src/services",
                "children": [
                  {
                    "name": "apiClient.ts",
                    "type": "file",
                    "path": "frontend/src/services/apiClient.ts"
                  }
                ]
              },
              {
                "name": "types",
                "type": "directory",
                "path": "frontend/src/types",
                "children": [
                  {
                    "name": "index.ts",
                    "type": "file",
                    "path": "frontend/src/types/index.ts"
                  }
                ]
              },
              {
                "name": "App.tsx",
                "type": "file",
                "path": "frontend/src/App.tsx"
              },
              {
                "name": "index.css",
                "type": "file",
                "path": "frontend/src/index.css"
              },
              {
                "name": "main.tsx",
                "type": "file",
                "path": "frontend/src/main.tsx"
              },
              {
                "name": "vite-env.d.ts",
                "type": "file",
                "path": "frontend/src/vite-env.d.ts"
              }
            ]
          },
          {
            "name": "index.html",
            "type": "file",
            "path": "frontend/index.html"
          },
          {
            "name": "package-lock.json",
            "type": "file",
            "path": "frontend/package-lock.json"
          },
          {
            "name": "package.json",
            "type": "file",
            "path": "frontend/package.json"
          },
          {
            "name": "postcss.config.js",
            "type": "file",
            "path": "frontend/postcss.config.js"
          },
          {
            "name": "tailwind.config.js",
            "type": "file",
            "path": "frontend/tailwind.config.js"
          },
          {
            "name": "tsconfig.json",
            "type": "file",
            "path": "frontend/tsconfig.json"
          },
          {
            "name": "vite.config.ts",
            "type": "file",
            "path": "frontend/vite.config.ts"
          }
        ]
      },
      {
        "name": "node_modules",
        "type": "directory",
        "path": "node_modules",
        "children": [],
        "hasMore": true
      },
      {
        "name": "output",
        "type": "directory",
        "path": "output",
        "children": []
      },
      {
        "name": "uploads",
        "type": "directory",
        "path": "uploads",
        "children": []
      },
      {
        "name": ".DS_Store",
        "type": "file",
        "path": ".DS_Store"
      },
      {
        "name": ".env",
        "type": "file",
        "path": ".env"
      },
      {
        "name": ".env.example",
        "type": "file",
        "path": ".env.example"
      },
      {
        "name": ".gitignore",
        "type": "file",
        "path": ".gitignore"
      },
      {
        "name": "CONTEXT.md",
        "type": "file",
        "path": "CONTEXT.md"
      },
      {
        "name": "eslint.config.js",
        "type": "file",
        "path": "eslint.config.js"
      },
      {
        "name": "package-lock.json",
        "type": "file",
        "path": "package-lock.json"
      },
      {
        "name": "package.json",
        "type": "file",
        "path": "package.json"
      }
    ]
  },
  "graphData": {
    "nodes": [
      {
        "id": "koma-fill",
        "name": "koma-fill",
        "path": "koma-fill",
        "type": "directory",
        "lines": 0,
        "val": 14,
        "color": "#4d515a",
        "baseColor": "#4ec9b0",
        "originalColor": "#4ec9b0",
        "defaultGlow": 0.18,
        "glowIntensity": 0.18,
        "highlighted": false,
        "parentPath": null,
        "childFileCount": 8
      },
      {
        "id": "koma-fill/.kamui",
        "name": ".kamui",
        "path": "koma-fill/.kamui",
        "type": "directory",
        "lines": 0,
        "val": 14,
        "color": "#4d515a",
        "baseColor": "#4ec9b0",
        "originalColor": "#4ec9b0",
        "defaultGlow": 0.18,
        "glowIntensity": 0.18,
        "highlighted": false,
        "parentPath": "koma-fill",
        "childFileCount": 0
      },
      {
        "id": "koma-fill/.worktrees",
        "name": ".worktrees",
        "path": "koma-fill/.worktrees",
        "type": "directory",
        "lines": 0,
        "val": 14,
        "color": "#4d515a",
        "baseColor": "#4ec9b0",
        "originalColor": "#4ec9b0",
        "defaultGlow": 0.18,
        "glowIntensity": 0.18,
        "highlighted": false,
        "parentPath": "koma-fill",
        "childFileCount": 0
      },
      {
        "id": "koma-fill/backend",
        "name": "backend",
        "path": "koma-fill/backend",
        "type": "directory",
        "lines": 0,
        "val": 14,
        "color": "#4d515a",
        "baseColor": "#4ec9b0",
        "originalColor": "#4ec9b0",
        "defaultGlow": 0.18,
        "glowIntensity": 0.18,
        "highlighted": false,
        "parentPath": "koma-fill",
        "childFileCount": 3
      },
      {
        "id": "koma-fill/backend/data",
        "name": "data",
        "path": "koma-fill/backend/data",
        "type": "directory",
        "lines": 0,
        "val": 14,
        "color": "#4d515a",
        "baseColor": "#4ec9b0",
        "originalColor": "#4ec9b0",
        "defaultGlow": 0.18,
        "glowIntensity": 0.18,
        "highlighted": false,
        "parentPath": "koma-fill/backend",
        "childFileCount": 0
      },
      {
        "id": "koma-fill/backend/src",
        "name": "src",
        "path": "koma-fill/backend/src",
        "type": "directory",
        "lines": 0,
        "val": 14,
        "color": "#4d515a",
        "baseColor": "#4ec9b0",
        "originalColor": "#4ec9b0",
        "defaultGlow": 0.18,
        "glowIntensity": 0.18,
        "highlighted": false,
        "parentPath": "koma-fill/backend",
        "childFileCount": 2
      },
      {
        "id": "koma-fill/backend/src/config",
        "name": "config",
        "path": "koma-fill/backend/src/config",
        "type": "directory",
        "lines": 0,
        "val": 14,
        "color": "#4d515a",
        "baseColor": "#4ec9b0",
        "originalColor": "#4ec9b0",
        "defaultGlow": 0.18,
        "glowIntensity": 0.18,
        "highlighted": false,
        "parentPath": "koma-fill/backend/src",
        "childFileCount": 1
      },
      {
        "id": "koma-fill/backend/src/config/constants.ts",
        "name": "constants.ts",
        "path": "koma-fill/backend/src/config/constants.ts",
        "type": "file",
        "lines": 0,
        "val": 6,
        "color": "#3178c6",
        "baseColor": "#3178c6",
        "originalColor": "#3178c6",
        "defaultGlow": 0.1,
        "glowIntensity": 0.1,
        "highlighted": false,
        "parentPath": "koma-fill/backend/src/config",
        "childFileCount": 0
      },
      {
        "id": "koma-fill/backend/src/database",
        "name": "database",
        "path": "koma-fill/backend/src/database",
        "type": "directory",
        "lines": 0,
        "val": 14,
        "color": "#4d515a",
        "baseColor": "#4ec9b0",
        "originalColor": "#4ec9b0",
        "defaultGlow": 0.18,
        "glowIntensity": 0.18,
        "highlighted": false,
        "parentPath": "koma-fill/backend/src",
        "childFileCount": 2
      },
      {
        "id": "koma-fill/backend/src/database/connection.ts",
        "name": "connection.ts",
        "path": "koma-fill/backend/src/database/connection.ts",
        "type": "file",
        "lines": 0,
        "val": 6,
        "color": "#3178c6",
        "baseColor": "#3178c6",
        "originalColor": "#3178c6",
        "defaultGlow": 0.1,
        "glowIntensity": 0.1,
        "highlighted": false,
        "parentPath": "koma-fill/backend/src/database",
        "childFileCount": 0
      },
      {
        "id": "koma-fill/backend/src/database/schema.ts",
        "name": "schema.ts",
        "path": "koma-fill/backend/src/database/schema.ts",
        "type": "file",
        "lines": 0,
        "val": 6,
        "color": "#3178c6",
        "baseColor": "#3178c6",
        "originalColor": "#3178c6",
        "defaultGlow": 0.1,
        "glowIntensity": 0.1,
        "highlighted": false,
        "parentPath": "koma-fill/backend/src/database",
        "childFileCount": 0
      },
      {
        "id": "koma-fill/backend/src/middleware",
        "name": "middleware",
        "path": "koma-fill/backend/src/middleware",
        "type": "directory",
        "lines": 0,
        "val": 14,
        "color": "#4d515a",
        "baseColor": "#4ec9b0",
        "originalColor": "#4ec9b0",
        "defaultGlow": 0.18,
        "glowIntensity": 0.18,
        "highlighted": false,
        "parentPath": "koma-fill/backend/src",
        "childFileCount": 1
      },
      {
        "id": "koma-fill/backend/src/middleware/errorHandler.ts",
        "name": "errorHandler.ts",
        "path": "koma-fill/backend/src/middleware/errorHandler.ts",
        "type": "file",
        "lines": 0,
        "val": 6,
        "color": "#3178c6",
        "baseColor": "#3178c6",
        "originalColor": "#3178c6",
        "defaultGlow": 0.1,
        "glowIntensity": 0.1,
        "highlighted": false,
        "parentPath": "koma-fill/backend/src/middleware",
        "childFileCount": 0
      },
      {
        "id": "koma-fill/backend/src/models",
        "name": "models",
        "path": "koma-fill/backend/src/models",
        "type": "directory",
        "lines": 0,
        "val": 14,
        "color": "#4d515a",
        "baseColor": "#4ec9b0",
        "originalColor": "#4ec9b0",
        "defaultGlow": 0.18,
        "glowIntensity": 0.18,
        "highlighted": false,
        "parentPath": "koma-fill/backend/src",
        "childFileCount": 1
      },
      {
        "id": "koma-fill/backend/src/models/types.ts",
        "name": "types.ts",
        "path": "koma-fill/backend/src/models/types.ts",
        "type": "file",
        "lines": 0,
        "val": 6,
        "color": "#3178c6",
        "baseColor": "#3178c6",
        "originalColor": "#3178c6",
        "defaultGlow": 0.1,
        "glowIntensity": 0.1,
        "highlighted": false,
        "parentPath": "koma-fill/backend/src/models",
        "childFileCount": 0
      },
      {
        "id": "koma-fill/backend/src/repositories",
        "name": "repositories",
        "path": "koma-fill/backend/src/repositories",
        "type": "directory",
        "lines": 0,
        "val": 14,
        "color": "#4d515a",
        "baseColor": "#4ec9b0",
        "originalColor": "#4ec9b0",
        "defaultGlow": 0.18,
        "glowIntensity": 0.18,
        "highlighted": false,
        "parentPath": "koma-fill/backend/src",
        "childFileCount": 3
      },
      {
        "id": "koma-fill/backend/src/repositories/keyImageRepository.ts",
        "name": "keyImageRepository.ts",
        "path": "koma-fill/backend/src/repositories/keyImageRepository.ts",
        "type": "file",
        "lines": 0,
        "val": 6,
        "color": "#3178c6",
        "baseColor": "#3178c6",
        "originalColor": "#3178c6",
        "defaultGlow": 0.1,
        "glowIntensity": 0.1,
        "highlighted": false,
        "parentPath": "koma-fill/backend/src/repositories",
        "childFileCount": 0
      },
      {
        "id": "koma-fill/backend/src/repositories/panelRepository.ts",
        "name": "panelRepository.ts",
        "path": "koma-fill/backend/src/repositories/panelRepository.ts",
        "type": "file",
        "lines": 0,
        "val": 6,
        "color": "#3178c6",
        "baseColor": "#3178c6",
        "originalColor": "#3178c6",
        "defaultGlow": 0.1,
        "glowIntensity": 0.1,
        "highlighted": false,
        "parentPath": "koma-fill/backend/src/repositories",
        "childFileCount": 0
      },
      {
        "id": "koma-fill/backend/src/repositories/projectRepository.ts",
        "name": "projectRepository.ts",
        "path": "koma-fill/backend/src/repositories/projectRepository.ts",
        "type": "file",
        "lines": 0,
        "val": 6,
        "color": "#3178c6",
        "baseColor": "#3178c6",
        "originalColor": "#3178c6",
        "defaultGlow": 0.1,
        "glowIntensity": 0.1,
        "highlighted": false,
        "parentPath": "koma-fill/backend/src/repositories",
        "childFileCount": 0
      },
      {
        "id": "koma-fill/backend/src/routes",
        "name": "routes",
        "path": "koma-fill/backend/src/routes",
        "type": "directory",
        "lines": 0,
        "val": 14,
        "color": "#4d515a",
        "baseColor": "#4ec9b0",
        "originalColor": "#4ec9b0",
        "defaultGlow": 0.18,
        "glowIntensity": 0.18,
        "highlighted": false,
        "parentPath": "koma-fill/backend/src",
        "childFileCount": 1
      },
      {
        "id": "koma-fill/backend/src/routes/manga.ts",
        "name": "manga.ts",
        "path": "koma-fill/backend/src/routes/manga.ts",
        "type": "file",
        "lines": 0,
        "val": 6,
        "color": "#3178c6",
        "baseColor": "#3178c6",
        "originalColor": "#3178c6",
        "defaultGlow": 0.1,
        "glowIntensity": 0.1,
        "highlighted": false,
        "parentPath": "koma-fill/backend/src/routes",
        "childFileCount": 0
      },
      {
        "id": "koma-fill/backend/src/services",
        "name": "services",
        "path": "koma-fill/backend/src/services",
        "type": "directory",
        "lines": 0,
        "val": 14,
        "color": "#4d515a",
        "baseColor": "#4ec9b0",
        "originalColor": "#4ec9b0",
        "defaultGlow": 0.18,
        "glowIntensity": 0.18,
        "highlighted": false,
        "parentPath": "koma-fill/backend/src",
        "childFileCount": 5
      },
      {
        "id": "koma-fill/backend/src/services/exportService.ts",
        "name": "exportService.ts",
        "path": "koma-fill/backend/src/services/exportService.ts",
        "type": "file",
        "lines": 0,
        "val": 6,
        "color": "#3178c6",
        "baseColor": "#3178c6",
        "originalColor": "#3178c6",
        "defaultGlow": 0.1,
        "glowIntensity": 0.1,
        "highlighted": false,
        "parentPath": "koma-fill/backend/src/services",
        "childFileCount": 0
      },
      {
        "id": "koma-fill/backend/src/services/imageAnalysisService.ts",
        "name": "imageAnalysisService.ts",
        "path": "koma-fill/backend/src/services/imageAnalysisService.ts",
        "type": "file",
        "lines": 0,
        "val": 6,
        "color": "#3178c6",
        "baseColor": "#3178c6",
        "originalColor": "#3178c6",
        "defaultGlow": 0.1,
        "glowIntensity": 0.1,
        "highlighted": false,
        "parentPath": "koma-fill/backend/src/services",
        "childFileCount": 0
      },
      {
        "id": "koma-fill/backend/src/services/imageGenerationService.ts",
        "name": "imageGenerationService.ts",
        "path": "koma-fill/backend/src/services/imageGenerationService.ts",
        "type": "file",
        "lines": 0,
        "val": 6,
        "color": "#3178c6",
        "baseColor": "#3178c6",
        "originalColor": "#3178c6",
        "defaultGlow": 0.1,
        "glowIntensity": 0.1,
        "highlighted": false,
        "parentPath": "koma-fill/backend/src/services",
        "childFileCount": 0
      },
      {
        "id": "koma-fill/backend/src/services/layoutEngine.ts",
        "name": "layoutEngine.ts",
        "path": "koma-fill/backend/src/services/layoutEngine.ts",
        "type": "file",
        "lines": 0,
        "val": 6,
        "color": "#3178c6",
        "baseColor": "#3178c6",
        "originalColor": "#3178c6",
        "defaultGlow": 0.1,
        "glowIntensity": 0.1,
        "highlighted": false,
        "parentPath": "koma-fill/backend/src/services",
        "childFileCount": 0
      },
      {
        "id": "koma-fill/backend/src/services/promptGenerationService.ts",
        "name": "promptGenerationService.ts",
        "path": "koma-fill/backend/src/services/promptGenerationService.ts",
        "type": "file",
        "lines": 0,
        "val": 6,
        "color": "#3178c6",
        "baseColor": "#3178c6",
        "originalColor": "#3178c6",
        "defaultGlow": 0.1,
        "glowIntensity": 0.1,
        "highlighted": false,
        "parentPath": "koma-fill/backend/src/services",
        "childFileCount": 0
      },
      {
        "id": "koma-fill/backend/src/utils",
        "name": "utils",
        "path": "koma-fill/backend/src/utils",
        "type": "directory",
        "lines": 0,
        "val": 14,
        "color": "#4d515a",
        "baseColor": "#4ec9b0",
        "originalColor": "#4ec9b0",
        "defaultGlow": 0.18,
        "glowIntensity": 0.18,
        "highlighted": false,
        "parentPath": "koma-fill/backend/src",
        "childFileCount": 1
      },
      {
        "id": "koma-fill/backend/src/utils/imageProcessor.ts",
        "name": "imageProcessor.ts",
        "path": "koma-fill/backend/src/utils/imageProcessor.ts",
        "type": "file",
        "lines": 0,
        "val": 6,
        "color": "#3178c6",
        "baseColor": "#3178c6",
        "originalColor": "#3178c6",
        "defaultGlow": 0.1,
        "glowIntensity": 0.1,
        "highlighted": false,
        "parentPath": "koma-fill/backend/src/utils",
        "childFileCount": 0
      },
      {
        "id": "koma-fill/backend/src/app.ts",
        "name": "app.ts",
        "path": "koma-fill/backend/src/app.ts",
        "type": "file",
        "lines": 0,
        "val": 6,
        "color": "#3178c6",
        "baseColor": "#3178c6",
        "originalColor": "#3178c6",
        "defaultGlow": 0.1,
        "glowIntensity": 0.1,
        "highlighted": false,
        "parentPath": "koma-fill/backend/src",
        "childFileCount": 0
      },
      {
        "id": "koma-fill/backend/src/index.ts",
        "name": "index.ts",
        "path": "koma-fill/backend/src/index.ts",
        "type": "file",
        "lines": 0,
        "val": 6,
        "color": "#3178c6",
        "baseColor": "#3178c6",
        "originalColor": "#3178c6",
        "defaultGlow": 0.1,
        "glowIntensity": 0.1,
        "highlighted": false,
        "parentPath": "koma-fill/backend/src",
        "childFileCount": 0
      },
      {
        "id": "koma-fill/backend/uploads",
        "name": "uploads",
        "path": "koma-fill/backend/uploads",
        "type": "directory",
        "lines": 0,
        "val": 14,
        "color": "#4d515a",
        "baseColor": "#4ec9b0",
        "originalColor": "#4ec9b0",
        "defaultGlow": 0.18,
        "glowIntensity": 0.18,
        "highlighted": false,
        "parentPath": "koma-fill/backend",
        "childFileCount": 0
      },
      {
        "id": "koma-fill/backend/package-lock.json",
        "name": "package-lock.json",
        "path": "koma-fill/backend/package-lock.json",
        "type": "file",
        "lines": 0,
        "val": 6,
        "color": "#8e44ad",
        "baseColor": "#8e44ad",
        "originalColor": "#8e44ad",
        "defaultGlow": 0.18,
        "glowIntensity": 0.18,
        "highlighted": false,
        "parentPath": "koma-fill/backend",
        "childFileCount": 0
      },
      {
        "id": "koma-fill/backend/package.json",
        "name": "package.json",
        "path": "koma-fill/backend/package.json",
        "type": "file",
        "lines": 0,
        "val": 6,
        "color": "#8e44ad",
        "baseColor": "#8e44ad",
        "originalColor": "#8e44ad",
        "defaultGlow": 0.18,
        "glowIntensity": 0.18,
        "highlighted": false,
        "parentPath": "koma-fill/backend",
        "childFileCount": 0
      },
      {
        "id": "koma-fill/backend/tsconfig.json",
        "name": "tsconfig.json",
        "path": "koma-fill/backend/tsconfig.json",
        "type": "file",
        "lines": 0,
        "val": 6,
        "color": "#8e44ad",
        "baseColor": "#8e44ad",
        "originalColor": "#8e44ad",
        "defaultGlow": 0.18,
        "glowIntensity": 0.18,
        "highlighted": false,
        "parentPath": "koma-fill/backend",
        "childFileCount": 0
      },
      {
        "id": "koma-fill/docs",
        "name": "docs",
        "path": "koma-fill/docs",
        "type": "directory",
        "lines": 0,
        "val": 14,
        "color": "#4d515a",
        "baseColor": "#4ec9b0",
        "originalColor": "#4ec9b0",
        "defaultGlow": 0.18,
        "glowIntensity": 0.18,
        "highlighted": false,
        "parentPath": "koma-fill",
        "childFileCount": 4
      },
      {
        "id": "koma-fill/docs/API_SPEC.md",
        "name": "API_SPEC.md",
        "path": "koma-fill/docs/API_SPEC.md",
        "type": "file",
        "lines": 0,
        "val": 6,
        "color": "#3498db",
        "baseColor": "#3498db",
        "originalColor": "#3498db",
        "defaultGlow": 0.18,
        "glowIntensity": 0.18,
        "highlighted": false,
        "parentPath": "koma-fill/docs",
        "childFileCount": 0
      },
      {
        "id": "koma-fill/docs/ARCHITECTURE.md",
        "name": "ARCHITECTURE.md",
        "path": "koma-fill/docs/ARCHITECTURE.md",
        "type": "file",
        "lines": 0,
        "val": 6,
        "color": "#3498db",
        "baseColor": "#3498db",
        "originalColor": "#3498db",
        "defaultGlow": 0.18,
        "glowIntensity": 0.18,
        "highlighted": false,
        "parentPath": "koma-fill/docs",
        "childFileCount": 0
      },
      {
        "id": "koma-fill/docs/KAMUI_FIX_PROMPTS.md",
        "name": "KAMUI_FIX_PROMPTS.md",
        "path": "koma-fill/docs/KAMUI_FIX_PROMPTS.md",
        "type": "file",
        "lines": 0,
        "val": 6,
        "color": "#3498db",
        "baseColor": "#3498db",
        "originalColor": "#3498db",
        "defaultGlow": 0.18,
        "glowIntensity": 0.18,
        "highlighted": false,
        "parentPath": "koma-fill/docs",
        "childFileCount": 0
      },
      {
        "id": "koma-fill/docs/KAMUI_PROMPTS.md",
        "name": "KAMUI_PROMPTS.md",
        "path": "koma-fill/docs/KAMUI_PROMPTS.md",
        "type": "file",
        "lines": 0,
        "val": 6,
        "color": "#3498db",
        "baseColor": "#3498db",
        "originalColor": "#3498db",
        "defaultGlow": 0.18,
        "glowIntensity": 0.18,
        "highlighted": false,
        "parentPath": "koma-fill/docs",
        "childFileCount": 0
      },
      {
        "id": "koma-fill/frontend",
        "name": "frontend",
        "path": "koma-fill/frontend",
        "type": "directory",
        "lines": 0,
        "val": 14,
        "color": "#4d515a",
        "baseColor": "#4ec9b0",
        "originalColor": "#4ec9b0",
        "defaultGlow": 0.18,
        "glowIntensity": 0.18,
        "highlighted": false,
        "parentPath": "koma-fill",
        "childFileCount": 7
      },
      {
        "id": "koma-fill/frontend/src",
        "name": "src",
        "path": "koma-fill/frontend/src",
        "type": "directory",
        "lines": 0,
        "val": 14,
        "color": "#4d515a",
        "baseColor": "#4ec9b0",
        "originalColor": "#4ec9b0",
        "defaultGlow": 0.18,
        "glowIntensity": 0.18,
        "highlighted": false,
        "parentPath": "koma-fill/frontend",
        "childFileCount": 4
      },
      {
        "id": "koma-fill/frontend/src/components",
        "name": "components",
        "path": "koma-fill/frontend/src/components",
        "type": "directory",
        "lines": 0,
        "val": 14,
        "color": "#4d515a",
        "baseColor": "#4ec9b0",
        "originalColor": "#4ec9b0",
        "defaultGlow": 0.18,
        "glowIntensity": 0.18,
        "highlighted": false,
        "parentPath": "koma-fill/frontend/src",
        "childFileCount": 6
      },
      {
        "id": "koma-fill/frontend/src/components/ExportOptions.tsx",
        "name": "ExportOptions.tsx",
        "path": "koma-fill/frontend/src/components/ExportOptions.tsx",
        "type": "file",
        "lines": 0,
        "val": 6,
        "color": "#61dafb",
        "baseColor": "#61dafb",
        "originalColor": "#61dafb",
        "defaultGlow": 0.1,
        "glowIntensity": 0.1,
        "highlighted": false,
        "parentPath": "koma-fill/frontend/src/components",
        "childFileCount": 0
      },
      {
        "id": "koma-fill/frontend/src/components/ImageUploader.tsx",
        "name": "ImageUploader.tsx",
        "path": "koma-fill/frontend/src/components/ImageUploader.tsx",
        "type": "file",
        "lines": 0,
        "val": 6,
        "color": "#61dafb",
        "baseColor": "#61dafb",
        "originalColor": "#61dafb",
        "defaultGlow": 0.1,
        "glowIntensity": 0.1,
        "highlighted": false,
        "parentPath": "koma-fill/frontend/src/components",
        "childFileCount": 0
      },
      {
        "id": "koma-fill/frontend/src/components/LayoutSelector.tsx",
        "name": "LayoutSelector.tsx",
        "path": "koma-fill/frontend/src/components/LayoutSelector.tsx",
        "type": "file",
        "lines": 0,
        "val": 6,
        "color": "#61dafb",
        "baseColor": "#61dafb",
        "originalColor": "#61dafb",
        "defaultGlow": 0.1,
        "glowIntensity": 0.1,
        "highlighted": false,
        "parentPath": "koma-fill/frontend/src/components",
        "childFileCount": 0
      },
      {
        "id": "koma-fill/frontend/src/components/PanelGrid.tsx",
        "name": "PanelGrid.tsx",
        "path": "koma-fill/frontend/src/components/PanelGrid.tsx",
        "type": "file",
        "lines": 0,
        "val": 6,
        "color": "#61dafb",
        "baseColor": "#61dafb",
        "originalColor": "#61dafb",
        "defaultGlow": 0.1,
        "glowIntensity": 0.1,
        "highlighted": false,
        "parentPath": "koma-fill/frontend/src/components",
        "childFileCount": 0
      },
      {
        "id": "koma-fill/frontend/src/components/ProgressBar.tsx",
        "name": "ProgressBar.tsx",
        "path": "koma-fill/frontend/src/components/ProgressBar.tsx",
        "type": "file",
        "lines": 0,
        "val": 6,
        "color": "#61dafb",
        "baseColor": "#61dafb",
        "originalColor": "#61dafb",
        "defaultGlow": 0.1,
        "glowIntensity": 0.1,
        "highlighted": false,
        "parentPath": "koma-fill/frontend/src/components",
        "childFileCount": 0
      },
      {
        "id": "koma-fill/frontend/src/components/StoryPromptEditor.tsx",
        "name": "StoryPromptEditor.tsx",
        "path": "koma-fill/frontend/src/components/StoryPromptEditor.tsx",
        "type": "file",
        "lines": 0,
        "val": 6,
        "color": "#61dafb",
        "baseColor": "#61dafb",
        "originalColor": "#61dafb",
        "defaultGlow": 0.1,
        "glowIntensity": 0.1,
        "highlighted": false,
        "parentPath": "koma-fill/frontend/src/components",
        "childFileCount": 0
      },
      {
        "id": "koma-fill/frontend/src/hooks",
        "name": "hooks",
        "path": "koma-fill/frontend/src/hooks",
        "type": "directory",
        "lines": 0,
        "val": 14,
        "color": "#4d515a",
        "baseColor": "#4ec9b0",
        "originalColor": "#4ec9b0",
        "defaultGlow": 0.18,
        "glowIntensity": 0.18,
        "highlighted": false,
        "parentPath": "koma-fill/frontend/src",
        "childFileCount": 1
      },
      {
        "id": "koma-fill/frontend/src/hooks/useMangaGeneration.ts",
        "name": "useMangaGeneration.ts",
        "path": "koma-fill/frontend/src/hooks/useMangaGeneration.ts",
        "type": "file",
        "lines": 0,
        "val": 6,
        "color": "#3178c6",
        "baseColor": "#3178c6",
        "originalColor": "#3178c6",
        "defaultGlow": 0.1,
        "glowIntensity": 0.1,
        "highlighted": false,
        "parentPath": "koma-fill/frontend/src/hooks",
        "childFileCount": 0
      },
      {
        "id": "koma-fill/frontend/src/pages",
        "name": "pages",
        "path": "koma-fill/frontend/src/pages",
        "type": "directory",
        "lines": 0,
        "val": 14,
        "color": "#4d515a",
        "baseColor": "#4ec9b0",
        "originalColor": "#4ec9b0",
        "defaultGlow": 0.18,
        "glowIntensity": 0.18,
        "highlighted": false,
        "parentPath": "koma-fill/frontend/src",
        "childFileCount": 2
      },
      {
        "id": "koma-fill/frontend/src/pages/CreateMangaPage.tsx",
        "name": "CreateMangaPage.tsx",
        "path": "koma-fill/frontend/src/pages/CreateMangaPage.tsx",
        "type": "file",
        "lines": 0,
        "val": 6,
        "color": "#61dafb",
        "baseColor": "#61dafb",
        "originalColor": "#61dafb",
        "defaultGlow": 0.1,
        "glowIntensity": 0.1,
        "highlighted": false,
        "parentPath": "koma-fill/frontend/src/pages",
        "childFileCount": 0
      },
      {
        "id": "koma-fill/frontend/src/pages/PreviewPage.tsx",
        "name": "PreviewPage.tsx",
        "path": "koma-fill/frontend/src/pages/PreviewPage.tsx",
        "type": "file",
        "lines": 0,
        "val": 6,
        "color": "#61dafb",
        "baseColor": "#61dafb",
        "originalColor": "#61dafb",
        "defaultGlow": 0.1,
        "glowIntensity": 0.1,
        "highlighted": false,
        "parentPath": "koma-fill/frontend/src/pages",
        "childFileCount": 0
      },
      {
        "id": "koma-fill/frontend/src/services",
        "name": "services",
        "path": "koma-fill/frontend/src/services",
        "type": "directory",
        "lines": 0,
        "val": 14,
        "color": "#4d515a",
        "baseColor": "#4ec9b0",
        "originalColor": "#4ec9b0",
        "defaultGlow": 0.18,
        "glowIntensity": 0.18,
        "highlighted": false,
        "parentPath": "koma-fill/frontend/src",
        "childFileCount": 1
      },
      {
        "id": "koma-fill/frontend/src/services/apiClient.ts",
        "name": "apiClient.ts",
        "path": "koma-fill/frontend/src/services/apiClient.ts",
        "type": "file",
        "lines": 0,
        "val": 6,
        "color": "#3178c6",
        "baseColor": "#3178c6",
        "originalColor": "#3178c6",
        "defaultGlow": 0.1,
        "glowIntensity": 0.1,
        "highlighted": false,
        "parentPath": "koma-fill/frontend/src/services",
        "childFileCount": 0
      },
      {
        "id": "koma-fill/frontend/src/types",
        "name": "types",
        "path": "koma-fill/frontend/src/types",
        "type": "directory",
        "lines": 0,
        "val": 14,
        "color": "#4d515a",
        "baseColor": "#4ec9b0",
        "originalColor": "#4ec9b0",
        "defaultGlow": 0.18,
        "glowIntensity": 0.18,
        "highlighted": false,
        "parentPath": "koma-fill/frontend/src",
        "childFileCount": 1
      },
      {
        "id": "koma-fill/frontend/src/types/index.ts",
        "name": "index.ts",
        "path": "koma-fill/frontend/src/types/index.ts",
        "type": "file",
        "lines": 0,
        "val": 6,
        "color": "#3178c6",
        "baseColor": "#3178c6",
        "originalColor": "#3178c6",
        "defaultGlow": 0.1,
        "glowIntensity": 0.1,
        "highlighted": false,
        "parentPath": "koma-fill/frontend/src/types",
        "childFileCount": 0
      },
      {
        "id": "koma-fill/frontend/src/App.tsx",
        "name": "App.tsx",
        "path": "koma-fill/frontend/src/App.tsx",
        "type": "file",
        "lines": 0,
        "val": 6,
        "color": "#61dafb",
        "baseColor": "#61dafb",
        "originalColor": "#61dafb",
        "defaultGlow": 0.1,
        "glowIntensity": 0.1,
        "highlighted": false,
        "parentPath": "koma-fill/frontend/src",
        "childFileCount": 0
      },
      {
        "id": "koma-fill/frontend/src/index.css",
        "name": "index.css",
        "path": "koma-fill/frontend/src/index.css",
        "type": "file",
        "lines": 0,
        "val": 6,
        "color": "#1572b6",
        "baseColor": "#1572b6",
        "originalColor": "#1572b6",
        "defaultGlow": 0.18,
        "glowIntensity": 0.18,
        "highlighted": false,
        "parentPath": "koma-fill/frontend/src",
        "childFileCount": 0
      },
      {
        "id": "koma-fill/frontend/src/main.tsx",
        "name": "main.tsx",
        "path": "koma-fill/frontend/src/main.tsx",
        "type": "file",
        "lines": 0,
        "val": 6,
        "color": "#61dafb",
        "baseColor": "#61dafb",
        "originalColor": "#61dafb",
        "defaultGlow": 0.1,
        "glowIntensity": 0.1,
        "highlighted": false,
        "parentPath": "koma-fill/frontend/src",
        "childFileCount": 0
      },
      {
        "id": "koma-fill/frontend/src/vite-env.d.ts",
        "name": "vite-env.d.ts",
        "path": "koma-fill/frontend/src/vite-env.d.ts",
        "type": "file",
        "lines": 0,
        "val": 6,
        "color": "#3178c6",
        "baseColor": "#3178c6",
        "originalColor": "#3178c6",
        "defaultGlow": 0.1,
        "glowIntensity": 0.1,
        "highlighted": false,
        "parentPath": "koma-fill/frontend/src",
        "childFileCount": 0
      },
      {
        "id": "koma-fill/frontend/index.html",
        "name": "index.html",
        "path": "koma-fill/frontend/index.html",
        "type": "file",
        "lines": 0,
        "val": 6,
        "color": "#e44d26",
        "baseColor": "#e44d26",
        "originalColor": "#e44d26",
        "defaultGlow": 0.18,
        "glowIntensity": 0.18,
        "highlighted": false,
        "parentPath": "koma-fill/frontend",
        "childFileCount": 0
      },
      {
        "id": "koma-fill/frontend/package-lock.json",
        "name": "package-lock.json",
        "path": "koma-fill/frontend/package-lock.json",
        "type": "file",
        "lines": 0,
        "val": 6,
        "color": "#8e44ad",
        "baseColor": "#8e44ad",
        "originalColor": "#8e44ad",
        "defaultGlow": 0.18,
        "glowIntensity": 0.18,
        "highlighted": false,
        "parentPath": "koma-fill/frontend",
        "childFileCount": 0
      },
      {
        "id": "koma-fill/frontend/package.json",
        "name": "package.json",
        "path": "koma-fill/frontend/package.json",
        "type": "file",
        "lines": 0,
        "val": 6,
        "color": "#8e44ad",
        "baseColor": "#8e44ad",
        "originalColor": "#8e44ad",
        "defaultGlow": 0.18,
        "glowIntensity": 0.18,
        "highlighted": false,
        "parentPath": "koma-fill/frontend",
        "childFileCount": 0
      },
      {
        "id": "koma-fill/frontend/postcss.config.js",
        "name": "postcss.config.js",
        "path": "koma-fill/frontend/postcss.config.js",
        "type": "file",
        "lines": 0,
        "val": 6,
        "color": "#f7df1e",
        "baseColor": "#f7df1e",
        "originalColor": "#f7df1e",
        "defaultGlow": 0.1,
        "glowIntensity": 0.1,
        "highlighted": false,
        "parentPath": "koma-fill/frontend",
        "childFileCount": 0
      },
      {
        "id": "koma-fill/frontend/tailwind.config.js",
        "name": "tailwind.config.js",
        "path": "koma-fill/frontend/tailwind.config.js",
        "type": "file",
        "lines": 0,
        "val": 6,
        "color": "#f7df1e",
        "baseColor": "#f7df1e",
        "originalColor": "#f7df1e",
        "defaultGlow": 0.1,
        "glowIntensity": 0.1,
        "highlighted": false,
        "parentPath": "koma-fill/frontend",
        "childFileCount": 0
      },
      {
        "id": "koma-fill/frontend/tsconfig.json",
        "name": "tsconfig.json",
        "path": "koma-fill/frontend/tsconfig.json",
        "type": "file",
        "lines": 0,
        "val": 6,
        "color": "#8e44ad",
        "baseColor": "#8e44ad",
        "originalColor": "#8e44ad",
        "defaultGlow": 0.18,
        "glowIntensity": 0.18,
        "highlighted": false,
        "parentPath": "koma-fill/frontend",
        "childFileCount": 0
      },
      {
        "id": "koma-fill/frontend/vite.config.ts",
        "name": "vite.config.ts",
        "path": "koma-fill/frontend/vite.config.ts",
        "type": "file",
        "lines": 0,
        "val": 6,
        "color": "#3178c6",
        "baseColor": "#3178c6",
        "originalColor": "#3178c6",
        "defaultGlow": 0.1,
        "glowIntensity": 0.1,
        "highlighted": false,
        "parentPath": "koma-fill/frontend",
        "childFileCount": 0
      },
      {
        "id": "koma-fill/node_modules",
        "name": "node_modules",
        "path": "koma-fill/node_modules",
        "type": "directory",
        "lines": 0,
        "val": 14,
        "color": "#4d515a",
        "baseColor": "#4ec9b0",
        "originalColor": "#4ec9b0",
        "defaultGlow": 0.18,
        "glowIntensity": 0.18,
        "highlighted": false,
        "parentPath": "koma-fill",
        "childFileCount": 0
      },
      {
        "id": "koma-fill/output",
        "name": "output",
        "path": "koma-fill/output",
        "type": "directory",
        "lines": 0,
        "val": 14,
        "color": "#4d515a",
        "baseColor": "#4ec9b0",
        "originalColor": "#4ec9b0",
        "defaultGlow": 0.18,
        "glowIntensity": 0.18,
        "highlighted": false,
        "parentPath": "koma-fill",
        "childFileCount": 0
      },
      {
        "id": "koma-fill/uploads",
        "name": "uploads",
        "path": "koma-fill/uploads",
        "type": "directory",
        "lines": 0,
        "val": 14,
        "color": "#4d515a",
        "baseColor": "#4ec9b0",
        "originalColor": "#4ec9b0",
        "defaultGlow": 0.18,
        "glowIntensity": 0.18,
        "highlighted": false,
        "parentPath": "koma-fill",
        "childFileCount": 0
      },
      {
        "id": "koma-fill/.DS_Store",
        "name": ".DS_Store",
        "path": "koma-fill/.DS_Store",
        "type": "file",
        "lines": 0,
        "val": 6,
        "color": "#57606f",
        "baseColor": "#57606f",
        "originalColor": "#57606f",
        "defaultGlow": 0.18,
        "glowIntensity": 0.18,
        "highlighted": false,
        "parentPath": "koma-fill",
        "childFileCount": 0
      },
      {
        "id": "koma-fill/.env",
        "name": ".env",
        "path": "koma-fill/.env",
        "type": "file",
        "lines": 0,
        "val": 6,
        "color": "#57606f",
        "baseColor": "#57606f",
        "originalColor": "#57606f",
        "defaultGlow": 0.18,
        "glowIntensity": 0.18,
        "highlighted": false,
        "parentPath": "koma-fill",
        "childFileCount": 0
      },
      {
        "id": "koma-fill/.env.example",
        "name": ".env.example",
        "path": "koma-fill/.env.example",
        "type": "file",
        "lines": 0,
        "val": 6,
        "color": "#57606f",
        "baseColor": "#57606f",
        "originalColor": "#57606f",
        "defaultGlow": 0.18,
        "glowIntensity": 0.18,
        "highlighted": false,
        "parentPath": "koma-fill",
        "childFileCount": 0
      },
      {
        "id": "koma-fill/.gitignore",
        "name": ".gitignore",
        "path": "koma-fill/.gitignore",
        "type": "file",
        "lines": 0,
        "val": 6,
        "color": "#57606f",
        "baseColor": "#57606f",
        "originalColor": "#57606f",
        "defaultGlow": 0.18,
        "glowIntensity": 0.18,
        "highlighted": false,
        "parentPath": "koma-fill",
        "childFileCount": 0
      },
      {
        "id": "koma-fill/CONTEXT.md",
        "name": "CONTEXT.md",
        "path": "koma-fill/CONTEXT.md",
        "type": "file",
        "lines": 0,
        "val": 6,
        "color": "#3498db",
        "baseColor": "#3498db",
        "originalColor": "#3498db",
        "defaultGlow": 0.18,
        "glowIntensity": 0.18,
        "highlighted": false,
        "parentPath": "koma-fill",
        "childFileCount": 0
      },
      {
        "id": "koma-fill/eslint.config.js",
        "name": "eslint.config.js",
        "path": "koma-fill/eslint.config.js",
        "type": "file",
        "lines": 0,
        "val": 6,
        "color": "#f7df1e",
        "baseColor": "#f7df1e",
        "originalColor": "#f7df1e",
        "defaultGlow": 0.1,
        "glowIntensity": 0.1,
        "highlighted": false,
        "parentPath": "koma-fill",
        "childFileCount": 0
      },
      {
        "id": "koma-fill/package-lock.json",
        "name": "package-lock.json",
        "path": "koma-fill/package-lock.json",
        "type": "file",
        "lines": 0,
        "val": 6,
        "color": "#8e44ad",
        "baseColor": "#8e44ad",
        "originalColor": "#8e44ad",
        "defaultGlow": 0.18,
        "glowIntensity": 0.18,
        "highlighted": false,
        "parentPath": "koma-fill",
        "childFileCount": 0
      },
      {
        "id": "koma-fill/package.json",
        "name": "package.json",
        "path": "koma-fill/package.json",
        "type": "file",
        "lines": 0,
        "val": 6,
        "color": "#8e44ad",
        "baseColor": "#8e44ad",
        "originalColor": "#8e44ad",
        "defaultGlow": 0.18,
        "glowIntensity": 0.18,
        "highlighted": false,
        "parentPath": "koma-fill",
        "childFileCount": 0
      }
    ],
    "links": [
      {
        "source": "koma-fill",
        "target": "koma-fill/.kamui",
        "type": "tree"
      },
      {
        "source": "koma-fill",
        "target": "koma-fill/.worktrees",
        "type": "tree"
      },
      {
        "source": "koma-fill",
        "target": "koma-fill/backend",
        "type": "tree"
      },
      {
        "source": "koma-fill/backend",
        "target": "koma-fill/backend/data",
        "type": "tree"
      },
      {
        "source": "koma-fill/backend",
        "target": "koma-fill/backend/src",
        "type": "tree"
      },
      {
        "source": "koma-fill/backend/src",
        "target": "koma-fill/backend/src/config",
        "type": "tree"
      },
      {
        "source": "koma-fill/backend/src/config",
        "target": "koma-fill/backend/src/config/constants.ts",
        "type": "tree"
      },
      {
        "source": "koma-fill/backend/src",
        "target": "koma-fill/backend/src/database",
        "type": "tree"
      },
      {
        "source": "koma-fill/backend/src/database",
        "target": "koma-fill/backend/src/database/connection.ts",
        "type": "tree"
      },
      {
        "source": "koma-fill/backend/src/database",
        "target": "koma-fill/backend/src/database/schema.ts",
        "type": "tree"
      },
      {
        "source": "koma-fill/backend/src",
        "target": "koma-fill/backend/src/middleware",
        "type": "tree"
      },
      {
        "source": "koma-fill/backend/src/middleware",
        "target": "koma-fill/backend/src/middleware/errorHandler.ts",
        "type": "tree"
      },
      {
        "source": "koma-fill/backend/src",
        "target": "koma-fill/backend/src/models",
        "type": "tree"
      },
      {
        "source": "koma-fill/backend/src/models",
        "target": "koma-fill/backend/src/models/types.ts",
        "type": "tree"
      },
      {
        "source": "koma-fill/backend/src",
        "target": "koma-fill/backend/src/repositories",
        "type": "tree"
      },
      {
        "source": "koma-fill/backend/src/repositories",
        "target": "koma-fill/backend/src/repositories/keyImageRepository.ts",
        "type": "tree"
      },
      {
        "source": "koma-fill/backend/src/repositories",
        "target": "koma-fill/backend/src/repositories/panelRepository.ts",
        "type": "tree"
      },
      {
        "source": "koma-fill/backend/src/repositories",
        "target": "koma-fill/backend/src/repositories/projectRepository.ts",
        "type": "tree"
      },
      {
        "source": "koma-fill/backend/src",
        "target": "koma-fill/backend/src/routes",
        "type": "tree"
      },
      {
        "source": "koma-fill/backend/src/routes",
        "target": "koma-fill/backend/src/routes/manga.ts",
        "type": "tree"
      },
      {
        "source": "koma-fill/backend/src",
        "target": "koma-fill/backend/src/services",
        "type": "tree"
      },
      {
        "source": "koma-fill/backend/src/services",
        "target": "koma-fill/backend/src/services/exportService.ts",
        "type": "tree"
      },
      {
        "source": "koma-fill/backend/src/services",
        "target": "koma-fill/backend/src/services/imageAnalysisService.ts",
        "type": "tree"
      },
      {
        "source": "koma-fill/backend/src/services",
        "target": "koma-fill/backend/src/services/imageGenerationService.ts",
        "type": "tree"
      },
      {
        "source": "koma-fill/backend/src/services",
        "target": "koma-fill/backend/src/services/layoutEngine.ts",
        "type": "tree"
      },
      {
        "source": "koma-fill/backend/src/services",
        "target": "koma-fill/backend/src/services/promptGenerationService.ts",
        "type": "tree"
      },
      {
        "source": "koma-fill/backend/src",
        "target": "koma-fill/backend/src/utils",
        "type": "tree"
      },
      {
        "source": "koma-fill/backend/src/utils",
        "target": "koma-fill/backend/src/utils/imageProcessor.ts",
        "type": "tree"
      },
      {
        "source": "koma-fill/backend/src",
        "target": "koma-fill/backend/src/app.ts",
        "type": "tree"
      },
      {
        "source": "koma-fill/backend/src",
        "target": "koma-fill/backend/src/index.ts",
        "type": "tree"
      },
      {
        "source": "koma-fill/backend",
        "target": "koma-fill/backend/uploads",
        "type": "tree"
      },
      {
        "source": "koma-fill/backend",
        "target": "koma-fill/backend/package-lock.json",
        "type": "tree"
      },
      {
        "source": "koma-fill/backend",
        "target": "koma-fill/backend/package.json",
        "type": "tree"
      },
      {
        "source": "koma-fill/backend",
        "target": "koma-fill/backend/tsconfig.json",
        "type": "tree"
      },
      {
        "source": "koma-fill",
        "target": "koma-fill/docs",
        "type": "tree"
      },
      {
        "source": "koma-fill/docs",
        "target": "koma-fill/docs/API_SPEC.md",
        "type": "tree"
      },
      {
        "source": "koma-fill/docs",
        "target": "koma-fill/docs/ARCHITECTURE.md",
        "type": "tree"
      },
      {
        "source": "koma-fill/docs",
        "target": "koma-fill/docs/KAMUI_FIX_PROMPTS.md",
        "type": "tree"
      },
      {
        "source": "koma-fill/docs",
        "target": "koma-fill/docs/KAMUI_PROMPTS.md",
        "type": "tree"
      },
      {
        "source": "koma-fill",
        "target": "koma-fill/frontend",
        "type": "tree"
      },
      {
        "source": "koma-fill/frontend",
        "target": "koma-fill/frontend/src",
        "type": "tree"
      },
      {
        "source": "koma-fill/frontend/src",
        "target": "koma-fill/frontend/src/components",
        "type": "tree"
      },
      {
        "source": "koma-fill/frontend/src/components",
        "target": "koma-fill/frontend/src/components/ExportOptions.tsx",
        "type": "tree"
      },
      {
        "source": "koma-fill/frontend/src/components",
        "target": "koma-fill/frontend/src/components/ImageUploader.tsx",
        "type": "tree"
      },
      {
        "source": "koma-fill/frontend/src/components",
        "target": "koma-fill/frontend/src/components/LayoutSelector.tsx",
        "type": "tree"
      },
      {
        "source": "koma-fill/frontend/src/components",
        "target": "koma-fill/frontend/src/components/PanelGrid.tsx",
        "type": "tree"
      },
      {
        "source": "koma-fill/frontend/src/components",
        "target": "koma-fill/frontend/src/components/ProgressBar.tsx",
        "type": "tree"
      },
      {
        "source": "koma-fill/frontend/src/components",
        "target": "koma-fill/frontend/src/components/StoryPromptEditor.tsx",
        "type": "tree"
      },
      {
        "source": "koma-fill/frontend/src",
        "target": "koma-fill/frontend/src/hooks",
        "type": "tree"
      },
      {
        "source": "koma-fill/frontend/src/hooks",
        "target": "koma-fill/frontend/src/hooks/useMangaGeneration.ts",
        "type": "tree"
      },
      {
        "source": "koma-fill/frontend/src",
        "target": "koma-fill/frontend/src/pages",
        "type": "tree"
      },
      {
        "source": "koma-fill/frontend/src/pages",
        "target": "koma-fill/frontend/src/pages/CreateMangaPage.tsx",
        "type": "tree"
      },
      {
        "source": "koma-fill/frontend/src/pages",
        "target": "koma-fill/frontend/src/pages/PreviewPage.tsx",
        "type": "tree"
      },
      {
        "source": "koma-fill/frontend/src",
        "target": "koma-fill/frontend/src/services",
        "type": "tree"
      },
      {
        "source": "koma-fill/frontend/src/services",
        "target": "koma-fill/frontend/src/services/apiClient.ts",
        "type": "tree"
      },
      {
        "source": "koma-fill/frontend/src",
        "target": "koma-fill/frontend/src/types",
        "type": "tree"
      },
      {
        "source": "koma-fill/frontend/src/types",
        "target": "koma-fill/frontend/src/types/index.ts",
        "type": "tree"
      },
      {
        "source": "koma-fill/frontend/src",
        "target": "koma-fill/frontend/src/App.tsx",
        "type": "tree"
      },
      {
        "source": "koma-fill/frontend/src",
        "target": "koma-fill/frontend/src/index.css",
        "type": "tree"
      },
      {
        "source": "koma-fill/frontend/src",
        "target": "koma-fill/frontend/src/main.tsx",
        "type": "tree"
      },
      {
        "source": "koma-fill/frontend/src",
        "target": "koma-fill/frontend/src/vite-env.d.ts",
        "type": "tree"
      },
      {
        "source": "koma-fill/frontend",
        "target": "koma-fill/frontend/index.html",
        "type": "tree"
      },
      {
        "source": "koma-fill/frontend",
        "target": "koma-fill/frontend/package-lock.json",
        "type": "tree"
      },
      {
        "source": "koma-fill/frontend",
        "target": "koma-fill/frontend/package.json",
        "type": "tree"
      },
      {
        "source": "koma-fill/frontend",
        "target": "koma-fill/frontend/postcss.config.js",
        "type": "tree"
      },
      {
        "source": "koma-fill/frontend",
        "target": "koma-fill/frontend/tailwind.config.js",
        "type": "tree"
      },
      {
        "source": "koma-fill/frontend",
        "target": "koma-fill/frontend/tsconfig.json",
        "type": "tree"
      },
      {
        "source": "koma-fill/frontend",
        "target": "koma-fill/frontend/vite.config.ts",
        "type": "tree"
      },
      {
        "source": "koma-fill",
        "target": "koma-fill/node_modules",
        "type": "tree"
      },
      {
        "source": "koma-fill",
        "target": "koma-fill/output",
        "type": "tree"
      },
      {
        "source": "koma-fill",
        "target": "koma-fill/uploads",
        "type": "tree"
      },
      {
        "source": "koma-fill",
        "target": "koma-fill/.DS_Store",
        "type": "tree"
      },
      {
        "source": "koma-fill",
        "target": "koma-fill/.env",
        "type": "tree"
      },
      {
        "source": "koma-fill",
        "target": "koma-fill/.env.example",
        "type": "tree"
      },
      {
        "source": "koma-fill",
        "target": "koma-fill/.gitignore",
        "type": "tree"
      },
      {
        "source": "koma-fill",
        "target": "koma-fill/CONTEXT.md",
        "type": "tree"
      },
      {
        "source": "koma-fill",
        "target": "koma-fill/eslint.config.js",
        "type": "tree"
      },
      {
        "source": "koma-fill",
        "target": "koma-fill/package-lock.json",
        "type": "tree"
      },
      {
        "source": "koma-fill",
        "target": "koma-fill/package.json",
        "type": "tree"
      }
    ]
  },
  "trackedFiles": [
    ".env.example",
    ".gitignore",
    ".kamui/apps/kamui-os-intro-20251125.css",
    ".kamui/apps/kamui-os-intro-20251125.html",
    ".kamui/apps/kamui-os-intro-20251125.js",
    ".kamui/gantte/test.yaml",
    ".kamui/manager/202602122348_monitor_comp-1770907489752-910mgnrj.html",
    ".kamui/manager/202602122352_eval_task-1770907489752-910mgnrj.html",
    ".kamui/manager/202602130004_eval_task-1770907489752-910mgnrj.html",
    ".kamui/manager/202602130014_eval_comp-1770909068260-pccd6qsd.html",
    ".kamui/manager/202602130014_monitor_comp-1770909068260-pccd6qsd.html",
    ".kamui/manager/202602130018_eval_task-1770909068260-pccd6qsd.html",
    ".kamui/manager/202602130018_monitor_task-1770909068260-pccd6qsd.html",
    ".kamui/model-versions-cache.json",
    ".kamui/movie/media/cyberpunk-city-flight.mp4",
    ".kamui/movie/media/cyberpunk-cityscape.png",
    ".kamui/movie/media/cyberpunk-night/cyberpunk-cityscape.png",
    ".kamui/movie/media/cyberpunk-night/japanese-alley-scene.png",
    ".kamui/movie/media/cyberpunk-night/neon-dreams.mp3",
    ".kamui/movie/media/cyberpunk-night/rainy-night-lofi.mp3",
    ".kamui/movie/media/cyberpunk-night/workspace-plus.json",
    ".kamui/movie/media/cyberpunk-night/workspace.json",
    ".kamui/movie/media/japanese-alley-night.mp4",
    ".kamui/movie/media/japanese-alley-scene.png",
    ".kamui/movie/media/neon-dreams.mp3",
    ".kamui/movie/media/rainy-night-lofi.mp3",
    ".kamui/movie/media/tokyo-rain/cyberpunk-cityscape.png",
    ".kamui/movie/media/tokyo-rain/japanese-alley-scene.png",
    ".kamui/movie/media/tokyo-rain/neon-dreams.mp3",
    ".kamui/movie/media/tokyo-rain/rainy-night-lofi.mp3",
    ".kamui/movie/media/tokyo-rain/workspace.json",
    ".kamui/prompt/merge-prompt.txt",
    ".kamui/system-graph-state.json",
    ".kamui/tasks-state.json",
    "CONTEXT.md",
    "backend/package-lock.json",
    "backend/package.json",
    "backend/src/app.ts",
    "backend/src/config/constants.ts",
    "backend/src/database/connection.ts",
    "backend/src/database/schema.ts",
    "backend/src/index.ts",
    "backend/src/middleware/errorHandler.ts",
    "backend/src/models/types.ts",
    "backend/src/repositories/keyImageRepository.ts",
    "backend/src/repositories/panelRepository.ts",
    "backend/src/repositories/projectRepository.ts",
    "backend/src/routes/manga.ts",
    "backend/src/services/exportService.ts",
    "backend/src/services/imageAnalysisService.ts",
    "backend/src/services/imageGenerationService.ts",
    "backend/src/services/layoutEngine.ts",
    "backend/src/services/promptGenerationService.ts",
    "backend/src/utils/imageProcessor.ts",
    "backend/tsconfig.json",
    "docs/API_SPEC.md",
    "docs/ARCHITECTURE.md",
    "docs/KAMUI_FIX_PROMPTS.md",
    "docs/KAMUI_PROMPTS.md",
    "eslint.config.js",
    "frontend/index.html",
    "frontend/package-lock.json",
    "frontend/package.json",
    "frontend/postcss.config.js",
    "frontend/src/App.tsx",
    "frontend/src/components/ExportOptions.tsx",
    "frontend/src/components/ImageUploader.tsx",
    "frontend/src/components/LayoutSelector.tsx",
    "frontend/src/components/PanelGrid.tsx",
    "frontend/src/components/ProgressBar.tsx",
    "frontend/src/components/StoryPromptEditor.tsx",
    "frontend/src/hooks/useMangaGeneration.ts",
    "frontend/src/index.css",
    "frontend/src/main.tsx",
    "frontend/src/pages/CreateMangaPage.tsx",
    "frontend/src/pages/PreviewPage.tsx",
    "frontend/src/services/apiClient.ts",
    "frontend/src/types/index.ts",
    "frontend/src/vite-env.d.ts",
    "frontend/tailwind.config.js",
    "frontend/tsconfig.json",
    "frontend/vite.config.ts",
    "package-lock.json",
    "package.json"
  ],
  "uiState": {
    "expandedDirs": [
      "koma-fill",
      "koma-fill/koma-fill",
      "koma-fill/.kamui",
      "koma-fill/koma-fill/.kamui",
      "koma-fill/.kamui/apps",
      "koma-fill/koma-fill/.kamui/apps",
      "koma-fill/.kamui/gantte",
      "koma-fill/koma-fill/.kamui/gantte",
      "koma-fill/.kamui/movie",
      "koma-fill/koma-fill/.kamui/movie",
      "koma-fill/.kamui/movie/media",
      "koma-fill/koma-fill/.kamui/movie/media",
      "koma-fill/.kamui/movie/media/cyberpunk-night",
      "koma-fill/koma-fill/.kamui/movie/media/cyberpunk-night",
      "koma-fill/.kamui/movie/media/tokyo-rain",
      "koma-fill/koma-fill/.kamui/movie/media/tokyo-rain",
      "koma-fill/.kamui/prompt",
      "koma-fill/koma-fill/.kamui/prompt",
      "task-1770909069269-afb680",
      "task-1770909072180-65bb97",
      "koma-fill/.kamui/manager",
      "koma-fill/koma-fill/.kamui/manager",
      "koma-fill/backend",
      "koma-fill/koma-fill/backend",
      "koma-fill/backend/src",
      "koma-fill/koma-fill/backend/src",
      "koma-fill/backend/src/routes",
      "koma-fill/koma-fill/backend/src/routes",
      "koma-fill/backend/src/utils",
      "koma-fill/koma-fill/backend/src/utils",
      "koma-fill/frontend",
      "koma-fill/koma-fill/frontend",
      "koma-fill/frontend/src",
      "koma-fill/koma-fill/frontend/src",
      "koma-fill/frontend/src/components",
      "koma-fill/koma-fill/frontend/src/components",
      "koma-fill/frontend/src/hooks",
      "koma-fill/koma-fill/frontend/src/hooks",
      "koma-fill/frontend/src/pages",
      "koma-fill/koma-fill/frontend/src/pages",
      "koma-fill/frontend/src/services",
      "koma-fill/koma-fill/frontend/src/services",
      "koma-fill/frontend/src/types",
      "koma-fill/koma-fill/frontend/src/types",
      "koma-fill/docs",
      "koma-fill/koma-fill/docs",
      "task-1770918401706-38620f",
      "task-1770918405559-058889"
    ],
    "selectedPath": null
  },
  "directoryTreeMeta": {
    "mode": "full",
    "maxDepthApplied": 10,
    "maxEntriesPerDirectory": 0,
    "isPartial": false
  },
  "gitHistoryMeta": {
    "mode": "full",
    "isPartial": false,
    "branchPulse": {
      "generatedAt": 1770921961047,
      "targets": [
        "main",
        "task/task-1770909068262-a5d61b",
        "task/task-1770909068463-2984dc",
        "task/task-1770909068675-7f6691",
        "task/task-1770909068862-42049e",
        "task/task-1770909069061-f69cf1",
        "task/task-1770909069269-afb680",
        "task/task-1770918400673-d21f34",
        "task/task-1770918400875-2630f2",
        "task/task-1770918401073-c21f64",
        "task/task-1770918401380-e8add6",
        "task/task-1770918401534-118872",
        "task/task-1770918401706-38620f",
        "task/task-1770918405559-058889",
        "master"
      ],
      "statsByBranch": {
        "task/task-1770909068463-2984dc": {
          "branch": "task/task-1770909068463-2984dc",
          "head": "f504fb330085dd678241be890191ac269c049851",
          "baseRef": "main",
          "baseHead": "4b04b83e00427c27f96428671d1044fd0a38393a",
          "mergeBase": "f504fb330085dd678241be890191ac269c049851",
          "divergence": {
            "aheadCount": 0,
            "fileCount": 0
          },
          "baseline": {
            "aheadCount": 0,
            "behindCount": 6,
            "fileCount": 36
          },
          "upstream": null
        },
        "task/task-1770909068675-7f6691": {
          "branch": "task/task-1770909068675-7f6691",
          "head": "1515fedca072442ad0656037229bce50b2e341f3",
          "baseRef": "main",
          "baseHead": "4b04b83e00427c27f96428671d1044fd0a38393a",
          "mergeBase": "1515fedca072442ad0656037229bce50b2e341f3",
          "divergence": {
            "aheadCount": 0,
            "fileCount": 0
          },
          "baseline": {
            "aheadCount": 0,
            "behindCount": 7,
            "fileCount": 48
          },
          "upstream": null
        },
        "task/task-1770909068262-a5d61b": {
          "branch": "task/task-1770909068262-a5d61b",
          "head": "1515fedca072442ad0656037229bce50b2e341f3",
          "baseRef": "main",
          "baseHead": "4b04b83e00427c27f96428671d1044fd0a38393a",
          "mergeBase": "1515fedca072442ad0656037229bce50b2e341f3",
          "divergence": {
            "aheadCount": 0,
            "fileCount": 0
          },
          "baseline": {
            "aheadCount": 0,
            "behindCount": 7,
            "fileCount": 48
          },
          "upstream": null
        },
        "main": {
          "branch": "main",
          "head": "4b04b83e00427c27f96428671d1044fd0a38393a",
          "baseRef": "origin/main",
          "baseHead": "21c659994cdba8f6164acd549bc5b77b6f2b8504",
          "mergeBase": "21c659994cdba8f6164acd549bc5b77b6f2b8504",
          "divergence": {
            "aheadCount": 3,
            "fileCount": 4
          },
          "baseline": {
            "aheadCount": 3,
            "behindCount": 0,
            "fileCount": 4
          },
          "upstream": null
        },
        "task/task-1770909069061-f69cf1": {
          "branch": "task/task-1770909069061-f69cf1",
          "head": "1515fedca072442ad0656037229bce50b2e341f3",
          "baseRef": "main",
          "baseHead": "4b04b83e00427c27f96428671d1044fd0a38393a",
          "mergeBase": "1515fedca072442ad0656037229bce50b2e341f3",
          "divergence": {
            "aheadCount": 0,
            "fileCount": 0
          },
          "baseline": {
            "aheadCount": 0,
            "behindCount": 7,
            "fileCount": 48
          },
          "upstream": null
        },
        "task/task-1770909069269-afb680": {
          "branch": "task/task-1770909069269-afb680",
          "head": "1515fedca072442ad0656037229bce50b2e341f3",
          "baseRef": "main",
          "baseHead": "4b04b83e00427c27f96428671d1044fd0a38393a",
          "mergeBase": "1515fedca072442ad0656037229bce50b2e341f3",
          "divergence": {
            "aheadCount": 0,
            "fileCount": 0
          },
          "baseline": {
            "aheadCount": 0,
            "behindCount": 7,
            "fileCount": 48
          },
          "upstream": null
        },
        "task/task-1770909068862-42049e": {
          "branch": "task/task-1770909068862-42049e",
          "head": "1515fedca072442ad0656037229bce50b2e341f3",
          "baseRef": "main",
          "baseHead": "4b04b83e00427c27f96428671d1044fd0a38393a",
          "mergeBase": "1515fedca072442ad0656037229bce50b2e341f3",
          "divergence": {
            "aheadCount": 0,
            "fileCount": 0
          },
          "baseline": {
            "aheadCount": 0,
            "behindCount": 7,
            "fileCount": 48
          },
          "upstream": null
        },
        "task/task-1770918400673-d21f34": {
          "branch": "task/task-1770918400673-d21f34",
          "head": "2b85eee6f1cc3016a295ef590494ae0c3924258a",
          "baseRef": "main",
          "baseHead": "4b04b83e00427c27f96428671d1044fd0a38393a",
          "mergeBase": "2b85eee6f1cc3016a295ef590494ae0c3924258a",
          "divergence": {
            "aheadCount": 0,
            "fileCount": 0
          },
          "baseline": {
            "aheadCount": 0,
            "behindCount": 2,
            "fileCount": 2
          },
          "upstream": null
        },
        "task/task-1770918401073-c21f64": {
          "branch": "task/task-1770918401073-c21f64",
          "head": "21c659994cdba8f6164acd549bc5b77b6f2b8504",
          "baseRef": "main",
          "baseHead": "4b04b83e00427c27f96428671d1044fd0a38393a",
          "mergeBase": "21c659994cdba8f6164acd549bc5b77b6f2b8504",
          "divergence": {
            "aheadCount": 0,
            "fileCount": 0
          },
          "baseline": {
            "aheadCount": 0,
            "behindCount": 3,
            "fileCount": 4
          },
          "upstream": null
        },
        "task/task-1770918401380-e8add6": {
          "branch": "task/task-1770918401380-e8add6",
          "head": "21c659994cdba8f6164acd549bc5b77b6f2b8504",
          "baseRef": "main",
          "baseHead": "4b04b83e00427c27f96428671d1044fd0a38393a",
          "mergeBase": "21c659994cdba8f6164acd549bc5b77b6f2b8504",
          "divergence": {
            "aheadCount": 0,
            "fileCount": 0
          },
          "baseline": {
            "aheadCount": 0,
            "behindCount": 3,
            "fileCount": 4
          },
          "upstream": null
        },
        "task/task-1770918400875-2630f2": {
          "branch": "task/task-1770918400875-2630f2",
          "head": "21c659994cdba8f6164acd549bc5b77b6f2b8504",
          "baseRef": "main",
          "baseHead": "4b04b83e00427c27f96428671d1044fd0a38393a",
          "mergeBase": "21c659994cdba8f6164acd549bc5b77b6f2b8504",
          "divergence": {
            "aheadCount": 0,
            "fileCount": 0
          },
          "baseline": {
            "aheadCount": 0,
            "behindCount": 3,
            "fileCount": 4
          },
          "upstream": null
        },
        "task/task-1770918401534-118872": {
          "branch": "task/task-1770918401534-118872",
          "head": "21c659994cdba8f6164acd549bc5b77b6f2b8504",
          "baseRef": "main",
          "baseHead": "4b04b83e00427c27f96428671d1044fd0a38393a",
          "mergeBase": "21c659994cdba8f6164acd549bc5b77b6f2b8504",
          "divergence": {
            "aheadCount": 0,
            "fileCount": 0
          },
          "baseline": {
            "aheadCount": 0,
            "behindCount": 3,
            "fileCount": 4
          },
          "upstream": null
        },
        "task/task-1770918405559-058889": {
          "branch": "task/task-1770918405559-058889",
          "head": "21c659994cdba8f6164acd549bc5b77b6f2b8504",
          "baseRef": "main",
          "baseHead": "4b04b83e00427c27f96428671d1044fd0a38393a",
          "mergeBase": "21c659994cdba8f6164acd549bc5b77b6f2b8504",
          "divergence": {
            "aheadCount": 0,
            "fileCount": 0
          },
          "baseline": {
            "aheadCount": 0,
            "behindCount": 3,
            "fileCount": 4
          },
          "upstream": null
        },
        "task/task-1770918401706-38620f": {
          "branch": "task/task-1770918401706-38620f",
          "head": "21c659994cdba8f6164acd549bc5b77b6f2b8504",
          "baseRef": "main",
          "baseHead": "4b04b83e00427c27f96428671d1044fd0a38393a",
          "mergeBase": "21c659994cdba8f6164acd549bc5b77b6f2b8504",
          "divergence": {
            "aheadCount": 0,
            "fileCount": 0
          },
          "baseline": {
            "aheadCount": 0,
            "behindCount": 3,
            "fileCount": 4
          },
          "upstream": null
        }
      }
    }
  },
  "gitHistoryState": {
    "selectedTimelineIndex": 1,
    "activeCommitHash": null,
    "entries": [
      {
        "type": "live",
        "label": "",
        "files": [],
        "branch": "main",
        "targetCommitHash": "4b04b83e00427c27f96428671d1044fd0a38393a",
        "worktreePath": "/Users/yuyafujita/Projects/koma-fill",
        "timestamp": 1770921961061,
        "lane": 0,
        "branchLabel": "main",
        "branchTags": [
          "main"
        ],
        "isDefaultWorktree": true,
        "branchColor": "#4f85e8",
        "index": 0
      },
      {
        "type": "unstaged",
        "label": " (1)",
        "files": [
          ".kamui/manager/202602130247_monitor_task-1770909068260-pccd6qsd.html"
        ],
        "branch": "main",
        "targetCommitHash": "4b04b83e00427c27f96428671d1044fd0a38393a",
        "worktreePath": "/Users/yuyafujita/Projects/koma-fill",
        "timestamp": 1770921961061,
        "sortOrder": 0,
        "lane": 0,
        "branchColor": "#4f85e8",
        "index": 1
      },
      {
        "type": "commit",
        "label": "Merge branch 'task/task-1770918400673-d21f34'",
        "commit": {
          "hash": "4b04b83e00427c27f96428671d1044fd0a38393a",
          "subject": "Merge branch 'task/task-1770918400673-d21f34'",
          "author": "Yuya Fujita",
          "timestamp": 1770921804,
          "parents": [
            "f99b47b62f5f1da9425a361da62235537aece713",
            "2b85eee6f1cc3016a295ef590494ae0c3924258a"
          ],
          "parent": "f99b47b62f5f1da9425a361da62235537aece713",
          "refs": "HEAD -> main",
          "branches": [
            "HEAD -> main",
            "main",
            "task/task-1770918400673-d21f34"
          ]
        },
        "commitHash": "4b04b83e00427c27f96428671d1044fd0a38393a",
        "lane": 0,
        "parentLinks": [
          {
            "hash": "f99b47b62f5f1da9425a361da62235537aece713",
            "lane": 0
          },
          {
            "hash": "2b85eee6f1cc3016a295ef590494ae0c3924258a",
            "lane": 1
          }
        ],
        "primaryBranchName": "main",
        "branchColor": "#4f85e8",
        "branchTags": [
          "main",
          "task/task-1770918400673-d21f34"
        ],
        "worktrees": [
          {
            "path": "/Users/yuyafujita/Projects/koma-fill",
            "head": "4b04b83e00427c27f96428671d1044fd0a38393a",
            "branch": "main",
            "isMerged": false,
            "mergeCommitHash": null,
            "status": {
              "staged": [],
              "unstaged": [],
              "untracked": [
                {
                  "path": ".kamui/manager/202602130247_monitor_task-1770909068260-pccd6qsd.html",
                  "status": "untracked",
                  "rawPath": ".kamui/manager/202602130247_monitor_task-1770909068260-pccd6qsd.html",
                  "timestamp": 1770921960568
                }
              ],
              "capturedAt": 1770921960568
            },
            "normalizedPath": "/Users/yuyafujita/Projects/koma-fill",
            "lane": 0
          }
        ],
        "index": 2
      },
      {
        "type": "commit",
        "label": "Update Kamui task state on main",
        "commit": {
          "hash": "f99b47b62f5f1da9425a361da62235537aece713",
          "subject": "Update Kamui task state on main",
          "author": "Yuya Fujita",
          "timestamp": 1770921799,
          "parents": [
            "21c659994cdba8f6164acd549bc5b77b6f2b8504"
          ],
          "parent": "21c659994cdba8f6164acd549bc5b77b6f2b8504",
          "refs": "",
          "branches": [
            "main"
          ]
        },
        "commitHash": "f99b47b62f5f1da9425a361da62235537aece713",
        "lane": 0,
        "parentLinks": [
          {
            "hash": "21c659994cdba8f6164acd549bc5b77b6f2b8504",
            "lane": 0
          }
        ],
        "primaryBranchName": "main",
        "branchColor": "#4f85e8",
        "branchTags": [],
        "index": 3
      },
      {
        "type": "commit",
        "label": "Fix CI defaults for test and ESLint v9 config",
        "commit": {
          "hash": "2b85eee6f1cc3016a295ef590494ae0c3924258a",
          "subject": "Fix CI defaults for test and ESLint v9 config",
          "author": "Yuya Fujita",
          "timestamp": 1770921774,
          "parents": [
            "21c659994cdba8f6164acd549bc5b77b6f2b8504"
          ],
          "parent": "21c659994cdba8f6164acd549bc5b77b6f2b8504",
          "refs": "task/task-1770918400673-d21f34",
          "branches": [
            "task/task-1770918400673-d21f34"
          ]
        },
        "commitHash": "2b85eee6f1cc3016a295ef590494ae0c3924258a",
        "lane": 1,
        "parentLinks": [
          {
            "hash": "21c659994cdba8f6164acd549bc5b77b6f2b8504",
            "lane": 0
          }
        ],
        "primaryBranchName": "task/task-1770918400673-d21f34",
        "branchColor": "#4f85e8",
        "branchTags": [],
        "worktrees": [
          {
            "path": "/Users/yuyafujita/Projects/koma-fill/.worktrees/task-1770918400673-d21f34",
            "head": "2b85eee6f1cc3016a295ef590494ae0c3924258a",
            "branch": "task/task-1770918400673-d21f34",
            "isMerged": true,
            "mergeCommitHash": "4b04b83e00427c27f96428671d1044fd0a38393a",
            "status": {
              "staged": [],
              "unstaged": [],
              "untracked": [],
              "capturedAt": 1770921960605
            },
            "normalizedPath": "/Users/yuyafujita/Projects/koma-fill/.worktrees/task-1770918400673-d21f34",
            "lane": 1
          }
        ],
        "index": 4
      },
      {
        "type": "unstaged",
        "label": " [task/task-1770918401380-e8add6] (8)",
        "files": [
          "backend/src/app.ts",
          "backend/src/config/constants.ts",
          "backend/src/routes/manga.ts",
          "backend/src/services/exportService.ts",
          "backend/src/services/layoutEngine.ts",
          "frontend/package.json",
          "frontend/src/components/ImageUploader.tsx",
          "package-lock.json"
        ],
        "branch": "task/task-1770918401380-e8add6",
        "targetCommitHash": "21c659994cdba8f6164acd549bc5b77b6f2b8504",
        "worktreePath": "/Users/yuyafujita/Projects/koma-fill/.worktrees/task-1770918401380-e8add6",
        "timestamp": 1770921960631,
        "sortOrder": 0,
        "lane": 3,
        "branchColor": "#e8a84f",
        "index": 5
      },
      {
        "type": "staged",
        "label": " [task/task-1770918401380-e8add6] (1)",
        "files": [
          "ackend/package.json"
        ],
        "branch": "task/task-1770918401380-e8add6",
        "targetCommitHash": "21c659994cdba8f6164acd549bc5b77b6f2b8504",
        "worktreePath": "/Users/yuyafujita/Projects/koma-fill/.worktrees/task-1770918401380-e8add6",
        "timestamp": 1770921960631,
        "sortOrder": 1,
        "lane": 3,
        "branchColor": "#e8a84f",
        "index": 6
      },
      {
        "type": "unstaged",
        "label": " [task/task-1770918401534-118872] (8)",
        "files": [
          "backend/src/app.ts",
          "backend/src/config/constants.ts",
          "backend/src/routes/manga.ts",
          "backend/src/services/exportService.ts",
          "backend/src/services/layoutEngine.ts",
          "frontend/package.json",
          "frontend/src/components/ImageUploader.tsx",
          "package-lock.json"
        ],
        "branch": "task/task-1770918401534-118872",
        "targetCommitHash": "21c659994cdba8f6164acd549bc5b77b6f2b8504",
        "worktreePath": "/Users/yuyafujita/Projects/koma-fill/.worktrees/task-1770918401534-118872",
        "timestamp": 1770921960630,
        "sortOrder": 0,
        "lane": 6,
        "branchColor": "#e8e84f",
        "index": 7
      },
      {
        "type": "staged",
        "label": " [task/task-1770918401534-118872] (1)",
        "files": [
          "ackend/package.json"
        ],
        "branch": "task/task-1770918401534-118872",
        "targetCommitHash": "21c659994cdba8f6164acd549bc5b77b6f2b8504",
        "worktreePath": "/Users/yuyafujita/Projects/koma-fill/.worktrees/task-1770918401534-118872",
        "timestamp": 1770921960630,
        "sortOrder": 1,
        "lane": 6,
        "branchColor": "#e8e84f",
        "index": 8
      },
      {
        "type": "unstaged",
        "label": " [task/task-1770918401706-38620f] (8)",
        "files": [
          "backend/src/app.ts",
          "backend/src/config/constants.ts",
          "backend/src/routes/manga.ts",
          "backend/src/services/exportService.ts",
          "backend/src/services/layoutEngine.ts",
          "frontend/package.json",
          "frontend/src/components/ImageUploader.tsx",
          "package-lock.json"
        ],
        "branch": "task/task-1770918401706-38620f",
        "targetCommitHash": "21c659994cdba8f6164acd549bc5b77b6f2b8504",
        "worktreePath": "/Users/yuyafujita/Projects/koma-fill/.worktrees/task-1770918401706-38620f",
        "timestamp": 1770921960641,
        "sortOrder": 0,
        "lane": 7,
        "branchColor": "#b84fe8",
        "index": 9
      },
      {
        "type": "staged",
        "label": " [task/task-1770918401706-38620f] (1)",
        "files": [
          "ackend/package.json"
        ],
        "branch": "task/task-1770918401706-38620f",
        "targetCommitHash": "21c659994cdba8f6164acd549bc5b77b6f2b8504",
        "worktreePath": "/Users/yuyafujita/Projects/koma-fill/.worktrees/task-1770918401706-38620f",
        "timestamp": 1770921960641,
        "sortOrder": 1,
        "lane": 7,
        "branchColor": "#b84fe8",
        "index": 10
      },
      {
        "type": "unstaged",
        "label": " [task/task-1770918405559-058889] (3)",
        "files": [
          "evaluation-report-6tasks-600.html",
          "evaluation-report-6tasks.html",
          "evaluation-report.html"
        ],
        "branch": "task/task-1770918405559-058889",
        "targetCommitHash": "21c659994cdba8f6164acd549bc5b77b6f2b8504",
        "worktreePath": "/Users/yuyafujita/Projects/koma-fill/.worktrees/task-1770918405559-058889",
        "timestamp": 1770921960641,
        "sortOrder": 0,
        "lane": 8,
        "branchColor": "#4fe84f",
        "index": 11
      },
      {
        "type": "anchor",
        "label": "[] CodexCLI2: # KAMUI-4D Bug Fix & ",
        "branch": "task/task-1770918400875-2630f2",
        "worktreePath": "/Users/yuyafujita/Projects/koma-fill/.worktrees/task-1770918400875-2630f2",
        "parentCommitHash": "21c659994cdba8f6164acd549bc5b77b6f2b8504",
        "lane": 4,
        "isMerged": false,
        "mergeCommitHash": null,
        "statusChildren": [],
        "isDefaultWorktree": false,
        "renderMode": "node",
        "shouldHide": false,
        "tagLabel": "task/task-1770918400875-2630f2",
        "taskId": "task-1770918400875-2630f2",
        "taskStatus": "working",
        "taskStatusLabel": "",
        "taskName": "CodexCLI2: # KAMUI-4D Bug Fix & Improvement Prompts for koma-fill\n## Post-Implementation Review  Multi-Agent Fix Guide\n\n**Version:** 1.1 (Post-Review Fix)\n**Project:** koma-fill - AI-powered manga panel generation system\n**Target:** KAMUI-4D Editor (Multi-AI CLI parallel execution)\n**Author:** Code Review by Claude (2026-02-13)\n\n---\n\n## Overview\n\n **3 + 1 + 4** \n\n### Issue Summary\n\n| # |  |  |  | Task |\n|---|------|--------|------|------|\n| 1 | Bug |  High | ImageUploader  useEffect  | Task 2 |\n| 2 | Bug |  High |  | Task 1 |\n| 3 | Bug |  Medium | SVG | Task 1 |\n| 4 | Security |  High |  | Task 1 |\n| 5 | Cleanup |  Low | exportService.ts  import | Task 1 |\n| 6 | Cleanup |  Low | winston  | Task 1 |\n| 7 | Improvement |  Medium | @dnd-kit/utilities  package.json  | Task 2 |\n| 8 | Improvement |  Medium | CORS origin  | Task 1 |\n\n---\n\n## Execution Strategy\n\n```\nTask 1 (Backend)   Agent A  #2,#3,#4,#5,#6,#8\nTask 2 (Frontend)  Agent B  #1,#7\nTask 3 (Verify)    Agent C   & Task 1,2 \n```\n\n**:** Task 1  Task 2 Task 3 \n\n```\nTimeline:\n  \n   Task 1 (Backend)      20-30 min\n   Agent A              \n  \n                           \n              Task 3 (Verify)   10-15 min\n                            Agent C          \n    \n   Task 2 (Frontend)     10-15 min\n   Agent B              \n  \n```\n\n---\n\n## Task 1:  (Agent A)\n### LayoutEngine / Security / Cleanup\n\n**Time Estimate:** 20-30 minutes\n**Difficulty:** Intermediate\n**Dependencies:** None\n\n### Objective\nCORS\n\n### Target Files\n\n```\nbackend/src/\n services/\n    layoutEngine.ts          [MODIFY]  (#2, #3)\n    exportService.ts         [MODIFY] import (#5)\n routes/\n    manga.ts                 [MODIFY]  (#4)\n app.ts                       [MODIFY] CORS (#8)\n config/\n     constants.ts             [MODIFY] ALLOWED_ORIGINS (#8)\nbackend/package.json             [MODIFY] winston (#6)\n```\n\n---\n\n### Fix #2: \n\n**File:** `backend/src/services/layoutEngine.ts`\n**Lines:** 299-313\n**Problem:** `bubble.text.split(' ')` 1\n\n**Current Code ():**\n```typescript\n// \nconst words = bubble.text.split(' ');\nconst lines: string[] = [];\nlet currentLine = '';\nconst maxCharsPerLine = 30;\n\nfor (const word of words) {\n  if ((currentLine + word).length > maxCharsPerLine) {\n    if (currentLine) lines.push(currentLine.trim());\n    currentLine = word + ' ';\n  } else {\n    currentLine += word + ' ';\n  }\n}\nif (currentLine) lines.push(currentLine.trim());\n```\n\n**Fix: **\n```typescript\n// : \nconst maxCharsPerLine = 15; // \nconst lines: string[] = [];\n\n// \nconst hasSpaces = bubble.text.includes(' ');\n\nif (hasSpaces) {\n  // : \n  const words = bubble.text.split(' ');\n  let currentLine = '';\n  for (const word of words) {\n    if ((currentLine + word).length > maxCharsPerLine) {\n      if (currentLine) lines.push(currentLine.trim());\n      currentLine = word + ' ';\n    } else {\n      currentLine += word + ' ';\n    }\n  }\n  if (currentLine) lines.push(currentLine.trim());\n} else {\n  // : \n  const text = bubble.text;\n  for (let i = 0; i < text.length; i += maxCharsPerLine) {\n    lines.push(text.slice(i, i + maxCharsPerLine));\n  }\n}\n```\n\n**Adjustment:**  `bubbleHeight` \n `const bubbleHeight = 60;` (265) :\n\n```typescript\n// bubbleHeight \nconst lineHeight = 20;\nconst verticalPadding = 20;\nconst bubbleHeight = Math.max(50, lines.length * lineHeight + verticalPadding);\n```\n\n**:** `bubbleHeight` ****\n`generateSpeechBubbleSvg` :\n1. lines\n2. bubbleHeight\n3. bubbleX/targetY\n4. shapePath\n5. textElements\n\n\n---\n\n### Fix #3: SVG\n\n**File:** `backend/src/services/layoutEngine.ts`\n**Line:** 320\n**Problem:** SVG `width`/`height` `sharp.composite()` \n\n**Current Code ():**\n```typescript\nconst svg = `<svg width=\"${panelPos.width + panelPos.x}\" height=\"${panelPos.height + panelPos.y}\" xmlns=\"http://www.w3.org/2000/svg\">\n```\n\n**Fix: addSpeechBubbles **\n\nStep 1: `generateSpeechBubbleSvg` :\n```typescript\nprivate generateSpeechBubbleSvg(\n  bubble: SpeechBubble,\n  panelPos: PanelPosition,\n  targetY: number,\n  layoutWidth: number,   //  \n  layoutHeight: number   //  \n): Buffer {\n```\n\nStep 2: SVG:\n```typescript\nconst svg = `<svg width=\"${layoutWidth}\" height=\"${layoutHeight}\" xmlns=\"http://www.w3.org/2000/svg\">\n```\n\nStep 3: `addSpeechBubbles`  (122):\n```typescript\nconst bubbleSvg = this.generateSpeechBubbleSvg(\n  bubble,\n  panelPos,\n  targetY,\n  layout.width,    //  \n  layout.height    //  \n);\n```\n\n---\n\n### Fix #4: \n\n**File:** `backend/src/routes/manga.ts`\n**Lines:** 664-673\n**Problem:**  `filePath: filePath` : `/app/uploads/xxx/panel.png`\n\n**Current Code ():**\n```typescript\nres.json({\n  message: 'Export successful',\n  projectId,\n  format: exportFormat,\n  downloadUrl: `/uploads/${projectId}/${path.basename(filePath)}`,\n  filePath: filePath,         //  \n  fileSize: result.fileSize,\n});\n```\n\n**Fix:**\n```typescript\nres.json({\n  message: 'Export successful',\n  projectId,\n  format: exportFormat,\n  downloadUrl: `/uploads/${projectId}/${path.basename(filePath)}`,\n  fileSize: result.fileSize,\n});\n```\n\n`filePath` OK `downloadUrl` \n\n---\n\n### Fix #5: exportService.ts  import\n\n**File:** `backend/src/services/exportService.ts`\n**Line:** 16\n\n**Current Code:**\n```typescript\nimport { Readable } from 'stream';\n```\n\n**Fix:** `Readable` \n\n---\n\n### Fix #6:  winston \n\n**File:** `backend/package.json`\n\n**Action:**\n```bash\ncd backend\nnpm uninstall winston\n```\n\n`winston`  import  `console.log` / `console.error` \n\n**Note:** Structured Logging `pino`  `winston` \n\n---\n\n### Fix #8: CORS origin \n\n**File:** `backend/src/config/constants.ts`\n\n**:** CONFIG  `ALLOWED_ORIGINS` :\n```typescript\nexport const CONFIG = {\n  // Server\n  PORT: parseInt(process.env.PORT || '5000', 10),\n  NODE_ENV: process.env.NODE_ENV || 'development',\n  BASE_URL: process.env.BASE_URL || 'http://localhost:5000',\n  ALLOWED_ORIGINS: process.env.ALLOWED_ORIGINS\n    ? process.env.ALLOWED_ORIGINS.split(',')\n    : ['http://localhost:3000'],\n\n  // ... \n```\n\n**File:** `backend/src/app.ts`\n\n**Current Code:**\n```typescript\napp.use(cors({\n  origin: process.env.NODE_ENV === 'production'\n    ? process.env.ALLOWED_ORIGINS?.split(',')\n    : ['http://localhost:3000'],\n}));\n```\n\n**Fix:**\n```typescript\nimport { CONFIG } from './config/constants';\n\n// ... (import)\n\napp.use(cors({\n  origin: CONFIG.NODE_ENV === 'production'\n    ? CONFIG.ALLOWED_ORIGINS\n    : CONFIG.ALLOWED_ORIGINS,\n}));\n```\n\n**:** `app.ts`  `CONFIG`  import  `app.ts`  `config/constants`  import \n\n---\n\n### Verification (Task 1)\n\n:\n\n```bash\ncd backend\n\n# TypeScript \nnpx tsc --noEmit\n\n# \nnpm ls --depth=0\n\n# \nnpm run build\n```\n\n**Expected:** \n\n---\n\n## Task 2:  (Agent B)\n### ImageUploader Bug Fix & Dependency Cleanup\n\n**Time Estimate:** 10-15 minutes\n**Difficulty:** Easy\n**Dependencies:** None\n\n### Objective\nImageUploader `package.json` \n\n### Target Files\n\n```\nfrontend/\n src/\n    components/\n        ImageUploader.tsx    [MODIFY] useEffect (#1)\n package.json                 [MODIFY] @dnd-kit/utilities (#7)\n```\n\n---\n\n### Fix #1: ImageUploader  useEffect \n\n**File:** `frontend/src/components/ImageUploader.tsx`\n**Lines:** 25-29\n**Problem:** `useEffect`  `images`  ** ObjectURL  revoke **\n\n**Current Code ():**\n```typescript\nuseEffect(() => {\n  return () => {\n    images.forEach((image) => URL.revokeObjectURL(image.previewUrl));\n  };\n}, [images]);\n```\n\n**:**\n1. A  `images = [A]`\n2. B  `images`  effect \n3.  `images.forEach(URL.revokeObjectURL)` AURL revoke \n4. : ABURL\n\n**Fix:  revoke  +  revoke **\n\n```typescript\n// URL\nuseEffect(() => {\n  return () => {\n    // URL\n    // eslint-disable-next-line react-hooks/exhaustive-deps -- intentionally run only on unmount\n    images.forEach((image) => URL.revokeObjectURL(image.previewUrl));\n  };\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n}, []);\n```\n\n**:** `removeImage` 73-81 `URL.revokeObjectURL` \n\n**:** `eslint-disable` :\n- React  `react-hooks/exhaustive-deps`  `images` \n- \n- `images`  `useRef`  `removeImage`  revoke  cleanup \n\n**Alternative Fix:**\n`useRef`  `images` :\n\n```typescript\nconst imagesRef = useRef<UploadedImage[]>([]);\n\n// imagesref\nuseEffect(() => {\n  imagesRef.current = images;\n}, [images]);\n\n// URL\nuseEffect(() => {\n  return () => {\n    imagesRef.current.forEach((image) => URL.revokeObjectURL(image.previewUrl));\n  };\n}, []);\n```\n\n**:** Alternative FixuseRef ESLint \n\n---\n\n### Fix #7: @dnd-kit/utilities  package.json \n\n**File:** `frontend/package.json`\n\n**Action:**\n```bash\ncd frontend\nnpm install @dnd-kit/utilities\n```\n\n**Reason:** `PanelGrid.tsx`  `@dnd-kit/utilities`  `CSS` `package.json` `@dnd-kit/sortable`  transitive dependency  break\n\n---\n\n### Verification (Task 2)\n\n:\n\n```bash\ncd frontend\n\n# TypeScript \nnpx tsc --noEmit\n\n# \nnpm run build\n\n# package.json \nnpm ls @dnd-kit/utilities\n```\n\n**Expected:** `dist/` \n\n---\n\n## Task 3:  (Agent C)\n### Build Verification & Integration Test\n\n**Time Estimate:** 10-15 minutes\n**Difficulty:** Easy\n**Dependencies:** Task 1  Task 2 \n\n### Objective\nTask 1, 2 TypeScript \n\n### Verification Checklist\n\n#### Step 1: Backend \n\n```bash\ncd backend\n\n# winston\nnpm install\n\n# TypeScript \nnpx tsc --noEmit\necho \"Backend type check: $?\"\n\n# \nnpm run build\necho \"Backend build: $?\"\n\n# \nls -la dist/services/layoutEngine.js\nls -la dist/services/exportService.js\nls -la dist/routes/manga.js\nls -la dist/app.js\n```\n\n**Expected:**\n-  exit code 0\n- `dist/`  `.js`  `.d.ts` \n- `dist/services/exportService.js`  `Readable`  import \n\n#### Step 2: Frontend \n\n```bash\ncd frontend\n\n# @dnd-kit/utilities\nnpm install\n\n# TypeScript \nnpx tsc --noEmit\necho \"Frontend type check: $?\"\n\n# Vite \nnpm run build\necho \"Frontend build: $?\"\n\n# \nls -la dist/\nls -la dist/assets/\n```\n\n**Expected:**\n-  exit code 0\n- `dist/index.html`  `dist/assets/`  JS/CSS \n\n#### Step 3: \n\n```bash\ncd backend\n\n# 5\ntimeout 5 node dist/index.js 2>&1 || true\n\n# \n# curl -s http://localhost:5000/api/health | head -1\n```\n\n**Expected:**\n- `koma-fill server running on http://localhost:5000` \n- DB initialized \n- \n\n#### Step 4: grep \n\n```bash\n# Fix #4: filePath  export \ngrep -n \"filePath:\" backend/src/routes/manga.ts | grep -v \"downloadUrl\\|layoutPath\\|imageFilePath\\|const filePath\\|file_path\\|\\.filePath\"\n\n# Fix #5: Readable  exportService import\ngrep -n \"Readable\" backend/src/services/exportService.ts\n\n# Fix #6: winston  package.json \ngrep -n \"winston\" backend/package.json\n\n# Fix #7: @dnd-kit/utilities  frontend/package.json \ngrep -n \"dnd-kit/utilities\" frontend/package.json\n\n# Fix #8: CONFIG.ALLOWED_ORIGINS \ngrep -n \"ALLOWED_ORIGINS\" backend/src/config/constants.ts\ngrep -n \"ALLOWED_ORIGINS\\|CONFIG\" backend/src/app.ts\n```\n\n**Expected:**\n- Fix #4: export  `filePath` \n- Fix #5: `Readable`  import \n- Fix #6: `winston` \n- Fix #7: `@dnd-kit/utilities` \n- Fix #8: `ALLOWED_ORIGINS`  constants.ts  app.ts \n\n#### Step 5: LayoutEngine \n\n```bash\n# layoutEngine.ts \ngrep -A 20 \"\" backend/src/services/layoutEngine.ts\n# \ngrep -A 20 \"maxCharsPerLine\" backend/src/services/layoutEngine.ts\n```\n\n**Expected:** `.split(' ')` \n\n---\n\n### Final Report\n\n:\n\n```\n## Fix Verification Report\n\n| # | Fix | Status | Notes |\n|---|-----|--------|-------|\n| 1 | ImageUploader useEffect | / | |\n| 2 |  | / | |\n| 3 | SVG | / | |\n| 4 |  | / | |\n| 5 | Readable import | / | |\n| 6 | winston | / | |\n| 7 | @dnd-kit/utilities | / | |\n| 8 | CORS | / | |\n\nBackend build: /\nFrontend build: /\nServer startup: /\n```\n\n---\n\n## Appendix: \n\n:\n\n1. ****  ARCHITECTURE.md  Bearer \n2. **winston / pino Structured Logging**  \n3. **CONTEXT.md **  \n4. **API_SPEC.md **  \n5. ****  jest \n6. **`generation_log` **  API\n7. ****  \n8. **API**  PreviewPage  `handleDelete` ",
        "tooltip": ": CodexCLI2: # KAMUI-4D Bug Fix & Improvement Prompts for koma-fill\n## Post-Implementation Review  Multi-Agent Fix Guide\n\n**Version:** 1.1 (Post-Review Fix)\n**Project:** koma-fill - AI-powered manga panel generation system\n**Target:** KAMUI-4D Editor (Multi-AI CLI parallel execution)\n**Author:** Code Review by Claude (2026-02-13)\n\n---\n\n## Overview\n\n **3 + 1 + 4** \n\n### Issue Summary\n\n| # |  |  |  | Task |\n|---|------|--------|------|------|\n| 1 | Bug |  High | ImageUploader  useEffect  | Task 2 |\n| 2 | Bug |  High |  | Task 1 |\n| 3 | Bug |  Medium | SVG | Task 1 |\n| 4 | Security |  High |  | Task 1 |\n| 5 | Cleanup |  Low | exportService.ts  import | Task 1 |\n| 6 | Cleanup |  Low | winston  | Task 1 |\n| 7 | Improvement |  Medium | @dnd-kit/utilities  package.json  | Task 2 |\n| 8 | Improvement |  Medium | CORS origin  | Task 1 |\n\n---\n\n## Execution Strategy\n\n```\nTask 1 (Backend)   Agent A  #2,#3,#4,#5,#6,#8\nTask 2 (Frontend)  Agent B  #1,#7\nTask 3 (Verify)    Agent C   & Task 1,2 \n```\n\n**:** Task 1  Task 2 Task 3 \n\n```\nTimeline:\n  \n   Task 1 (Backend)      20-30 min\n   Agent A              \n  \n                           \n              Task 3 (Verify)   10-15 min\n                            Agent C          \n    \n   Task 2 (Frontend)     10-15 min\n   Agent B              \n  \n```\n\n---\n\n## Task 1:  (Agent A)\n### LayoutEngine / Security / Cleanup\n\n**Time Estimate:** 20-30 minutes\n**Difficulty:** Intermediate\n**Dependencies:** None\n\n### Objective\nCORS\n\n### Target Files\n\n```\nbackend/src/\n services/\n    layoutEngine.ts          [MODIFY]  (#2, #3)\n    exportService.ts         [MODIFY] import (#5)\n routes/\n    manga.ts                 [MODIFY]  (#4)\n app.ts                       [MODIFY] CORS (#8)\n config/\n     constants.ts             [MODIFY] ALLOWED_ORIGINS (#8)\nbackend/package.json             [MODIFY] winston (#6)\n```\n\n---\n\n### Fix #2: \n\n**File:** `backend/src/services/layoutEngine.ts`\n**Lines:** 299-313\n**Problem:** `bubble.text.split(' ')` 1\n\n**Current Code ():**\n```typescript\n// \nconst words = bubble.text.split(' ');\nconst lines: string[] = [];\nlet currentLine = '';\nconst maxCharsPerLine = 30;\n\nfor (const word of words) {\n  if ((currentLine + word).length > maxCharsPerLine) {\n    if (currentLine) lines.push(currentLine.trim());\n    currentLine = word + ' ';\n  } else {\n    currentLine += word + ' ';\n  }\n}\nif (currentLine) lines.push(currentLine.trim());\n```\n\n**Fix: **\n```typescript\n// : \nconst maxCharsPerLine = 15; // \nconst lines: string[] = [];\n\n// \nconst hasSpaces = bubble.text.includes(' ');\n\nif (hasSpaces) {\n  // : \n  const words = bubble.text.split(' ');\n  let currentLine = '';\n  for (const word of words) {\n    if ((currentLine + word).length > maxCharsPerLine) {\n      if (currentLine) lines.push(currentLine.trim());\n      currentLine = word + ' ';\n    } else {\n      currentLine += word + ' ';\n    }\n  }\n  if (currentLine) lines.push(currentLine.trim());\n} else {\n  // : \n  const text = bubble.text;\n  for (let i = 0; i < text.length; i += maxCharsPerLine) {\n    lines.push(text.slice(i, i + maxCharsPerLine));\n  }\n}\n```\n\n**Adjustment:**  `bubbleHeight` \n `const bubbleHeight = 60;` (265) :\n\n```typescript\n// bubbleHeight \nconst lineHeight = 20;\nconst verticalPadding = 20;\nconst bubbleHeight = Math.max(50, lines.length * lineHeight + verticalPadding);\n```\n\n**:** `bubbleHeight` ****\n`generateSpeechBubbleSvg` :\n1. lines\n2. bubbleHeight\n3. bubbleX/targetY\n4. shapePath\n5. textElements\n\n\n---\n\n### Fix #3: SVG\n\n**File:** `backend/src/services/layoutEngine.ts`\n**Line:** 320\n**Problem:** SVG `width`/`height` `sharp.composite()` \n\n**Current Code ():**\n```typescript\nconst svg = `<svg width=\"${panelPos.width + panelPos.x}\" height=\"${panelPos.height + panelPos.y}\" xmlns=\"http://www.w3.org/2000/svg\">\n```\n\n**Fix: addSpeechBubbles **\n\nStep 1: `generateSpeechBubbleSvg` :\n```typescript\nprivate generateSpeechBubbleSvg(\n  bubble: SpeechBubble,\n  panelPos: PanelPosition,\n  targetY: number,\n  layoutWidth: number,   //  \n  layoutHeight: number   //  \n): Buffer {\n```\n\nStep 2: SVG:\n```typescript\nconst svg = `<svg width=\"${layoutWidth}\" height=\"${layoutHeight}\" xmlns=\"http://www.w3.org/2000/svg\">\n```\n\nStep 3: `addSpeechBubbles`  (122):\n```typescript\nconst bubbleSvg = this.generateSpeechBubbleSvg(\n  bubble,\n  panelPos,\n  targetY,\n  layout.width,    //  \n  layout.height    //  \n);\n```\n\n---\n\n### Fix #4: \n\n**File:** `backend/src/routes/manga.ts`\n**Lines:** 664-673\n**Problem:**  `filePath: filePath` : `/app/uploads/xxx/panel.png`\n\n**Current Code ():**\n```typescript\nres.json({\n  message: 'Export successful',\n  projectId,\n  format: exportFormat,\n  downloadUrl: `/uploads/${projectId}/${path.basename(filePath)}`,\n  filePath: filePath,         //  \n  fileSize: result.fileSize,\n});\n```\n\n**Fix:**\n```typescript\nres.json({\n  message: 'Export successful',\n  projectId,\n  format: exportFormat,\n  downloadUrl: `/uploads/${projectId}/${path.basename(filePath)}`,\n  fileSize: result.fileSize,\n});\n```\n\n`filePath` OK `downloadUrl` \n\n---\n\n### Fix #5: exportService.ts  import\n\n**File:** `backend/src/services/exportService.ts`\n**Line:** 16\n\n**Current Code:**\n```typescript\nimport { Readable } from 'stream';\n```\n\n**Fix:** `Readable` \n\n---\n\n### Fix #6:  winston \n\n**File:** `backend/package.json`\n\n**Action:**\n```bash\ncd backend\nnpm uninstall winston\n```\n\n`winston`  import  `console.log` / `console.error` \n\n**Note:** Structured Logging `pino`  `winston` \n\n---\n\n### Fix #8: CORS origin \n\n**File:** `backend/src/config/constants.ts`\n\n**:** CONFIG  `ALLOWED_ORIGINS` :\n```typescript\nexport const CONFIG = {\n  // Server\n  PORT: parseInt(process.env.PORT || '5000', 10),\n  NODE_ENV: process.env.NODE_ENV || 'development',\n  BASE_URL: process.env.BASE_URL || 'http://localhost:5000',\n  ALLOWED_ORIGINS: process.env.ALLOWED_ORIGINS\n    ? process.env.ALLOWED_ORIGINS.split(',')\n    : ['http://localhost:3000'],\n\n  // ... \n```\n\n**File:** `backend/src/app.ts`\n\n**Current Code:**\n```typescript\napp.use(cors({\n  origin: process.env.NODE_ENV === 'production'\n    ? process.env.ALLOWED_ORIGINS?.split(',')\n    : ['http://localhost:3000'],\n}));\n```\n\n**Fix:**\n```typescript\nimport { CONFIG } from './config/constants';\n\n// ... (import)\n\napp.use(cors({\n  origin: CONFIG.NODE_ENV === 'production'\n    ? CONFIG.ALLOWED_ORIGINS\n    : CONFIG.ALLOWED_ORIGINS,\n}));\n```\n\n**:** `app.ts`  `CONFIG`  import  `app.ts`  `config/constants`  import \n\n---\n\n### Verification (Task 1)\n\n:\n\n```bash\ncd backend\n\n# TypeScript \nnpx tsc --noEmit\n\n# \nnpm ls --depth=0\n\n# \nnpm run build\n```\n\n**Expected:** \n\n---\n\n## Task 2:  (Agent B)\n### ImageUploader Bug Fix & Dependency Cleanup\n\n**Time Estimate:** 10-15 minutes\n**Difficulty:** Easy\n**Dependencies:** None\n\n### Objective\nImageUploader `package.json` \n\n### Target Files\n\n```\nfrontend/\n src/\n    components/\n        ImageUploader.tsx    [MODIFY] useEffect (#1)\n package.json                 [MODIFY] @dnd-kit/utilities (#7)\n```\n\n---\n\n### Fix #1: ImageUploader  useEffect \n\n**File:** `frontend/src/components/ImageUploader.tsx`\n**Lines:** 25-29\n**Problem:** `useEffect`  `images`  ** ObjectURL  revoke **\n\n**Current Code ():**\n```typescript\nuseEffect(() => {\n  return () => {\n    images.forEach((image) => URL.revokeObjectURL(image.previewUrl));\n  };\n}, [images]);\n```\n\n**:**\n1. A  `images = [A]`\n2. B  `images`  effect \n3.  `images.forEach(URL.revokeObjectURL)` AURL revoke \n4. : ABURL\n\n**Fix:  revoke  +  revoke **\n\n```typescript\n// URL\nuseEffect(() => {\n  return () => {\n    // URL\n    // eslint-disable-next-line react-hooks/exhaustive-deps -- intentionally run only on unmount\n    images.forEach((image) => URL.revokeObjectURL(image.previewUrl));\n  };\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n}, []);\n```\n\n**:** `removeImage` 73-81 `URL.revokeObjectURL` \n\n**:** `eslint-disable` :\n- React  `react-hooks/exhaustive-deps`  `images` \n- \n- `images`  `useRef`  `removeImage`  revoke  cleanup \n\n**Alternative Fix:**\n`useRef`  `images` :\n\n```typescript\nconst imagesRef = useRef<UploadedImage[]>([]);\n\n// imagesref\nuseEffect(() => {\n  imagesRef.current = images;\n}, [images]);\n\n// URL\nuseEffect(() => {\n  return () => {\n    imagesRef.current.forEach((image) => URL.revokeObjectURL(image.previewUrl));\n  };\n}, []);\n```\n\n**:** Alternative FixuseRef ESLint \n\n---\n\n### Fix #7: @dnd-kit/utilities  package.json \n\n**File:** `frontend/package.json`\n\n**Action:**\n```bash\ncd frontend\nnpm install @dnd-kit/utilities\n```\n\n**Reason:** `PanelGrid.tsx`  `@dnd-kit/utilities`  `CSS` `package.json` `@dnd-kit/sortable`  transitive dependency  break\n\n---\n\n### Verification (Task 2)\n\n:\n\n```bash\ncd frontend\n\n# TypeScript \nnpx tsc --noEmit\n\n# \nnpm run build\n\n# package.json \nnpm ls @dnd-kit/utilities\n```\n\n**Expected:** `dist/` \n\n---\n\n## Task 3:  (Agent C)\n### Build Verification & Integration Test\n\n**Time Estimate:** 10-15 minutes\n**Difficulty:** Easy\n**Dependencies:** Task 1  Task 2 \n\n### Objective\nTask 1, 2 TypeScript \n\n### Verification Checklist\n\n#### Step 1: Backend \n\n```bash\ncd backend\n\n# winston\nnpm install\n\n# TypeScript \nnpx tsc --noEmit\necho \"Backend type check: $?\"\n\n# \nnpm run build\necho \"Backend build: $?\"\n\n# \nls -la dist/services/layoutEngine.js\nls -la dist/services/exportService.js\nls -la dist/routes/manga.js\nls -la dist/app.js\n```\n\n**Expected:**\n-  exit code 0\n- `dist/`  `.js`  `.d.ts` \n- `dist/services/exportService.js`  `Readable`  import \n\n#### Step 2: Frontend \n\n```bash\ncd frontend\n\n# @dnd-kit/utilities\nnpm install\n\n# TypeScript \nnpx tsc --noEmit\necho \"Frontend type check: $?\"\n\n# Vite \nnpm run build\necho \"Frontend build: $?\"\n\n# \nls -la dist/\nls -la dist/assets/\n```\n\n**Expected:**\n-  exit code 0\n- `dist/index.html`  `dist/assets/`  JS/CSS \n\n#### Step 3: \n\n```bash\ncd backend\n\n# 5\ntimeout 5 node dist/index.js 2>&1 || true\n\n# \n# curl -s http://localhost:5000/api/health | head -1\n```\n\n**Expected:**\n- `koma-fill server running on http://localhost:5000` \n- DB initialized \n- \n\n#### Step 4: grep \n\n```bash\n# Fix #4: filePath  export \ngrep -n \"filePath:\" backend/src/routes/manga.ts | grep -v \"downloadUrl\\|layoutPath\\|imageFilePath\\|const filePath\\|file_path\\|\\.filePath\"\n\n# Fix #5: Readable  exportService import\ngrep -n \"Readable\" backend/src/services/exportService.ts\n\n# Fix #6: winston  package.json \ngrep -n \"winston\" backend/package.json\n\n# Fix #7: @dnd-kit/utilities  frontend/package.json \ngrep -n \"dnd-kit/utilities\" frontend/package.json\n\n# Fix #8: CONFIG.ALLOWED_ORIGINS \ngrep -n \"ALLOWED_ORIGINS\" backend/src/config/constants.ts\ngrep -n \"ALLOWED_ORIGINS\\|CONFIG\" backend/src/app.ts\n```\n\n**Expected:**\n- Fix #4: export  `filePath` \n- Fix #5: `Readable`  import \n- Fix #6: `winston` \n- Fix #7: `@dnd-kit/utilities` \n- Fix #8: `ALLOWED_ORIGINS`  constants.ts  app.ts \n\n#### Step 5: LayoutEngine \n\n```bash\n# layoutEngine.ts \ngrep -A 20 \"\" backend/src/services/layoutEngine.ts\n# \ngrep -A 20 \"maxCharsPerLine\" backend/src/services/layoutEngine.ts\n```\n\n**Expected:** `.split(' ')` \n\n---\n\n### Final Report\n\n:\n\n```\n## Fix Verification Report\n\n| # | Fix | Status | Notes |\n|---|-----|--------|-------|\n| 1 | ImageUploader useEffect | / | |\n| 2 |  | / | |\n| 3 | SVG | / | |\n| 4 |  | / | |\n| 5 | Readable import | / | |\n| 6 | winston | / | |\n| 7 | @dnd-kit/utilities | / | |\n| 8 | CORS | / | |\n\nBackend build: /\nFrontend build: /\nServer startup: /\n```\n\n---\n\n## Appendix: \n\n:\n\n1. ****  ARCHITECTURE.md  Bearer \n2. **winston / pino Structured Logging**  \n3. **CONTEXT.md **  \n4. **API_SPEC.md **  \n5. ****  jest \n6. **`generation_log` **  API\n7. ****  \n8. **API**  PreviewPage  `handleDelete` \n: \nID: task-1770918400875-2630f2\nBranch: task/task-1770918400875-2630f2\nWorktree: Users/yuyafujita/Projects/koma-fill/.worktrees/task-1770918400875-2630f2",
        "branchColor": "#e84f7f",
        "index": 12
      },
      {
        "type": "anchor",
        "label": "[] CodexCLI3: # KAMUI-4D Bug Fix & ",
        "branch": "task/task-1770918401073-c21f64",
        "worktreePath": "/Users/yuyafujita/Projects/koma-fill/.worktrees/task-1770918401073-c21f64",
        "parentCommitHash": "21c659994cdba8f6164acd549bc5b77b6f2b8504",
        "lane": 5,
        "isMerged": false,
        "mergeCommitHash": null,
        "statusChildren": [],
        "isDefaultWorktree": false,
        "renderMode": "node",
        "shouldHide": false,
        "tagLabel": "task/task-1770918401073-c21f64",
        "taskId": "task-1770918401073-c21f64",
        "taskStatus": "working",
        "taskStatusLabel": "",
        "taskName": "CodexCLI3: # KAMUI-4D Bug Fix & Improvement Prompts for koma-fill\n## Post-Implementation Review  Multi-Agent Fix Guide\n\n**Version:** 1.1 (Post-Review Fix)\n**Project:** koma-fill - AI-powered manga panel generation system\n**Target:** KAMUI-4D Editor (Multi-AI CLI parallel execution)\n**Author:** Code Review by Claude (2026-02-13)\n\n---\n\n## Overview\n\n **3 + 1 + 4** \n\n### Issue Summary\n\n| # |  |  |  | Task |\n|---|------|--------|------|------|\n| 1 | Bug |  High | ImageUploader  useEffect  | Task 2 |\n| 2 | Bug |  High |  | Task 1 |\n| 3 | Bug |  Medium | SVG | Task 1 |\n| 4 | Security |  High |  | Task 1 |\n| 5 | Cleanup |  Low | exportService.ts  import | Task 1 |\n| 6 | Cleanup |  Low | winston  | Task 1 |\n| 7 | Improvement |  Medium | @dnd-kit/utilities  package.json  | Task 2 |\n| 8 | Improvement |  Medium | CORS origin  | Task 1 |\n\n---\n\n## Execution Strategy\n\n```\nTask 1 (Backend)   Agent A  #2,#3,#4,#5,#6,#8\nTask 2 (Frontend)  Agent B  #1,#7\nTask 3 (Verify)    Agent C   & Task 1,2 \n```\n\n**:** Task 1  Task 2 Task 3 \n\n```\nTimeline:\n  \n   Task 1 (Backend)      20-30 min\n   Agent A              \n  \n                           \n              Task 3 (Verify)   10-15 min\n                            Agent C          \n    \n   Task 2 (Frontend)     10-15 min\n   Agent B              \n  \n```\n\n---\n\n## Task 1:  (Agent A)\n### LayoutEngine / Security / Cleanup\n\n**Time Estimate:** 20-30 minutes\n**Difficulty:** Intermediate\n**Dependencies:** None\n\n### Objective\nCORS\n\n### Target Files\n\n```\nbackend/src/\n services/\n    layoutEngine.ts          [MODIFY]  (#2, #3)\n    exportService.ts         [MODIFY] import (#5)\n routes/\n    manga.ts                 [MODIFY]  (#4)\n app.ts                       [MODIFY] CORS (#8)\n config/\n     constants.ts             [MODIFY] ALLOWED_ORIGINS (#8)\nbackend/package.json             [MODIFY] winston (#6)\n```\n\n---\n\n### Fix #2: \n\n**File:** `backend/src/services/layoutEngine.ts`\n**Lines:** 299-313\n**Problem:** `bubble.text.split(' ')` 1\n\n**Current Code ():**\n```typescript\n// \nconst words = bubble.text.split(' ');\nconst lines: string[] = [];\nlet currentLine = '';\nconst maxCharsPerLine = 30;\n\nfor (const word of words) {\n  if ((currentLine + word).length > maxCharsPerLine) {\n    if (currentLine) lines.push(currentLine.trim());\n    currentLine = word + ' ';\n  } else {\n    currentLine += word + ' ';\n  }\n}\nif (currentLine) lines.push(currentLine.trim());\n```\n\n**Fix: **\n```typescript\n// : \nconst maxCharsPerLine = 15; // \nconst lines: string[] = [];\n\n// \nconst hasSpaces = bubble.text.includes(' ');\n\nif (hasSpaces) {\n  // : \n  const words = bubble.text.split(' ');\n  let currentLine = '';\n  for (const word of words) {\n    if ((currentLine + word).length > maxCharsPerLine) {\n      if (currentLine) lines.push(currentLine.trim());\n      currentLine = word + ' ';\n    } else {\n      currentLine += word + ' ';\n    }\n  }\n  if (currentLine) lines.push(currentLine.trim());\n} else {\n  // : \n  const text = bubble.text;\n  for (let i = 0; i < text.length; i += maxCharsPerLine) {\n    lines.push(text.slice(i, i + maxCharsPerLine));\n  }\n}\n```\n\n**Adjustment:**  `bubbleHeight` \n `const bubbleHeight = 60;` (265) :\n\n```typescript\n// bubbleHeight \nconst lineHeight = 20;\nconst verticalPadding = 20;\nconst bubbleHeight = Math.max(50, lines.length * lineHeight + verticalPadding);\n```\n\n**:** `bubbleHeight` ****\n`generateSpeechBubbleSvg` :\n1. lines\n2. bubbleHeight\n3. bubbleX/targetY\n4. shapePath\n5. textElements\n\n\n---\n\n### Fix #3: SVG\n\n**File:** `backend/src/services/layoutEngine.ts`\n**Line:** 320\n**Problem:** SVG `width`/`height` `sharp.composite()` \n\n**Current Code ():**\n```typescript\nconst svg = `<svg width=\"${panelPos.width + panelPos.x}\" height=\"${panelPos.height + panelPos.y}\" xmlns=\"http://www.w3.org/2000/svg\">\n```\n\n**Fix: addSpeechBubbles **\n\nStep 1: `generateSpeechBubbleSvg` :\n```typescript\nprivate generateSpeechBubbleSvg(\n  bubble: SpeechBubble,\n  panelPos: PanelPosition,\n  targetY: number,\n  layoutWidth: number,   //  \n  layoutHeight: number   //  \n): Buffer {\n```\n\nStep 2: SVG:\n```typescript\nconst svg = `<svg width=\"${layoutWidth}\" height=\"${layoutHeight}\" xmlns=\"http://www.w3.org/2000/svg\">\n```\n\nStep 3: `addSpeechBubbles`  (122):\n```typescript\nconst bubbleSvg = this.generateSpeechBubbleSvg(\n  bubble,\n  panelPos,\n  targetY,\n  layout.width,    //  \n  layout.height    //  \n);\n```\n\n---\n\n### Fix #4: \n\n**File:** `backend/src/routes/manga.ts`\n**Lines:** 664-673\n**Problem:**  `filePath: filePath` : `/app/uploads/xxx/panel.png`\n\n**Current Code ():**\n```typescript\nres.json({\n  message: 'Export successful',\n  projectId,\n  format: exportFormat,\n  downloadUrl: `/uploads/${projectId}/${path.basename(filePath)}`,\n  filePath: filePath,         //  \n  fileSize: result.fileSize,\n});\n```\n\n**Fix:**\n```typescript\nres.json({\n  message: 'Export successful',\n  projectId,\n  format: exportFormat,\n  downloadUrl: `/uploads/${projectId}/${path.basename(filePath)}`,\n  fileSize: result.fileSize,\n});\n```\n\n`filePath` OK `downloadUrl` \n\n---\n\n### Fix #5: exportService.ts  import\n\n**File:** `backend/src/services/exportService.ts`\n**Line:** 16\n\n**Current Code:**\n```typescript\nimport { Readable } from 'stream';\n```\n\n**Fix:** `Readable` \n\n---\n\n### Fix #6:  winston \n\n**File:** `backend/package.json`\n\n**Action:**\n```bash\ncd backend\nnpm uninstall winston\n```\n\n`winston`  import  `console.log` / `console.error` \n\n**Note:** Structured Logging `pino`  `winston` \n\n---\n\n### Fix #8: CORS origin \n\n**File:** `backend/src/config/constants.ts`\n\n**:** CONFIG  `ALLOWED_ORIGINS` :\n```typescript\nexport const CONFIG = {\n  // Server\n  PORT: parseInt(process.env.PORT || '5000', 10),\n  NODE_ENV: process.env.NODE_ENV || 'development',\n  BASE_URL: process.env.BASE_URL || 'http://localhost:5000',\n  ALLOWED_ORIGINS: process.env.ALLOWED_ORIGINS\n    ? process.env.ALLOWED_ORIGINS.split(',')\n    : ['http://localhost:3000'],\n\n  // ... \n```\n\n**File:** `backend/src/app.ts`\n\n**Current Code:**\n```typescript\napp.use(cors({\n  origin: process.env.NODE_ENV === 'production'\n    ? process.env.ALLOWED_ORIGINS?.split(',')\n    : ['http://localhost:3000'],\n}));\n```\n\n**Fix:**\n```typescript\nimport { CONFIG } from './config/constants';\n\n// ... (import)\n\napp.use(cors({\n  origin: CONFIG.NODE_ENV === 'production'\n    ? CONFIG.ALLOWED_ORIGINS\n    : CONFIG.ALLOWED_ORIGINS,\n}));\n```\n\n**:** `app.ts`  `CONFIG`  import  `app.ts`  `config/constants`  import \n\n---\n\n### Verification (Task 1)\n\n:\n\n```bash\ncd backend\n\n# TypeScript \nnpx tsc --noEmit\n\n# \nnpm ls --depth=0\n\n# \nnpm run build\n```\n\n**Expected:** \n\n---\n\n## Task 2:  (Agent B)\n### ImageUploader Bug Fix & Dependency Cleanup\n\n**Time Estimate:** 10-15 minutes\n**Difficulty:** Easy\n**Dependencies:** None\n\n### Objective\nImageUploader `package.json` \n\n### Target Files\n\n```\nfrontend/\n src/\n    components/\n        ImageUploader.tsx    [MODIFY] useEffect (#1)\n package.json                 [MODIFY] @dnd-kit/utilities (#7)\n```\n\n---\n\n### Fix #1: ImageUploader  useEffect \n\n**File:** `frontend/src/components/ImageUploader.tsx`\n**Lines:** 25-29\n**Problem:** `useEffect`  `images`  ** ObjectURL  revoke **\n\n**Current Code ():**\n```typescript\nuseEffect(() => {\n  return () => {\n    images.forEach((image) => URL.revokeObjectURL(image.previewUrl));\n  };\n}, [images]);\n```\n\n**:**\n1. A  `images = [A]`\n2. B  `images`  effect \n3.  `images.forEach(URL.revokeObjectURL)` AURL revoke \n4. : ABURL\n\n**Fix:  revoke  +  revoke **\n\n```typescript\n// URL\nuseEffect(() => {\n  return () => {\n    // URL\n    // eslint-disable-next-line react-hooks/exhaustive-deps -- intentionally run only on unmount\n    images.forEach((image) => URL.revokeObjectURL(image.previewUrl));\n  };\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n}, []);\n```\n\n**:** `removeImage` 73-81 `URL.revokeObjectURL` \n\n**:** `eslint-disable` :\n- React  `react-hooks/exhaustive-deps`  `images` \n- \n- `images`  `useRef`  `removeImage`  revoke  cleanup \n\n**Alternative Fix:**\n`useRef`  `images` :\n\n```typescript\nconst imagesRef = useRef<UploadedImage[]>([]);\n\n// imagesref\nuseEffect(() => {\n  imagesRef.current = images;\n}, [images]);\n\n// URL\nuseEffect(() => {\n  return () => {\n    imagesRef.current.forEach((image) => URL.revokeObjectURL(image.previewUrl));\n  };\n}, []);\n```\n\n**:** Alternative FixuseRef ESLint \n\n---\n\n### Fix #7: @dnd-kit/utilities  package.json \n\n**File:** `frontend/package.json`\n\n**Action:**\n```bash\ncd frontend\nnpm install @dnd-kit/utilities\n```\n\n**Reason:** `PanelGrid.tsx`  `@dnd-kit/utilities`  `CSS` `package.json` `@dnd-kit/sortable`  transitive dependency  break\n\n---\n\n### Verification (Task 2)\n\n:\n\n```bash\ncd frontend\n\n# TypeScript \nnpx tsc --noEmit\n\n# \nnpm run build\n\n# package.json \nnpm ls @dnd-kit/utilities\n```\n\n**Expected:** `dist/` \n\n---\n\n## Task 3:  (Agent C)\n### Build Verification & Integration Test\n\n**Time Estimate:** 10-15 minutes\n**Difficulty:** Easy\n**Dependencies:** Task 1  Task 2 \n\n### Objective\nTask 1, 2 TypeScript \n\n### Verification Checklist\n\n#### Step 1: Backend \n\n```bash\ncd backend\n\n# winston\nnpm install\n\n# TypeScript \nnpx tsc --noEmit\necho \"Backend type check: $?\"\n\n# \nnpm run build\necho \"Backend build: $?\"\n\n# \nls -la dist/services/layoutEngine.js\nls -la dist/services/exportService.js\nls -la dist/routes/manga.js\nls -la dist/app.js\n```\n\n**Expected:**\n-  exit code 0\n- `dist/`  `.js`  `.d.ts` \n- `dist/services/exportService.js`  `Readable`  import \n\n#### Step 2: Frontend \n\n```bash\ncd frontend\n\n# @dnd-kit/utilities\nnpm install\n\n# TypeScript \nnpx tsc --noEmit\necho \"Frontend type check: $?\"\n\n# Vite \nnpm run build\necho \"Frontend build: $?\"\n\n# \nls -la dist/\nls -la dist/assets/\n```\n\n**Expected:**\n-  exit code 0\n- `dist/index.html`  `dist/assets/`  JS/CSS \n\n#### Step 3: \n\n```bash\ncd backend\n\n# 5\ntimeout 5 node dist/index.js 2>&1 || true\n\n# \n# curl -s http://localhost:5000/api/health | head -1\n```\n\n**Expected:**\n- `koma-fill server running on http://localhost:5000` \n- DB initialized \n- \n\n#### Step 4: grep \n\n```bash\n# Fix #4: filePath  export \ngrep -n \"filePath:\" backend/src/routes/manga.ts | grep -v \"downloadUrl\\|layoutPath\\|imageFilePath\\|const filePath\\|file_path\\|\\.filePath\"\n\n# Fix #5: Readable  exportService import\ngrep -n \"Readable\" backend/src/services/exportService.ts\n\n# Fix #6: winston  package.json \ngrep -n \"winston\" backend/package.json\n\n# Fix #7: @dnd-kit/utilities  frontend/package.json \ngrep -n \"dnd-kit/utilities\" frontend/package.json\n\n# Fix #8: CONFIG.ALLOWED_ORIGINS \ngrep -n \"ALLOWED_ORIGINS\" backend/src/config/constants.ts\ngrep -n \"ALLOWED_ORIGINS\\|CONFIG\" backend/src/app.ts\n```\n\n**Expected:**\n- Fix #4: export  `filePath` \n- Fix #5: `Readable`  import \n- Fix #6: `winston` \n- Fix #7: `@dnd-kit/utilities` \n- Fix #8: `ALLOWED_ORIGINS`  constants.ts  app.ts \n\n#### Step 5: LayoutEngine \n\n```bash\n# layoutEngine.ts \ngrep -A 20 \"\" backend/src/services/layoutEngine.ts\n# \ngrep -A 20 \"maxCharsPerLine\" backend/src/services/layoutEngine.ts\n```\n\n**Expected:** `.split(' ')` \n\n---\n\n### Final Report\n\n:\n\n```\n## Fix Verification Report\n\n| # | Fix | Status | Notes |\n|---|-----|--------|-------|\n| 1 | ImageUploader useEffect | / | |\n| 2 |  | / | |\n| 3 | SVG | / | |\n| 4 |  | / | |\n| 5 | Readable import | / | |\n| 6 | winston | / | |\n| 7 | @dnd-kit/utilities | / | |\n| 8 | CORS | / | |\n\nBackend build: /\nFrontend build: /\nServer startup: /\n```\n\n---\n\n## Appendix: \n\n:\n\n1. ****  ARCHITECTURE.md  Bearer \n2. **winston / pino Structured Logging**  \n3. **CONTEXT.md **  \n4. **API_SPEC.md **  \n5. ****  jest \n6. **`generation_log` **  API\n7. ****  \n8. **API**  PreviewPage  `handleDelete` ",
        "tooltip": ": CodexCLI3: # KAMUI-4D Bug Fix & Improvement Prompts for koma-fill\n## Post-Implementation Review  Multi-Agent Fix Guide\n\n**Version:** 1.1 (Post-Review Fix)\n**Project:** koma-fill - AI-powered manga panel generation system\n**Target:** KAMUI-4D Editor (Multi-AI CLI parallel execution)\n**Author:** Code Review by Claude (2026-02-13)\n\n---\n\n## Overview\n\n **3 + 1 + 4** \n\n### Issue Summary\n\n| # |  |  |  | Task |\n|---|------|--------|------|------|\n| 1 | Bug |  High | ImageUploader  useEffect  | Task 2 |\n| 2 | Bug |  High |  | Task 1 |\n| 3 | Bug |  Medium | SVG | Task 1 |\n| 4 | Security |  High |  | Task 1 |\n| 5 | Cleanup |  Low | exportService.ts  import | Task 1 |\n| 6 | Cleanup |  Low | winston  | Task 1 |\n| 7 | Improvement |  Medium | @dnd-kit/utilities  package.json  | Task 2 |\n| 8 | Improvement |  Medium | CORS origin  | Task 1 |\n\n---\n\n## Execution Strategy\n\n```\nTask 1 (Backend)   Agent A  #2,#3,#4,#5,#6,#8\nTask 2 (Frontend)  Agent B  #1,#7\nTask 3 (Verify)    Agent C   & Task 1,2 \n```\n\n**:** Task 1  Task 2 Task 3 \n\n```\nTimeline:\n  \n   Task 1 (Backend)      20-30 min\n   Agent A              \n  \n                           \n              Task 3 (Verify)   10-15 min\n                            Agent C          \n    \n   Task 2 (Frontend)     10-15 min\n   Agent B              \n  \n```\n\n---\n\n## Task 1:  (Agent A)\n### LayoutEngine / Security / Cleanup\n\n**Time Estimate:** 20-30 minutes\n**Difficulty:** Intermediate\n**Dependencies:** None\n\n### Objective\nCORS\n\n### Target Files\n\n```\nbackend/src/\n services/\n    layoutEngine.ts          [MODIFY]  (#2, #3)\n    exportService.ts         [MODIFY] import (#5)\n routes/\n    manga.ts                 [MODIFY]  (#4)\n app.ts                       [MODIFY] CORS (#8)\n config/\n     constants.ts             [MODIFY] ALLOWED_ORIGINS (#8)\nbackend/package.json             [MODIFY] winston (#6)\n```\n\n---\n\n### Fix #2: \n\n**File:** `backend/src/services/layoutEngine.ts`\n**Lines:** 299-313\n**Problem:** `bubble.text.split(' ')` 1\n\n**Current Code ():**\n```typescript\n// \nconst words = bubble.text.split(' ');\nconst lines: string[] = [];\nlet currentLine = '';\nconst maxCharsPerLine = 30;\n\nfor (const word of words) {\n  if ((currentLine + word).length > maxCharsPerLine) {\n    if (currentLine) lines.push(currentLine.trim());\n    currentLine = word + ' ';\n  } else {\n    currentLine += word + ' ';\n  }\n}\nif (currentLine) lines.push(currentLine.trim());\n```\n\n**Fix: **\n```typescript\n// : \nconst maxCharsPerLine = 15; // \nconst lines: string[] = [];\n\n// \nconst hasSpaces = bubble.text.includes(' ');\n\nif (hasSpaces) {\n  // : \n  const words = bubble.text.split(' ');\n  let currentLine = '';\n  for (const word of words) {\n    if ((currentLine + word).length > maxCharsPerLine) {\n      if (currentLine) lines.push(currentLine.trim());\n      currentLine = word + ' ';\n    } else {\n      currentLine += word + ' ';\n    }\n  }\n  if (currentLine) lines.push(currentLine.trim());\n} else {\n  // : \n  const text = bubble.text;\n  for (let i = 0; i < text.length; i += maxCharsPerLine) {\n    lines.push(text.slice(i, i + maxCharsPerLine));\n  }\n}\n```\n\n**Adjustment:**  `bubbleHeight` \n `const bubbleHeight = 60;` (265) :\n\n```typescript\n// bubbleHeight \nconst lineHeight = 20;\nconst verticalPadding = 20;\nconst bubbleHeight = Math.max(50, lines.length * lineHeight + verticalPadding);\n```\n\n**:** `bubbleHeight` ****\n`generateSpeechBubbleSvg` :\n1. lines\n2. bubbleHeight\n3. bubbleX/targetY\n4. shapePath\n5. textElements\n\n\n---\n\n### Fix #3: SVG\n\n**File:** `backend/src/services/layoutEngine.ts`\n**Line:** 320\n**Problem:** SVG `width`/`height` `sharp.composite()` \n\n**Current Code ():**\n```typescript\nconst svg = `<svg width=\"${panelPos.width + panelPos.x}\" height=\"${panelPos.height + panelPos.y}\" xmlns=\"http://www.w3.org/2000/svg\">\n```\n\n**Fix: addSpeechBubbles **\n\nStep 1: `generateSpeechBubbleSvg` :\n```typescript\nprivate generateSpeechBubbleSvg(\n  bubble: SpeechBubble,\n  panelPos: PanelPosition,\n  targetY: number,\n  layoutWidth: number,   //  \n  layoutHeight: number   //  \n): Buffer {\n```\n\nStep 2: SVG:\n```typescript\nconst svg = `<svg width=\"${layoutWidth}\" height=\"${layoutHeight}\" xmlns=\"http://www.w3.org/2000/svg\">\n```\n\nStep 3: `addSpeechBubbles`  (122):\n```typescript\nconst bubbleSvg = this.generateSpeechBubbleSvg(\n  bubble,\n  panelPos,\n  targetY,\n  layout.width,    //  \n  layout.height    //  \n);\n```\n\n---\n\n### Fix #4: \n\n**File:** `backend/src/routes/manga.ts`\n**Lines:** 664-673\n**Problem:**  `filePath: filePath` : `/app/uploads/xxx/panel.png`\n\n**Current Code ():**\n```typescript\nres.json({\n  message: 'Export successful',\n  projectId,\n  format: exportFormat,\n  downloadUrl: `/uploads/${projectId}/${path.basename(filePath)}`,\n  filePath: filePath,         //  \n  fileSize: result.fileSize,\n});\n```\n\n**Fix:**\n```typescript\nres.json({\n  message: 'Export successful',\n  projectId,\n  format: exportFormat,\n  downloadUrl: `/uploads/${projectId}/${path.basename(filePath)}`,\n  fileSize: result.fileSize,\n});\n```\n\n`filePath` OK `downloadUrl` \n\n---\n\n### Fix #5: exportService.ts  import\n\n**File:** `backend/src/services/exportService.ts`\n**Line:** 16\n\n**Current Code:**\n```typescript\nimport { Readable } from 'stream';\n```\n\n**Fix:** `Readable` \n\n---\n\n### Fix #6:  winston \n\n**File:** `backend/package.json`\n\n**Action:**\n```bash\ncd backend\nnpm uninstall winston\n```\n\n`winston`  import  `console.log` / `console.error` \n\n**Note:** Structured Logging `pino`  `winston` \n\n---\n\n### Fix #8: CORS origin \n\n**File:** `backend/src/config/constants.ts`\n\n**:** CONFIG  `ALLOWED_ORIGINS` :\n```typescript\nexport const CONFIG = {\n  // Server\n  PORT: parseInt(process.env.PORT || '5000', 10),\n  NODE_ENV: process.env.NODE_ENV || 'development',\n  BASE_URL: process.env.BASE_URL || 'http://localhost:5000',\n  ALLOWED_ORIGINS: process.env.ALLOWED_ORIGINS\n    ? process.env.ALLOWED_ORIGINS.split(',')\n    : ['http://localhost:3000'],\n\n  // ... \n```\n\n**File:** `backend/src/app.ts`\n\n**Current Code:**\n```typescript\napp.use(cors({\n  origin: process.env.NODE_ENV === 'production'\n    ? process.env.ALLOWED_ORIGINS?.split(',')\n    : ['http://localhost:3000'],\n}));\n```\n\n**Fix:**\n```typescript\nimport { CONFIG } from './config/constants';\n\n// ... (import)\n\napp.use(cors({\n  origin: CONFIG.NODE_ENV === 'production'\n    ? CONFIG.ALLOWED_ORIGINS\n    : CONFIG.ALLOWED_ORIGINS,\n}));\n```\n\n**:** `app.ts`  `CONFIG`  import  `app.ts`  `config/constants`  import \n\n---\n\n### Verification (Task 1)\n\n:\n\n```bash\ncd backend\n\n# TypeScript \nnpx tsc --noEmit\n\n# \nnpm ls --depth=0\n\n# \nnpm run build\n```\n\n**Expected:** \n\n---\n\n## Task 2:  (Agent B)\n### ImageUploader Bug Fix & Dependency Cleanup\n\n**Time Estimate:** 10-15 minutes\n**Difficulty:** Easy\n**Dependencies:** None\n\n### Objective\nImageUploader `package.json` \n\n### Target Files\n\n```\nfrontend/\n src/\n    components/\n        ImageUploader.tsx    [MODIFY] useEffect (#1)\n package.json                 [MODIFY] @dnd-kit/utilities (#7)\n```\n\n---\n\n### Fix #1: ImageUploader  useEffect \n\n**File:** `frontend/src/components/ImageUploader.tsx`\n**Lines:** 25-29\n**Problem:** `useEffect`  `images`  ** ObjectURL  revoke **\n\n**Current Code ():**\n```typescript\nuseEffect(() => {\n  return () => {\n    images.forEach((image) => URL.revokeObjectURL(image.previewUrl));\n  };\n}, [images]);\n```\n\n**:**\n1. A  `images = [A]`\n2. B  `images`  effect \n3.  `images.forEach(URL.revokeObjectURL)` AURL revoke \n4. : ABURL\n\n**Fix:  revoke  +  revoke **\n\n```typescript\n// URL\nuseEffect(() => {\n  return () => {\n    // URL\n    // eslint-disable-next-line react-hooks/exhaustive-deps -- intentionally run only on unmount\n    images.forEach((image) => URL.revokeObjectURL(image.previewUrl));\n  };\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n}, []);\n```\n\n**:** `removeImage` 73-81 `URL.revokeObjectURL` \n\n**:** `eslint-disable` :\n- React  `react-hooks/exhaustive-deps`  `images` \n- \n- `images`  `useRef`  `removeImage`  revoke  cleanup \n\n**Alternative Fix:**\n`useRef`  `images` :\n\n```typescript\nconst imagesRef = useRef<UploadedImage[]>([]);\n\n// imagesref\nuseEffect(() => {\n  imagesRef.current = images;\n}, [images]);\n\n// URL\nuseEffect(() => {\n  return () => {\n    imagesRef.current.forEach((image) => URL.revokeObjectURL(image.previewUrl));\n  };\n}, []);\n```\n\n**:** Alternative FixuseRef ESLint \n\n---\n\n### Fix #7: @dnd-kit/utilities  package.json \n\n**File:** `frontend/package.json`\n\n**Action:**\n```bash\ncd frontend\nnpm install @dnd-kit/utilities\n```\n\n**Reason:** `PanelGrid.tsx`  `@dnd-kit/utilities`  `CSS` `package.json` `@dnd-kit/sortable`  transitive dependency  break\n\n---\n\n### Verification (Task 2)\n\n:\n\n```bash\ncd frontend\n\n# TypeScript \nnpx tsc --noEmit\n\n# \nnpm run build\n\n# package.json \nnpm ls @dnd-kit/utilities\n```\n\n**Expected:** `dist/` \n\n---\n\n## Task 3:  (Agent C)\n### Build Verification & Integration Test\n\n**Time Estimate:** 10-15 minutes\n**Difficulty:** Easy\n**Dependencies:** Task 1  Task 2 \n\n### Objective\nTask 1, 2 TypeScript \n\n### Verification Checklist\n\n#### Step 1: Backend \n\n```bash\ncd backend\n\n# winston\nnpm install\n\n# TypeScript \nnpx tsc --noEmit\necho \"Backend type check: $?\"\n\n# \nnpm run build\necho \"Backend build: $?\"\n\n# \nls -la dist/services/layoutEngine.js\nls -la dist/services/exportService.js\nls -la dist/routes/manga.js\nls -la dist/app.js\n```\n\n**Expected:**\n-  exit code 0\n- `dist/`  `.js`  `.d.ts` \n- `dist/services/exportService.js`  `Readable`  import \n\n#### Step 2: Frontend \n\n```bash\ncd frontend\n\n# @dnd-kit/utilities\nnpm install\n\n# TypeScript \nnpx tsc --noEmit\necho \"Frontend type check: $?\"\n\n# Vite \nnpm run build\necho \"Frontend build: $?\"\n\n# \nls -la dist/\nls -la dist/assets/\n```\n\n**Expected:**\n-  exit code 0\n- `dist/index.html`  `dist/assets/`  JS/CSS \n\n#### Step 3: \n\n```bash\ncd backend\n\n# 5\ntimeout 5 node dist/index.js 2>&1 || true\n\n# \n# curl -s http://localhost:5000/api/health | head -1\n```\n\n**Expected:**\n- `koma-fill server running on http://localhost:5000` \n- DB initialized \n- \n\n#### Step 4: grep \n\n```bash\n# Fix #4: filePath  export \ngrep -n \"filePath:\" backend/src/routes/manga.ts | grep -v \"downloadUrl\\|layoutPath\\|imageFilePath\\|const filePath\\|file_path\\|\\.filePath\"\n\n# Fix #5: Readable  exportService import\ngrep -n \"Readable\" backend/src/services/exportService.ts\n\n# Fix #6: winston  package.json \ngrep -n \"winston\" backend/package.json\n\n# Fix #7: @dnd-kit/utilities  frontend/package.json \ngrep -n \"dnd-kit/utilities\" frontend/package.json\n\n# Fix #8: CONFIG.ALLOWED_ORIGINS \ngrep -n \"ALLOWED_ORIGINS\" backend/src/config/constants.ts\ngrep -n \"ALLOWED_ORIGINS\\|CONFIG\" backend/src/app.ts\n```\n\n**Expected:**\n- Fix #4: export  `filePath` \n- Fix #5: `Readable`  import \n- Fix #6: `winston` \n- Fix #7: `@dnd-kit/utilities` \n- Fix #8: `ALLOWED_ORIGINS`  constants.ts  app.ts \n\n#### Step 5: LayoutEngine \n\n```bash\n# layoutEngine.ts \ngrep -A 20 \"\" backend/src/services/layoutEngine.ts\n# \ngrep -A 20 \"maxCharsPerLine\" backend/src/services/layoutEngine.ts\n```\n\n**Expected:** `.split(' ')` \n\n---\n\n### Final Report\n\n:\n\n```\n## Fix Verification Report\n\n| # | Fix | Status | Notes |\n|---|-----|--------|-------|\n| 1 | ImageUploader useEffect | / | |\n| 2 |  | / | |\n| 3 | SVG | / | |\n| 4 |  | / | |\n| 5 | Readable import | / | |\n| 6 | winston | / | |\n| 7 | @dnd-kit/utilities | / | |\n| 8 | CORS | / | |\n\nBackend build: /\nFrontend build: /\nServer startup: /\n```\n\n---\n\n## Appendix: \n\n:\n\n1. ****  ARCHITECTURE.md  Bearer \n2. **winston / pino Structured Logging**  \n3. **CONTEXT.md **  \n4. **API_SPEC.md **  \n5. ****  jest \n6. **`generation_log` **  API\n7. ****  \n8. **API**  PreviewPage  `handleDelete` \n: \nID: task-1770918401073-c21f64\nBranch: task/task-1770918401073-c21f64\nWorktree: Users/yuyafujita/Projects/koma-fill/.worktrees/task-1770918401073-c21f64",
        "branchColor": "#4fe8b8",
        "index": 13
      },
      {
        "type": "anchor",
        "label": "[] ClaudeCode1: # KAMUI-4D Bug Fix ",
        "branch": "task/task-1770918401380-e8add6",
        "worktreePath": "/Users/yuyafujita/Projects/koma-fill/.worktrees/task-1770918401380-e8add6",
        "parentCommitHash": "21c659994cdba8f6164acd549bc5b77b6f2b8504",
        "lane": 3,
        "isMerged": false,
        "mergeCommitHash": null,
        "statusChildren": [
          {
            "type": "unstaged",
            "label": " [task/task-1770918401380-e8add6] (8)",
            "files": [
              "backend/src/app.ts",
              "backend/src/config/constants.ts",
              "backend/src/routes/manga.ts",
              "backend/src/services/exportService.ts",
              "backend/src/services/layoutEngine.ts",
              "frontend/package.json",
              "frontend/src/components/ImageUploader.tsx",
              "package-lock.json"
            ],
            "branch": "task/task-1770918401380-e8add6",
            "targetCommitHash": "21c659994cdba8f6164acd549bc5b77b6f2b8504",
            "worktreePath": "/Users/yuyafujita/Projects/koma-fill/.worktrees/task-1770918401380-e8add6",
            "timestamp": 1770921960631,
            "sortOrder": 0,
            "lane": 3,
            "branchColor": "#e8a84f",
            "index": 5
          },
          {
            "type": "staged",
            "label": " [task/task-1770918401380-e8add6] (1)",
            "files": [
              "ackend/package.json"
            ],
            "branch": "task/task-1770918401380-e8add6",
            "targetCommitHash": "21c659994cdba8f6164acd549bc5b77b6f2b8504",
            "worktreePath": "/Users/yuyafujita/Projects/koma-fill/.worktrees/task-1770918401380-e8add6",
            "timestamp": 1770921960631,
            "sortOrder": 1,
            "lane": 3,
            "branchColor": "#e8a84f",
            "index": 6
          }
        ],
        "isDefaultWorktree": false,
        "renderMode": "node",
        "shouldHide": false,
        "tagLabel": "task/task-1770918401380-e8add6",
        "taskId": "task-1770918401380-e8add6",
        "taskStatus": "working",
        "taskStatusLabel": "",
        "taskName": "ClaudeCode1: # KAMUI-4D Bug Fix & Improvement Prompts for koma-fill\n## Post-Implementation Review  Multi-Agent Fix Guide\n\n**Version:** 1.1 (Post-Review Fix)\n**Project:** koma-fill - AI-powered manga panel generation system\n**Target:** KAMUI-4D Editor (Multi-AI CLI parallel execution)\n**Author:** Code Review by Claude (2026-02-13)\n\n---\n\n## Overview\n\n **3 + 1 + 4** \n\n### Issue Summary\n\n| # |  |  |  | Task |\n|---|------|--------|------|------|\n| 1 | Bug |  High | ImageUploader  useEffect  | Task 2 |\n| 2 | Bug |  High |  | Task 1 |\n| 3 | Bug |  Medium | SVG | Task 1 |\n| 4 | Security |  High |  | Task 1 |\n| 5 | Cleanup |  Low | exportService.ts  import | Task 1 |\n| 6 | Cleanup |  Low | winston  | Task 1 |\n| 7 | Improvement |  Medium | @dnd-kit/utilities  package.json  | Task 2 |\n| 8 | Improvement |  Medium | CORS origin  | Task 1 |\n\n---\n\n## Execution Strategy\n\n```\nTask 1 (Backend)   Agent A  #2,#3,#4,#5,#6,#8\nTask 2 (Frontend)  Agent B  #1,#7\nTask 3 (Verify)    Agent C   & Task 1,2 \n```\n\n**:** Task 1  Task 2 Task 3 \n\n```\nTimeline:\n  \n   Task 1 (Backend)      20-30 min\n   Agent A              \n  \n                           \n              Task 3 (Verify)   10-15 min\n                            Agent C          \n    \n   Task 2 (Frontend)     10-15 min\n   Agent B              \n  \n```\n\n---\n\n## Task 1:  (Agent A)\n### LayoutEngine / Security / Cleanup\n\n**Time Estimate:** 20-30 minutes\n**Difficulty:** Intermediate\n**Dependencies:** None\n\n### Objective\nCORS\n\n### Target Files\n\n```\nbackend/src/\n services/\n    layoutEngine.ts          [MODIFY]  (#2, #3)\n    exportService.ts         [MODIFY] import (#5)\n routes/\n    manga.ts                 [MODIFY]  (#4)\n app.ts                       [MODIFY] CORS (#8)\n config/\n     constants.ts             [MODIFY] ALLOWED_ORIGINS (#8)\nbackend/package.json             [MODIFY] winston (#6)\n```\n\n---\n\n### Fix #2: \n\n**File:** `backend/src/services/layoutEngine.ts`\n**Lines:** 299-313\n**Problem:** `bubble.text.split(' ')` 1\n\n**Current Code ():**\n```typescript\n// \nconst words = bubble.text.split(' ');\nconst lines: string[] = [];\nlet currentLine = '';\nconst maxCharsPerLine = 30;\n\nfor (const word of words) {\n  if ((currentLine + word).length > maxCharsPerLine) {\n    if (currentLine) lines.push(currentLine.trim());\n    currentLine = word + ' ';\n  } else {\n    currentLine += word + ' ';\n  }\n}\nif (currentLine) lines.push(currentLine.trim());\n```\n\n**Fix: **\n```typescript\n// : \nconst maxCharsPerLine = 15; // \nconst lines: string[] = [];\n\n// \nconst hasSpaces = bubble.text.includes(' ');\n\nif (hasSpaces) {\n  // : \n  const words = bubble.text.split(' ');\n  let currentLine = '';\n  for (const word of words) {\n    if ((currentLine + word).length > maxCharsPerLine) {\n      if (currentLine) lines.push(currentLine.trim());\n      currentLine = word + ' ';\n    } else {\n      currentLine += word + ' ';\n    }\n  }\n  if (currentLine) lines.push(currentLine.trim());\n} else {\n  // : \n  const text = bubble.text;\n  for (let i = 0; i < text.length; i += maxCharsPerLine) {\n    lines.push(text.slice(i, i + maxCharsPerLine));\n  }\n}\n```\n\n**Adjustment:**  `bubbleHeight` \n `const bubbleHeight = 60;` (265) :\n\n```typescript\n// bubbleHeight \nconst lineHeight = 20;\nconst verticalPadding = 20;\nconst bubbleHeight = Math.max(50, lines.length * lineHeight + verticalPadding);\n```\n\n**:** `bubbleHeight` ****\n`generateSpeechBubbleSvg` :\n1. lines\n2. bubbleHeight\n3. bubbleX/targetY\n4. shapePath\n5. textElements\n\n\n---\n\n### Fix #3: SVG\n\n**File:** `backend/src/services/layoutEngine.ts`\n**Line:** 320\n**Problem:** SVG `width`/`height` `sharp.composite()` \n\n**Current Code ():**\n```typescript\nconst svg = `<svg width=\"${panelPos.width + panelPos.x}\" height=\"${panelPos.height + panelPos.y}\" xmlns=\"http://www.w3.org/2000/svg\">\n```\n\n**Fix: addSpeechBubbles **\n\nStep 1: `generateSpeechBubbleSvg` :\n```typescript\nprivate generateSpeechBubbleSvg(\n  bubble: SpeechBubble,\n  panelPos: PanelPosition,\n  targetY: number,\n  layoutWidth: number,   //  \n  layoutHeight: number   //  \n): Buffer {\n```\n\nStep 2: SVG:\n```typescript\nconst svg = `<svg width=\"${layoutWidth}\" height=\"${layoutHeight}\" xmlns=\"http://www.w3.org/2000/svg\">\n```\n\nStep 3: `addSpeechBubbles`  (122):\n```typescript\nconst bubbleSvg = this.generateSpeechBubbleSvg(\n  bubble,\n  panelPos,\n  targetY,\n  layout.width,    //  \n  layout.height    //  \n);\n```\n\n---\n\n### Fix #4: \n\n**File:** `backend/src/routes/manga.ts`\n**Lines:** 664-673\n**Problem:**  `filePath: filePath` : `/app/uploads/xxx/panel.png`\n\n**Current Code ():**\n```typescript\nres.json({\n  message: 'Export successful',\n  projectId,\n  format: exportFormat,\n  downloadUrl: `/uploads/${projectId}/${path.basename(filePath)}`,\n  filePath: filePath,         //  \n  fileSize: result.fileSize,\n});\n```\n\n**Fix:**\n```typescript\nres.json({\n  message: 'Export successful',\n  projectId,\n  format: exportFormat,\n  downloadUrl: `/uploads/${projectId}/${path.basename(filePath)}`,\n  fileSize: result.fileSize,\n});\n```\n\n`filePath` OK `downloadUrl` \n\n---\n\n### Fix #5: exportService.ts  import\n\n**File:** `backend/src/services/exportService.ts`\n**Line:** 16\n\n**Current Code:**\n```typescript\nimport { Readable } from 'stream';\n```\n\n**Fix:** `Readable` \n\n---\n\n### Fix #6:  winston \n\n**File:** `backend/package.json`\n\n**Action:**\n```bash\ncd backend\nnpm uninstall winston\n```\n\n`winston`  import  `console.log` / `console.error` \n\n**Note:** Structured Logging `pino`  `winston` \n\n---\n\n### Fix #8: CORS origin \n\n**File:** `backend/src/config/constants.ts`\n\n**:** CONFIG  `ALLOWED_ORIGINS` :\n```typescript\nexport const CONFIG = {\n  // Server\n  PORT: parseInt(process.env.PORT || '5000', 10),\n  NODE_ENV: process.env.NODE_ENV || 'development',\n  BASE_URL: process.env.BASE_URL || 'http://localhost:5000',\n  ALLOWED_ORIGINS: process.env.ALLOWED_ORIGINS\n    ? process.env.ALLOWED_ORIGINS.split(',')\n    : ['http://localhost:3000'],\n\n  // ... \n```\n\n**File:** `backend/src/app.ts`\n\n**Current Code:**\n```typescript\napp.use(cors({\n  origin: process.env.NODE_ENV === 'production'\n    ? process.env.ALLOWED_ORIGINS?.split(',')\n    : ['http://localhost:3000'],\n}));\n```\n\n**Fix:**\n```typescript\nimport { CONFIG } from './config/constants';\n\n// ... (import)\n\napp.use(cors({\n  origin: CONFIG.NODE_ENV === 'production'\n    ? CONFIG.ALLOWED_ORIGINS\n    : CONFIG.ALLOWED_ORIGINS,\n}));\n```\n\n**:** `app.ts`  `CONFIG`  import  `app.ts`  `config/constants`  import \n\n---\n\n### Verification (Task 1)\n\n:\n\n```bash\ncd backend\n\n# TypeScript \nnpx tsc --noEmit\n\n# \nnpm ls --depth=0\n\n# \nnpm run build\n```\n\n**Expected:** \n\n---\n\n## Task 2:  (Agent B)\n### ImageUploader Bug Fix & Dependency Cleanup\n\n**Time Estimate:** 10-15 minutes\n**Difficulty:** Easy\n**Dependencies:** None\n\n### Objective\nImageUploader `package.json` \n\n### Target Files\n\n```\nfrontend/\n src/\n    components/\n        ImageUploader.tsx    [MODIFY] useEffect (#1)\n package.json                 [MODIFY] @dnd-kit/utilities (#7)\n```\n\n---\n\n### Fix #1: ImageUploader  useEffect \n\n**File:** `frontend/src/components/ImageUploader.tsx`\n**Lines:** 25-29\n**Problem:** `useEffect`  `images`  ** ObjectURL  revoke **\n\n**Current Code ():**\n```typescript\nuseEffect(() => {\n  return () => {\n    images.forEach((image) => URL.revokeObjectURL(image.previewUrl));\n  };\n}, [images]);\n```\n\n**:**\n1. A  `images = [A]`\n2. B  `images`  effect \n3.  `images.forEach(URL.revokeObjectURL)` AURL revoke \n4. : ABURL\n\n**Fix:  revoke  +  revoke **\n\n```typescript\n// URL\nuseEffect(() => {\n  return () => {\n    // URL\n    // eslint-disable-next-line react-hooks/exhaustive-deps -- intentionally run only on unmount\n    images.forEach((image) => URL.revokeObjectURL(image.previewUrl));\n  };\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n}, []);\n```\n\n**:** `removeImage` 73-81 `URL.revokeObjectURL` \n\n**:** `eslint-disable` :\n- React  `react-hooks/exhaustive-deps`  `images` \n- \n- `images`  `useRef`  `removeImage`  revoke  cleanup \n\n**Alternative Fix:**\n`useRef`  `images` :\n\n```typescript\nconst imagesRef = useRef<UploadedImage[]>([]);\n\n// imagesref\nuseEffect(() => {\n  imagesRef.current = images;\n}, [images]);\n\n// URL\nuseEffect(() => {\n  return () => {\n    imagesRef.current.forEach((image) => URL.revokeObjectURL(image.previewUrl));\n  };\n}, []);\n```\n\n**:** Alternative FixuseRef ESLint \n\n---\n\n### Fix #7: @dnd-kit/utilities  package.json \n\n**File:** `frontend/package.json`\n\n**Action:**\n```bash\ncd frontend\nnpm install @dnd-kit/utilities\n```\n\n**Reason:** `PanelGrid.tsx`  `@dnd-kit/utilities`  `CSS` `package.json` `@dnd-kit/sortable`  transitive dependency  break\n\n---\n\n### Verification (Task 2)\n\n:\n\n```bash\ncd frontend\n\n# TypeScript \nnpx tsc --noEmit\n\n# \nnpm run build\n\n# package.json \nnpm ls @dnd-kit/utilities\n```\n\n**Expected:** `dist/` \n\n---\n\n## Task 3:  (Agent C)\n### Build Verification & Integration Test\n\n**Time Estimate:** 10-15 minutes\n**Difficulty:** Easy\n**Dependencies:** Task 1  Task 2 \n\n### Objective\nTask 1, 2 TypeScript \n\n### Verification Checklist\n\n#### Step 1: Backend \n\n```bash\ncd backend\n\n# winston\nnpm install\n\n# TypeScript \nnpx tsc --noEmit\necho \"Backend type check: $?\"\n\n# \nnpm run build\necho \"Backend build: $?\"\n\n# \nls -la dist/services/layoutEngine.js\nls -la dist/services/exportService.js\nls -la dist/routes/manga.js\nls -la dist/app.js\n```\n\n**Expected:**\n-  exit code 0\n- `dist/`  `.js`  `.d.ts` \n- `dist/services/exportService.js`  `Readable`  import \n\n#### Step 2: Frontend \n\n```bash\ncd frontend\n\n# @dnd-kit/utilities\nnpm install\n\n# TypeScript \nnpx tsc --noEmit\necho \"Frontend type check: $?\"\n\n# Vite \nnpm run build\necho \"Frontend build: $?\"\n\n# \nls -la dist/\nls -la dist/assets/\n```\n\n**Expected:**\n-  exit code 0\n- `dist/index.html`  `dist/assets/`  JS/CSS \n\n#### Step 3: \n\n```bash\ncd backend\n\n# 5\ntimeout 5 node dist/index.js 2>&1 || true\n\n# \n# curl -s http://localhost:5000/api/health | head -1\n```\n\n**Expected:**\n- `koma-fill server running on http://localhost:5000` \n- DB initialized \n- \n\n#### Step 4: grep \n\n```bash\n# Fix #4: filePath  export \ngrep -n \"filePath:\" backend/src/routes/manga.ts | grep -v \"downloadUrl\\|layoutPath\\|imageFilePath\\|const filePath\\|file_path\\|\\.filePath\"\n\n# Fix #5: Readable  exportService import\ngrep -n \"Readable\" backend/src/services/exportService.ts\n\n# Fix #6: winston  package.json \ngrep -n \"winston\" backend/package.json\n\n# Fix #7: @dnd-kit/utilities  frontend/package.json \ngrep -n \"dnd-kit/utilities\" frontend/package.json\n\n# Fix #8: CONFIG.ALLOWED_ORIGINS \ngrep -n \"ALLOWED_ORIGINS\" backend/src/config/constants.ts\ngrep -n \"ALLOWED_ORIGINS\\|CONFIG\" backend/src/app.ts\n```\n\n**Expected:**\n- Fix #4: export  `filePath` \n- Fix #5: `Readable`  import \n- Fix #6: `winston` \n- Fix #7: `@dnd-kit/utilities` \n- Fix #8: `ALLOWED_ORIGINS`  constants.ts  app.ts \n\n#### Step 5: LayoutEngine \n\n```bash\n# layoutEngine.ts \ngrep -A 20 \"\" backend/src/services/layoutEngine.ts\n# \ngrep -A 20 \"maxCharsPerLine\" backend/src/services/layoutEngine.ts\n```\n\n**Expected:** `.split(' ')` \n\n---\n\n### Final Report\n\n:\n\n```\n## Fix Verification Report\n\n| # | Fix | Status | Notes |\n|---|-----|--------|-------|\n| 1 | ImageUploader useEffect | / | |\n| 2 |  | / | |\n| 3 | SVG | / | |\n| 4 |  | / | |\n| 5 | Readable import | / | |\n| 6 | winston | / | |\n| 7 | @dnd-kit/utilities | / | |\n| 8 | CORS | / | |\n\nBackend build: /\nFrontend build: /\nServer startup: /\n```\n\n---\n\n## Appendix: \n\n:\n\n1. ****  ARCHITECTURE.md  Bearer \n2. **winston / pino Structured Logging**  \n3. **CONTEXT.md **  \n4. **API_SPEC.md **  \n5. ****  jest \n6. **`generation_log` **  API\n7. ****  \n8. **API**  PreviewPage  `handleDelete` ",
        "tooltip": ": ClaudeCode1: # KAMUI-4D Bug Fix & Improvement Prompts for koma-fill\n## Post-Implementation Review  Multi-Agent Fix Guide\n\n**Version:** 1.1 (Post-Review Fix)\n**Project:** koma-fill - AI-powered manga panel generation system\n**Target:** KAMUI-4D Editor (Multi-AI CLI parallel execution)\n**Author:** Code Review by Claude (2026-02-13)\n\n---\n\n## Overview\n\n **3 + 1 + 4** \n\n### Issue Summary\n\n| # |  |  |  | Task |\n|---|------|--------|------|------|\n| 1 | Bug |  High | ImageUploader  useEffect  | Task 2 |\n| 2 | Bug |  High |  | Task 1 |\n| 3 | Bug |  Medium | SVG | Task 1 |\n| 4 | Security |  High |  | Task 1 |\n| 5 | Cleanup |  Low | exportService.ts  import | Task 1 |\n| 6 | Cleanup |  Low | winston  | Task 1 |\n| 7 | Improvement |  Medium | @dnd-kit/utilities  package.json  | Task 2 |\n| 8 | Improvement |  Medium | CORS origin  | Task 1 |\n\n---\n\n## Execution Strategy\n\n```\nTask 1 (Backend)   Agent A  #2,#3,#4,#5,#6,#8\nTask 2 (Frontend)  Agent B  #1,#7\nTask 3 (Verify)    Agent C   & Task 1,2 \n```\n\n**:** Task 1  Task 2 Task 3 \n\n```\nTimeline:\n  \n   Task 1 (Backend)      20-30 min\n   Agent A              \n  \n                           \n              Task 3 (Verify)   10-15 min\n                            Agent C          \n    \n   Task 2 (Frontend)     10-15 min\n   Agent B              \n  \n```\n\n---\n\n## Task 1:  (Agent A)\n### LayoutEngine / Security / Cleanup\n\n**Time Estimate:** 20-30 minutes\n**Difficulty:** Intermediate\n**Dependencies:** None\n\n### Objective\nCORS\n\n### Target Files\n\n```\nbackend/src/\n services/\n    layoutEngine.ts          [MODIFY]  (#2, #3)\n    exportService.ts         [MODIFY] import (#5)\n routes/\n    manga.ts                 [MODIFY]  (#4)\n app.ts                       [MODIFY] CORS (#8)\n config/\n     constants.ts             [MODIFY] ALLOWED_ORIGINS (#8)\nbackend/package.json             [MODIFY] winston (#6)\n```\n\n---\n\n### Fix #2: \n\n**File:** `backend/src/services/layoutEngine.ts`\n**Lines:** 299-313\n**Problem:** `bubble.text.split(' ')` 1\n\n**Current Code ():**\n```typescript\n// \nconst words = bubble.text.split(' ');\nconst lines: string[] = [];\nlet currentLine = '';\nconst maxCharsPerLine = 30;\n\nfor (const word of words) {\n  if ((currentLine + word).length > maxCharsPerLine) {\n    if (currentLine) lines.push(currentLine.trim());\n    currentLine = word + ' ';\n  } else {\n    currentLine += word + ' ';\n  }\n}\nif (currentLine) lines.push(currentLine.trim());\n```\n\n**Fix: **\n```typescript\n// : \nconst maxCharsPerLine = 15; // \nconst lines: string[] = [];\n\n// \nconst hasSpaces = bubble.text.includes(' ');\n\nif (hasSpaces) {\n  // : \n  const words = bubble.text.split(' ');\n  let currentLine = '';\n  for (const word of words) {\n    if ((currentLine + word).length > maxCharsPerLine) {\n      if (currentLine) lines.push(currentLine.trim());\n      currentLine = word + ' ';\n    } else {\n      currentLine += word + ' ';\n    }\n  }\n  if (currentLine) lines.push(currentLine.trim());\n} else {\n  // : \n  const text = bubble.text;\n  for (let i = 0; i < text.length; i += maxCharsPerLine) {\n    lines.push(text.slice(i, i + maxCharsPerLine));\n  }\n}\n```\n\n**Adjustment:**  `bubbleHeight` \n `const bubbleHeight = 60;` (265) :\n\n```typescript\n// bubbleHeight \nconst lineHeight = 20;\nconst verticalPadding = 20;\nconst bubbleHeight = Math.max(50, lines.length * lineHeight + verticalPadding);\n```\n\n**:** `bubbleHeight` ****\n`generateSpeechBubbleSvg` :\n1. lines\n2. bubbleHeight\n3. bubbleX/targetY\n4. shapePath\n5. textElements\n\n\n---\n\n### Fix #3: SVG\n\n**File:** `backend/src/services/layoutEngine.ts`\n**Line:** 320\n**Problem:** SVG `width`/`height` `sharp.composite()` \n\n**Current Code ():**\n```typescript\nconst svg = `<svg width=\"${panelPos.width + panelPos.x}\" height=\"${panelPos.height + panelPos.y}\" xmlns=\"http://www.w3.org/2000/svg\">\n```\n\n**Fix: addSpeechBubbles **\n\nStep 1: `generateSpeechBubbleSvg` :\n```typescript\nprivate generateSpeechBubbleSvg(\n  bubble: SpeechBubble,\n  panelPos: PanelPosition,\n  targetY: number,\n  layoutWidth: number,   //  \n  layoutHeight: number   //  \n): Buffer {\n```\n\nStep 2: SVG:\n```typescript\nconst svg = `<svg width=\"${layoutWidth}\" height=\"${layoutHeight}\" xmlns=\"http://www.w3.org/2000/svg\">\n```\n\nStep 3: `addSpeechBubbles`  (122):\n```typescript\nconst bubbleSvg = this.generateSpeechBubbleSvg(\n  bubble,\n  panelPos,\n  targetY,\n  layout.width,    //  \n  layout.height    //  \n);\n```\n\n---\n\n### Fix #4: \n\n**File:** `backend/src/routes/manga.ts`\n**Lines:** 664-673\n**Problem:**  `filePath: filePath` : `/app/uploads/xxx/panel.png`\n\n**Current Code ():**\n```typescript\nres.json({\n  message: 'Export successful',\n  projectId,\n  format: exportFormat,\n  downloadUrl: `/uploads/${projectId}/${path.basename(filePath)}`,\n  filePath: filePath,         //  \n  fileSize: result.fileSize,\n});\n```\n\n**Fix:**\n```typescript\nres.json({\n  message: 'Export successful',\n  projectId,\n  format: exportFormat,\n  downloadUrl: `/uploads/${projectId}/${path.basename(filePath)}`,\n  fileSize: result.fileSize,\n});\n```\n\n`filePath` OK `downloadUrl` \n\n---\n\n### Fix #5: exportService.ts  import\n\n**File:** `backend/src/services/exportService.ts`\n**Line:** 16\n\n**Current Code:**\n```typescript\nimport { Readable } from 'stream';\n```\n\n**Fix:** `Readable` \n\n---\n\n### Fix #6:  winston \n\n**File:** `backend/package.json`\n\n**Action:**\n```bash\ncd backend\nnpm uninstall winston\n```\n\n`winston`  import  `console.log` / `console.error` \n\n**Note:** Structured Logging `pino`  `winston` \n\n---\n\n### Fix #8: CORS origin \n\n**File:** `backend/src/config/constants.ts`\n\n**:** CONFIG  `ALLOWED_ORIGINS` :\n```typescript\nexport const CONFIG = {\n  // Server\n  PORT: parseInt(process.env.PORT || '5000', 10),\n  NODE_ENV: process.env.NODE_ENV || 'development',\n  BASE_URL: process.env.BASE_URL || 'http://localhost:5000',\n  ALLOWED_ORIGINS: process.env.ALLOWED_ORIGINS\n    ? process.env.ALLOWED_ORIGINS.split(',')\n    : ['http://localhost:3000'],\n\n  // ... \n```\n\n**File:** `backend/src/app.ts`\n\n**Current Code:**\n```typescript\napp.use(cors({\n  origin: process.env.NODE_ENV === 'production'\n    ? process.env.ALLOWED_ORIGINS?.split(',')\n    : ['http://localhost:3000'],\n}));\n```\n\n**Fix:**\n```typescript\nimport { CONFIG } from './config/constants';\n\n// ... (import)\n\napp.use(cors({\n  origin: CONFIG.NODE_ENV === 'production'\n    ? CONFIG.ALLOWED_ORIGINS\n    : CONFIG.ALLOWED_ORIGINS,\n}));\n```\n\n**:** `app.ts`  `CONFIG`  import  `app.ts`  `config/constants`  import \n\n---\n\n### Verification (Task 1)\n\n:\n\n```bash\ncd backend\n\n# TypeScript \nnpx tsc --noEmit\n\n# \nnpm ls --depth=0\n\n# \nnpm run build\n```\n\n**Expected:** \n\n---\n\n## Task 2:  (Agent B)\n### ImageUploader Bug Fix & Dependency Cleanup\n\n**Time Estimate:** 10-15 minutes\n**Difficulty:** Easy\n**Dependencies:** None\n\n### Objective\nImageUploader `package.json` \n\n### Target Files\n\n```\nfrontend/\n src/\n    components/\n        ImageUploader.tsx    [MODIFY] useEffect (#1)\n package.json                 [MODIFY] @dnd-kit/utilities (#7)\n```\n\n---\n\n### Fix #1: ImageUploader  useEffect \n\n**File:** `frontend/src/components/ImageUploader.tsx`\n**Lines:** 25-29\n**Problem:** `useEffect`  `images`  ** ObjectURL  revoke **\n\n**Current Code ():**\n```typescript\nuseEffect(() => {\n  return () => {\n    images.forEach((image) => URL.revokeObjectURL(image.previewUrl));\n  };\n}, [images]);\n```\n\n**:**\n1. A  `images = [A]`\n2. B  `images`  effect \n3.  `images.forEach(URL.revokeObjectURL)` AURL revoke \n4. : ABURL\n\n**Fix:  revoke  +  revoke **\n\n```typescript\n// URL\nuseEffect(() => {\n  return () => {\n    // URL\n    // eslint-disable-next-line react-hooks/exhaustive-deps -- intentionally run only on unmount\n    images.forEach((image) => URL.revokeObjectURL(image.previewUrl));\n  };\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n}, []);\n```\n\n**:** `removeImage` 73-81 `URL.revokeObjectURL` \n\n**:** `eslint-disable` :\n- React  `react-hooks/exhaustive-deps`  `images` \n- \n- `images`  `useRef`  `removeImage`  revoke  cleanup \n\n**Alternative Fix:**\n`useRef`  `images` :\n\n```typescript\nconst imagesRef = useRef<UploadedImage[]>([]);\n\n// imagesref\nuseEffect(() => {\n  imagesRef.current = images;\n}, [images]);\n\n// URL\nuseEffect(() => {\n  return () => {\n    imagesRef.current.forEach((image) => URL.revokeObjectURL(image.previewUrl));\n  };\n}, []);\n```\n\n**:** Alternative FixuseRef ESLint \n\n---\n\n### Fix #7: @dnd-kit/utilities  package.json \n\n**File:** `frontend/package.json`\n\n**Action:**\n```bash\ncd frontend\nnpm install @dnd-kit/utilities\n```\n\n**Reason:** `PanelGrid.tsx`  `@dnd-kit/utilities`  `CSS` `package.json` `@dnd-kit/sortable`  transitive dependency  break\n\n---\n\n### Verification (Task 2)\n\n:\n\n```bash\ncd frontend\n\n# TypeScript \nnpx tsc --noEmit\n\n# \nnpm run build\n\n# package.json \nnpm ls @dnd-kit/utilities\n```\n\n**Expected:** `dist/` \n\n---\n\n## Task 3:  (Agent C)\n### Build Verification & Integration Test\n\n**Time Estimate:** 10-15 minutes\n**Difficulty:** Easy\n**Dependencies:** Task 1  Task 2 \n\n### Objective\nTask 1, 2 TypeScript \n\n### Verification Checklist\n\n#### Step 1: Backend \n\n```bash\ncd backend\n\n# winston\nnpm install\n\n# TypeScript \nnpx tsc --noEmit\necho \"Backend type check: $?\"\n\n# \nnpm run build\necho \"Backend build: $?\"\n\n# \nls -la dist/services/layoutEngine.js\nls -la dist/services/exportService.js\nls -la dist/routes/manga.js\nls -la dist/app.js\n```\n\n**Expected:**\n-  exit code 0\n- `dist/`  `.js`  `.d.ts` \n- `dist/services/exportService.js`  `Readable`  import \n\n#### Step 2: Frontend \n\n```bash\ncd frontend\n\n# @dnd-kit/utilities\nnpm install\n\n# TypeScript \nnpx tsc --noEmit\necho \"Frontend type check: $?\"\n\n# Vite \nnpm run build\necho \"Frontend build: $?\"\n\n# \nls -la dist/\nls -la dist/assets/\n```\n\n**Expected:**\n-  exit code 0\n- `dist/index.html`  `dist/assets/`  JS/CSS \n\n#### Step 3: \n\n```bash\ncd backend\n\n# 5\ntimeout 5 node dist/index.js 2>&1 || true\n\n# \n# curl -s http://localhost:5000/api/health | head -1\n```\n\n**Expected:**\n- `koma-fill server running on http://localhost:5000` \n- DB initialized \n- \n\n#### Step 4: grep \n\n```bash\n# Fix #4: filePath  export \ngrep -n \"filePath:\" backend/src/routes/manga.ts | grep -v \"downloadUrl\\|layoutPath\\|imageFilePath\\|const filePath\\|file_path\\|\\.filePath\"\n\n# Fix #5: Readable  exportService import\ngrep -n \"Readable\" backend/src/services/exportService.ts\n\n# Fix #6: winston  package.json \ngrep -n \"winston\" backend/package.json\n\n# Fix #7: @dnd-kit/utilities  frontend/package.json \ngrep -n \"dnd-kit/utilities\" frontend/package.json\n\n# Fix #8: CONFIG.ALLOWED_ORIGINS \ngrep -n \"ALLOWED_ORIGINS\" backend/src/config/constants.ts\ngrep -n \"ALLOWED_ORIGINS\\|CONFIG\" backend/src/app.ts\n```\n\n**Expected:**\n- Fix #4: export  `filePath` \n- Fix #5: `Readable`  import \n- Fix #6: `winston` \n- Fix #7: `@dnd-kit/utilities` \n- Fix #8: `ALLOWED_ORIGINS`  constants.ts  app.ts \n\n#### Step 5: LayoutEngine \n\n```bash\n# layoutEngine.ts \ngrep -A 20 \"\" backend/src/services/layoutEngine.ts\n# \ngrep -A 20 \"maxCharsPerLine\" backend/src/services/layoutEngine.ts\n```\n\n**Expected:** `.split(' ')` \n\n---\n\n### Final Report\n\n:\n\n```\n## Fix Verification Report\n\n| # | Fix | Status | Notes |\n|---|-----|--------|-------|\n| 1 | ImageUploader useEffect | / | |\n| 2 |  | / | |\n| 3 | SVG | / | |\n| 4 |  | / | |\n| 5 | Readable import | / | |\n| 6 | winston | / | |\n| 7 | @dnd-kit/utilities | / | |\n| 8 | CORS | / | |\n\nBackend build: /\nFrontend build: /\nServer startup: /\n```\n\n---\n\n## Appendix: \n\n:\n\n1. ****  ARCHITECTURE.md  Bearer \n2. **winston / pino Structured Logging**  \n3. **CONTEXT.md **  \n4. **API_SPEC.md **  \n5. ****  jest \n6. **`generation_log` **  API\n7. ****  \n8. **API**  PreviewPage  `handleDelete` \n: \nID: task-1770918401380-e8add6\nBranch: task/task-1770918401380-e8add6\nWorktree: Users/yuyafujita/Projects/koma-fill/.worktrees/task-1770918401380-e8add6",
        "branchColor": "#e8a84f",
        "index": 14
      },
      {
        "type": "anchor",
        "label": "[] ClaudeCode2: # KAMUI-4D Bug Fix ",
        "branch": "task/task-1770918401534-118872",
        "worktreePath": "/Users/yuyafujita/Projects/koma-fill/.worktrees/task-1770918401534-118872",
        "parentCommitHash": "21c659994cdba8f6164acd549bc5b77b6f2b8504",
        "lane": 6,
        "isMerged": false,
        "mergeCommitHash": null,
        "statusChildren": [
          {
            "type": "unstaged",
            "label": " [task/task-1770918401534-118872] (8)",
            "files": [
              "backend/src/app.ts",
              "backend/src/config/constants.ts",
              "backend/src/routes/manga.ts",
              "backend/src/services/exportService.ts",
              "backend/src/services/layoutEngine.ts",
              "frontend/package.json",
              "frontend/src/components/ImageUploader.tsx",
              "package-lock.json"
            ],
            "branch": "task/task-1770918401534-118872",
            "targetCommitHash": "21c659994cdba8f6164acd549bc5b77b6f2b8504",
            "worktreePath": "/Users/yuyafujita/Projects/koma-fill/.worktrees/task-1770918401534-118872",
            "timestamp": 1770921960630,
            "sortOrder": 0,
            "lane": 6,
            "branchColor": "#e8e84f",
            "index": 7
          },
          {
            "type": "staged",
            "label": " [task/task-1770918401534-118872] (1)",
            "files": [
              "ackend/package.json"
            ],
            "branch": "task/task-1770918401534-118872",
            "targetCommitHash": "21c659994cdba8f6164acd549bc5b77b6f2b8504",
            "worktreePath": "/Users/yuyafujita/Projects/koma-fill/.worktrees/task-1770918401534-118872",
            "timestamp": 1770921960630,
            "sortOrder": 1,
            "lane": 6,
            "branchColor": "#e8e84f",
            "index": 8
          }
        ],
        "isDefaultWorktree": false,
        "renderMode": "node",
        "shouldHide": false,
        "tagLabel": "task/task-1770918401534-118872",
        "taskId": "task-1770918401534-118872",
        "taskStatus": "working",
        "taskStatusLabel": "",
        "taskName": "ClaudeCode2: # KAMUI-4D Bug Fix & Improvement Prompts for koma-fill\n## Post-Implementation Review  Multi-Agent Fix Guide\n\n**Version:** 1.1 (Post-Review Fix)\n**Project:** koma-fill - AI-powered manga panel generation system\n**Target:** KAMUI-4D Editor (Multi-AI CLI parallel execution)\n**Author:** Code Review by Claude (2026-02-13)\n\n---\n\n## Overview\n\n **3 + 1 + 4** \n\n### Issue Summary\n\n| # |  |  |  | Task |\n|---|------|--------|------|------|\n| 1 | Bug |  High | ImageUploader  useEffect  | Task 2 |\n| 2 | Bug |  High |  | Task 1 |\n| 3 | Bug |  Medium | SVG | Task 1 |\n| 4 | Security |  High |  | Task 1 |\n| 5 | Cleanup |  Low | exportService.ts  import | Task 1 |\n| 6 | Cleanup |  Low | winston  | Task 1 |\n| 7 | Improvement |  Medium | @dnd-kit/utilities  package.json  | Task 2 |\n| 8 | Improvement |  Medium | CORS origin  | Task 1 |\n\n---\n\n## Execution Strategy\n\n```\nTask 1 (Backend)   Agent A  #2,#3,#4,#5,#6,#8\nTask 2 (Frontend)  Agent B  #1,#7\nTask 3 (Verify)    Agent C   & Task 1,2 \n```\n\n**:** Task 1  Task 2 Task 3 \n\n```\nTimeline:\n  \n   Task 1 (Backend)      20-30 min\n   Agent A              \n  \n                           \n              Task 3 (Verify)   10-15 min\n                            Agent C          \n    \n   Task 2 (Frontend)     10-15 min\n   Agent B              \n  \n```\n\n---\n\n## Task 1:  (Agent A)\n### LayoutEngine / Security / Cleanup\n\n**Time Estimate:** 20-30 minutes\n**Difficulty:** Intermediate\n**Dependencies:** None\n\n### Objective\nCORS\n\n### Target Files\n\n```\nbackend/src/\n services/\n    layoutEngine.ts          [MODIFY]  (#2, #3)\n    exportService.ts         [MODIFY] import (#5)\n routes/\n    manga.ts                 [MODIFY]  (#4)\n app.ts                       [MODIFY] CORS (#8)\n config/\n     constants.ts             [MODIFY] ALLOWED_ORIGINS (#8)\nbackend/package.json             [MODIFY] winston (#6)\n```\n\n---\n\n### Fix #2: \n\n**File:** `backend/src/services/layoutEngine.ts`\n**Lines:** 299-313\n**Problem:** `bubble.text.split(' ')` 1\n\n**Current Code ():**\n```typescript\n// \nconst words = bubble.text.split(' ');\nconst lines: string[] = [];\nlet currentLine = '';\nconst maxCharsPerLine = 30;\n\nfor (const word of words) {\n  if ((currentLine + word).length > maxCharsPerLine) {\n    if (currentLine) lines.push(currentLine.trim());\n    currentLine = word + ' ';\n  } else {\n    currentLine += word + ' ';\n  }\n}\nif (currentLine) lines.push(currentLine.trim());\n```\n\n**Fix: **\n```typescript\n// : \nconst maxCharsPerLine = 15; // \nconst lines: string[] = [];\n\n// \nconst hasSpaces = bubble.text.includes(' ');\n\nif (hasSpaces) {\n  // : \n  const words = bubble.text.split(' ');\n  let currentLine = '';\n  for (const word of words) {\n    if ((currentLine + word).length > maxCharsPerLine) {\n      if (currentLine) lines.push(currentLine.trim());\n      currentLine = word + ' ';\n    } else {\n      currentLine += word + ' ';\n    }\n  }\n  if (currentLine) lines.push(currentLine.trim());\n} else {\n  // : \n  const text = bubble.text;\n  for (let i = 0; i < text.length; i += maxCharsPerLine) {\n    lines.push(text.slice(i, i + maxCharsPerLine));\n  }\n}\n```\n\n**Adjustment:**  `bubbleHeight` \n `const bubbleHeight = 60;` (265) :\n\n```typescript\n// bubbleHeight \nconst lineHeight = 20;\nconst verticalPadding = 20;\nconst bubbleHeight = Math.max(50, lines.length * lineHeight + verticalPadding);\n```\n\n**:** `bubbleHeight` ****\n`generateSpeechBubbleSvg` :\n1. lines\n2. bubbleHeight\n3. bubbleX/targetY\n4. shapePath\n5. textElements\n\n\n---\n\n### Fix #3: SVG\n\n**File:** `backend/src/services/layoutEngine.ts`\n**Line:** 320\n**Problem:** SVG `width`/`height` `sharp.composite()` \n\n**Current Code ():**\n```typescript\nconst svg = `<svg width=\"${panelPos.width + panelPos.x}\" height=\"${panelPos.height + panelPos.y}\" xmlns=\"http://www.w3.org/2000/svg\">\n```\n\n**Fix: addSpeechBubbles **\n\nStep 1: `generateSpeechBubbleSvg` :\n```typescript\nprivate generateSpeechBubbleSvg(\n  bubble: SpeechBubble,\n  panelPos: PanelPosition,\n  targetY: number,\n  layoutWidth: number,   //  \n  layoutHeight: number   //  \n): Buffer {\n```\n\nStep 2: SVG:\n```typescript\nconst svg = `<svg width=\"${layoutWidth}\" height=\"${layoutHeight}\" xmlns=\"http://www.w3.org/2000/svg\">\n```\n\nStep 3: `addSpeechBubbles`  (122):\n```typescript\nconst bubbleSvg = this.generateSpeechBubbleSvg(\n  bubble,\n  panelPos,\n  targetY,\n  layout.width,    //  \n  layout.height    //  \n);\n```\n\n---\n\n### Fix #4: \n\n**File:** `backend/src/routes/manga.ts`\n**Lines:** 664-673\n**Problem:**  `filePath: filePath` : `/app/uploads/xxx/panel.png`\n\n**Current Code ():**\n```typescript\nres.json({\n  message: 'Export successful',\n  projectId,\n  format: exportFormat,\n  downloadUrl: `/uploads/${projectId}/${path.basename(filePath)}`,\n  filePath: filePath,         //  \n  fileSize: result.fileSize,\n});\n```\n\n**Fix:**\n```typescript\nres.json({\n  message: 'Export successful',\n  projectId,\n  format: exportFormat,\n  downloadUrl: `/uploads/${projectId}/${path.basename(filePath)}`,\n  fileSize: result.fileSize,\n});\n```\n\n`filePath` OK `downloadUrl` \n\n---\n\n### Fix #5: exportService.ts  import\n\n**File:** `backend/src/services/exportService.ts`\n**Line:** 16\n\n**Current Code:**\n```typescript\nimport { Readable } from 'stream';\n```\n\n**Fix:** `Readable` \n\n---\n\n### Fix #6:  winston \n\n**File:** `backend/package.json`\n\n**Action:**\n```bash\ncd backend\nnpm uninstall winston\n```\n\n`winston`  import  `console.log` / `console.error` \n\n**Note:** Structured Logging `pino`  `winston` \n\n---\n\n### Fix #8: CORS origin \n\n**File:** `backend/src/config/constants.ts`\n\n**:** CONFIG  `ALLOWED_ORIGINS` :\n```typescript\nexport const CONFIG = {\n  // Server\n  PORT: parseInt(process.env.PORT || '5000', 10),\n  NODE_ENV: process.env.NODE_ENV || 'development',\n  BASE_URL: process.env.BASE_URL || 'http://localhost:5000',\n  ALLOWED_ORIGINS: process.env.ALLOWED_ORIGINS\n    ? process.env.ALLOWED_ORIGINS.split(',')\n    : ['http://localhost:3000'],\n\n  // ... \n```\n\n**File:** `backend/src/app.ts`\n\n**Current Code:**\n```typescript\napp.use(cors({\n  origin: process.env.NODE_ENV === 'production'\n    ? process.env.ALLOWED_ORIGINS?.split(',')\n    : ['http://localhost:3000'],\n}));\n```\n\n**Fix:**\n```typescript\nimport { CONFIG } from './config/constants';\n\n// ... (import)\n\napp.use(cors({\n  origin: CONFIG.NODE_ENV === 'production'\n    ? CONFIG.ALLOWED_ORIGINS\n    : CONFIG.ALLOWED_ORIGINS,\n}));\n```\n\n**:** `app.ts`  `CONFIG`  import  `app.ts`  `config/constants`  import \n\n---\n\n### Verification (Task 1)\n\n:\n\n```bash\ncd backend\n\n# TypeScript \nnpx tsc --noEmit\n\n# \nnpm ls --depth=0\n\n# \nnpm run build\n```\n\n**Expected:** \n\n---\n\n## Task 2:  (Agent B)\n### ImageUploader Bug Fix & Dependency Cleanup\n\n**Time Estimate:** 10-15 minutes\n**Difficulty:** Easy\n**Dependencies:** None\n\n### Objective\nImageUploader `package.json` \n\n### Target Files\n\n```\nfrontend/\n src/\n    components/\n        ImageUploader.tsx    [MODIFY] useEffect (#1)\n package.json                 [MODIFY] @dnd-kit/utilities (#7)\n```\n\n---\n\n### Fix #1: ImageUploader  useEffect \n\n**File:** `frontend/src/components/ImageUploader.tsx`\n**Lines:** 25-29\n**Problem:** `useEffect`  `images`  ** ObjectURL  revoke **\n\n**Current Code ():**\n```typescript\nuseEffect(() => {\n  return () => {\n    images.forEach((image) => URL.revokeObjectURL(image.previewUrl));\n  };\n}, [images]);\n```\n\n**:**\n1. A  `images = [A]`\n2. B  `images`  effect \n3.  `images.forEach(URL.revokeObjectURL)` AURL revoke \n4. : ABURL\n\n**Fix:  revoke  +  revoke **\n\n```typescript\n// URL\nuseEffect(() => {\n  return () => {\n    // URL\n    // eslint-disable-next-line react-hooks/exhaustive-deps -- intentionally run only on unmount\n    images.forEach((image) => URL.revokeObjectURL(image.previewUrl));\n  };\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n}, []);\n```\n\n**:** `removeImage` 73-81 `URL.revokeObjectURL` \n\n**:** `eslint-disable` :\n- React  `react-hooks/exhaustive-deps`  `images` \n- \n- `images`  `useRef`  `removeImage`  revoke  cleanup \n\n**Alternative Fix:**\n`useRef`  `images` :\n\n```typescript\nconst imagesRef = useRef<UploadedImage[]>([]);\n\n// imagesref\nuseEffect(() => {\n  imagesRef.current = images;\n}, [images]);\n\n// URL\nuseEffect(() => {\n  return () => {\n    imagesRef.current.forEach((image) => URL.revokeObjectURL(image.previewUrl));\n  };\n}, []);\n```\n\n**:** Alternative FixuseRef ESLint \n\n---\n\n### Fix #7: @dnd-kit/utilities  package.json \n\n**File:** `frontend/package.json`\n\n**Action:**\n```bash\ncd frontend\nnpm install @dnd-kit/utilities\n```\n\n**Reason:** `PanelGrid.tsx`  `@dnd-kit/utilities`  `CSS` `package.json` `@dnd-kit/sortable`  transitive dependency  break\n\n---\n\n### Verification (Task 2)\n\n:\n\n```bash\ncd frontend\n\n# TypeScript \nnpx tsc --noEmit\n\n# \nnpm run build\n\n# package.json \nnpm ls @dnd-kit/utilities\n```\n\n**Expected:** `dist/` \n\n---\n\n## Task 3:  (Agent C)\n### Build Verification & Integration Test\n\n**Time Estimate:** 10-15 minutes\n**Difficulty:** Easy\n**Dependencies:** Task 1  Task 2 \n\n### Objective\nTask 1, 2 TypeScript \n\n### Verification Checklist\n\n#### Step 1: Backend \n\n```bash\ncd backend\n\n# winston\nnpm install\n\n# TypeScript \nnpx tsc --noEmit\necho \"Backend type check: $?\"\n\n# \nnpm run build\necho \"Backend build: $?\"\n\n# \nls -la dist/services/layoutEngine.js\nls -la dist/services/exportService.js\nls -la dist/routes/manga.js\nls -la dist/app.js\n```\n\n**Expected:**\n-  exit code 0\n- `dist/`  `.js`  `.d.ts` \n- `dist/services/exportService.js`  `Readable`  import \n\n#### Step 2: Frontend \n\n```bash\ncd frontend\n\n# @dnd-kit/utilities\nnpm install\n\n# TypeScript \nnpx tsc --noEmit\necho \"Frontend type check: $?\"\n\n# Vite \nnpm run build\necho \"Frontend build: $?\"\n\n# \nls -la dist/\nls -la dist/assets/\n```\n\n**Expected:**\n-  exit code 0\n- `dist/index.html`  `dist/assets/`  JS/CSS \n\n#### Step 3: \n\n```bash\ncd backend\n\n# 5\ntimeout 5 node dist/index.js 2>&1 || true\n\n# \n# curl -s http://localhost:5000/api/health | head -1\n```\n\n**Expected:**\n- `koma-fill server running on http://localhost:5000` \n- DB initialized \n- \n\n#### Step 4: grep \n\n```bash\n# Fix #4: filePath  export \ngrep -n \"filePath:\" backend/src/routes/manga.ts | grep -v \"downloadUrl\\|layoutPath\\|imageFilePath\\|const filePath\\|file_path\\|\\.filePath\"\n\n# Fix #5: Readable  exportService import\ngrep -n \"Readable\" backend/src/services/exportService.ts\n\n# Fix #6: winston  package.json \ngrep -n \"winston\" backend/package.json\n\n# Fix #7: @dnd-kit/utilities  frontend/package.json \ngrep -n \"dnd-kit/utilities\" frontend/package.json\n\n# Fix #8: CONFIG.ALLOWED_ORIGINS \ngrep -n \"ALLOWED_ORIGINS\" backend/src/config/constants.ts\ngrep -n \"ALLOWED_ORIGINS\\|CONFIG\" backend/src/app.ts\n```\n\n**Expected:**\n- Fix #4: export  `filePath` \n- Fix #5: `Readable`  import \n- Fix #6: `winston` \n- Fix #7: `@dnd-kit/utilities` \n- Fix #8: `ALLOWED_ORIGINS`  constants.ts  app.ts \n\n#### Step 5: LayoutEngine \n\n```bash\n# layoutEngine.ts \ngrep -A 20 \"\" backend/src/services/layoutEngine.ts\n# \ngrep -A 20 \"maxCharsPerLine\" backend/src/services/layoutEngine.ts\n```\n\n**Expected:** `.split(' ')` \n\n---\n\n### Final Report\n\n:\n\n```\n## Fix Verification Report\n\n| # | Fix | Status | Notes |\n|---|-----|--------|-------|\n| 1 | ImageUploader useEffect | / | |\n| 2 |  | / | |\n| 3 | SVG | / | |\n| 4 |  | / | |\n| 5 | Readable import | / | |\n| 6 | winston | / | |\n| 7 | @dnd-kit/utilities | / | |\n| 8 | CORS | / | |\n\nBackend build: /\nFrontend build: /\nServer startup: /\n```\n\n---\n\n## Appendix: \n\n:\n\n1. ****  ARCHITECTURE.md  Bearer \n2. **winston / pino Structured Logging**  \n3. **CONTEXT.md **  \n4. **API_SPEC.md **  \n5. ****  jest \n6. **`generation_log` **  API\n7. ****  \n8. **API**  PreviewPage  `handleDelete` ",
        "tooltip": ": ClaudeCode2: # KAMUI-4D Bug Fix & Improvement Prompts for koma-fill\n## Post-Implementation Review  Multi-Agent Fix Guide\n\n**Version:** 1.1 (Post-Review Fix)\n**Project:** koma-fill - AI-powered manga panel generation system\n**Target:** KAMUI-4D Editor (Multi-AI CLI parallel execution)\n**Author:** Code Review by Claude (2026-02-13)\n\n---\n\n## Overview\n\n **3 + 1 + 4** \n\n### Issue Summary\n\n| # |  |  |  | Task |\n|---|------|--------|------|------|\n| 1 | Bug |  High | ImageUploader  useEffect  | Task 2 |\n| 2 | Bug |  High |  | Task 1 |\n| 3 | Bug |  Medium | SVG | Task 1 |\n| 4 | Security |  High |  | Task 1 |\n| 5 | Cleanup |  Low | exportService.ts  import | Task 1 |\n| 6 | Cleanup |  Low | winston  | Task 1 |\n| 7 | Improvement |  Medium | @dnd-kit/utilities  package.json  | Task 2 |\n| 8 | Improvement |  Medium | CORS origin  | Task 1 |\n\n---\n\n## Execution Strategy\n\n```\nTask 1 (Backend)   Agent A  #2,#3,#4,#5,#6,#8\nTask 2 (Frontend)  Agent B  #1,#7\nTask 3 (Verify)    Agent C   & Task 1,2 \n```\n\n**:** Task 1  Task 2 Task 3 \n\n```\nTimeline:\n  \n   Task 1 (Backend)      20-30 min\n   Agent A              \n  \n                           \n              Task 3 (Verify)   10-15 min\n                            Agent C          \n    \n   Task 2 (Frontend)     10-15 min\n   Agent B              \n  \n```\n\n---\n\n## Task 1:  (Agent A)\n### LayoutEngine / Security / Cleanup\n\n**Time Estimate:** 20-30 minutes\n**Difficulty:** Intermediate\n**Dependencies:** None\n\n### Objective\nCORS\n\n### Target Files\n\n```\nbackend/src/\n services/\n    layoutEngine.ts          [MODIFY]  (#2, #3)\n    exportService.ts         [MODIFY] import (#5)\n routes/\n    manga.ts                 [MODIFY]  (#4)\n app.ts                       [MODIFY] CORS (#8)\n config/\n     constants.ts             [MODIFY] ALLOWED_ORIGINS (#8)\nbackend/package.json             [MODIFY] winston (#6)\n```\n\n---\n\n### Fix #2: \n\n**File:** `backend/src/services/layoutEngine.ts`\n**Lines:** 299-313\n**Problem:** `bubble.text.split(' ')` 1\n\n**Current Code ():**\n```typescript\n// \nconst words = bubble.text.split(' ');\nconst lines: string[] = [];\nlet currentLine = '';\nconst maxCharsPerLine = 30;\n\nfor (const word of words) {\n  if ((currentLine + word).length > maxCharsPerLine) {\n    if (currentLine) lines.push(currentLine.trim());\n    currentLine = word + ' ';\n  } else {\n    currentLine += word + ' ';\n  }\n}\nif (currentLine) lines.push(currentLine.trim());\n```\n\n**Fix: **\n```typescript\n// : \nconst maxCharsPerLine = 15; // \nconst lines: string[] = [];\n\n// \nconst hasSpaces = bubble.text.includes(' ');\n\nif (hasSpaces) {\n  // : \n  const words = bubble.text.split(' ');\n  let currentLine = '';\n  for (const word of words) {\n    if ((currentLine + word).length > maxCharsPerLine) {\n      if (currentLine) lines.push(currentLine.trim());\n      currentLine = word + ' ';\n    } else {\n      currentLine += word + ' ';\n    }\n  }\n  if (currentLine) lines.push(currentLine.trim());\n} else {\n  // : \n  const text = bubble.text;\n  for (let i = 0; i < text.length; i += maxCharsPerLine) {\n    lines.push(text.slice(i, i + maxCharsPerLine));\n  }\n}\n```\n\n**Adjustment:**  `bubbleHeight` \n `const bubbleHeight = 60;` (265) :\n\n```typescript\n// bubbleHeight \nconst lineHeight = 20;\nconst verticalPadding = 20;\nconst bubbleHeight = Math.max(50, lines.length * lineHeight + verticalPadding);\n```\n\n**:** `bubbleHeight` ****\n`generateSpeechBubbleSvg` :\n1. lines\n2. bubbleHeight\n3. bubbleX/targetY\n4. shapePath\n5. textElements\n\n\n---\n\n### Fix #3: SVG\n\n**File:** `backend/src/services/layoutEngine.ts`\n**Line:** 320\n**Problem:** SVG `width`/`height` `sharp.composite()` \n\n**Current Code ():**\n```typescript\nconst svg = `<svg width=\"${panelPos.width + panelPos.x}\" height=\"${panelPos.height + panelPos.y}\" xmlns=\"http://www.w3.org/2000/svg\">\n```\n\n**Fix: addSpeechBubbles **\n\nStep 1: `generateSpeechBubbleSvg` :\n```typescript\nprivate generateSpeechBubbleSvg(\n  bubble: SpeechBubble,\n  panelPos: PanelPosition,\n  targetY: number,\n  layoutWidth: number,   //  \n  layoutHeight: number   //  \n): Buffer {\n```\n\nStep 2: SVG:\n```typescript\nconst svg = `<svg width=\"${layoutWidth}\" height=\"${layoutHeight}\" xmlns=\"http://www.w3.org/2000/svg\">\n```\n\nStep 3: `addSpeechBubbles`  (122):\n```typescript\nconst bubbleSvg = this.generateSpeechBubbleSvg(\n  bubble,\n  panelPos,\n  targetY,\n  layout.width,    //  \n  layout.height    //  \n);\n```\n\n---\n\n### Fix #4: \n\n**File:** `backend/src/routes/manga.ts`\n**Lines:** 664-673\n**Problem:**  `filePath: filePath` : `/app/uploads/xxx/panel.png`\n\n**Current Code ():**\n```typescript\nres.json({\n  message: 'Export successful',\n  projectId,\n  format: exportFormat,\n  downloadUrl: `/uploads/${projectId}/${path.basename(filePath)}`,\n  filePath: filePath,         //  \n  fileSize: result.fileSize,\n});\n```\n\n**Fix:**\n```typescript\nres.json({\n  message: 'Export successful',\n  projectId,\n  format: exportFormat,\n  downloadUrl: `/uploads/${projectId}/${path.basename(filePath)}`,\n  fileSize: result.fileSize,\n});\n```\n\n`filePath` OK `downloadUrl` \n\n---\n\n### Fix #5: exportService.ts  import\n\n**File:** `backend/src/services/exportService.ts`\n**Line:** 16\n\n**Current Code:**\n```typescript\nimport { Readable } from 'stream';\n```\n\n**Fix:** `Readable` \n\n---\n\n### Fix #6:  winston \n\n**File:** `backend/package.json`\n\n**Action:**\n```bash\ncd backend\nnpm uninstall winston\n```\n\n`winston`  import  `console.log` / `console.error` \n\n**Note:** Structured Logging `pino`  `winston` \n\n---\n\n### Fix #8: CORS origin \n\n**File:** `backend/src/config/constants.ts`\n\n**:** CONFIG  `ALLOWED_ORIGINS` :\n```typescript\nexport const CONFIG = {\n  // Server\n  PORT: parseInt(process.env.PORT || '5000', 10),\n  NODE_ENV: process.env.NODE_ENV || 'development',\n  BASE_URL: process.env.BASE_URL || 'http://localhost:5000',\n  ALLOWED_ORIGINS: process.env.ALLOWED_ORIGINS\n    ? process.env.ALLOWED_ORIGINS.split(',')\n    : ['http://localhost:3000'],\n\n  // ... \n```\n\n**File:** `backend/src/app.ts`\n\n**Current Code:**\n```typescript\napp.use(cors({\n  origin: process.env.NODE_ENV === 'production'\n    ? process.env.ALLOWED_ORIGINS?.split(',')\n    : ['http://localhost:3000'],\n}));\n```\n\n**Fix:**\n```typescript\nimport { CONFIG } from './config/constants';\n\n// ... (import)\n\napp.use(cors({\n  origin: CONFIG.NODE_ENV === 'production'\n    ? CONFIG.ALLOWED_ORIGINS\n    : CONFIG.ALLOWED_ORIGINS,\n}));\n```\n\n**:** `app.ts`  `CONFIG`  import  `app.ts`  `config/constants`  import \n\n---\n\n### Verification (Task 1)\n\n:\n\n```bash\ncd backend\n\n# TypeScript \nnpx tsc --noEmit\n\n# \nnpm ls --depth=0\n\n# \nnpm run build\n```\n\n**Expected:** \n\n---\n\n## Task 2:  (Agent B)\n### ImageUploader Bug Fix & Dependency Cleanup\n\n**Time Estimate:** 10-15 minutes\n**Difficulty:** Easy\n**Dependencies:** None\n\n### Objective\nImageUploader `package.json` \n\n### Target Files\n\n```\nfrontend/\n src/\n    components/\n        ImageUploader.tsx    [MODIFY] useEffect (#1)\n package.json                 [MODIFY] @dnd-kit/utilities (#7)\n```\n\n---\n\n### Fix #1: ImageUploader  useEffect \n\n**File:** `frontend/src/components/ImageUploader.tsx`\n**Lines:** 25-29\n**Problem:** `useEffect`  `images`  ** ObjectURL  revoke **\n\n**Current Code ():**\n```typescript\nuseEffect(() => {\n  return () => {\n    images.forEach((image) => URL.revokeObjectURL(image.previewUrl));\n  };\n}, [images]);\n```\n\n**:**\n1. A  `images = [A]`\n2. B  `images`  effect \n3.  `images.forEach(URL.revokeObjectURL)` AURL revoke \n4. : ABURL\n\n**Fix:  revoke  +  revoke **\n\n```typescript\n// URL\nuseEffect(() => {\n  return () => {\n    // URL\n    // eslint-disable-next-line react-hooks/exhaustive-deps -- intentionally run only on unmount\n    images.forEach((image) => URL.revokeObjectURL(image.previewUrl));\n  };\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n}, []);\n```\n\n**:** `removeImage` 73-81 `URL.revokeObjectURL` \n\n**:** `eslint-disable` :\n- React  `react-hooks/exhaustive-deps`  `images` \n- \n- `images`  `useRef`  `removeImage`  revoke  cleanup \n\n**Alternative Fix:**\n`useRef`  `images` :\n\n```typescript\nconst imagesRef = useRef<UploadedImage[]>([]);\n\n// imagesref\nuseEffect(() => {\n  imagesRef.current = images;\n}, [images]);\n\n// URL\nuseEffect(() => {\n  return () => {\n    imagesRef.current.forEach((image) => URL.revokeObjectURL(image.previewUrl));\n  };\n}, []);\n```\n\n**:** Alternative FixuseRef ESLint \n\n---\n\n### Fix #7: @dnd-kit/utilities  package.json \n\n**File:** `frontend/package.json`\n\n**Action:**\n```bash\ncd frontend\nnpm install @dnd-kit/utilities\n```\n\n**Reason:** `PanelGrid.tsx`  `@dnd-kit/utilities`  `CSS` `package.json` `@dnd-kit/sortable`  transitive dependency  break\n\n---\n\n### Verification (Task 2)\n\n:\n\n```bash\ncd frontend\n\n# TypeScript \nnpx tsc --noEmit\n\n# \nnpm run build\n\n# package.json \nnpm ls @dnd-kit/utilities\n```\n\n**Expected:** `dist/` \n\n---\n\n## Task 3:  (Agent C)\n### Build Verification & Integration Test\n\n**Time Estimate:** 10-15 minutes\n**Difficulty:** Easy\n**Dependencies:** Task 1  Task 2 \n\n### Objective\nTask 1, 2 TypeScript \n\n### Verification Checklist\n\n#### Step 1: Backend \n\n```bash\ncd backend\n\n# winston\nnpm install\n\n# TypeScript \nnpx tsc --noEmit\necho \"Backend type check: $?\"\n\n# \nnpm run build\necho \"Backend build: $?\"\n\n# \nls -la dist/services/layoutEngine.js\nls -la dist/services/exportService.js\nls -la dist/routes/manga.js\nls -la dist/app.js\n```\n\n**Expected:**\n-  exit code 0\n- `dist/`  `.js`  `.d.ts` \n- `dist/services/exportService.js`  `Readable`  import \n\n#### Step 2: Frontend \n\n```bash\ncd frontend\n\n# @dnd-kit/utilities\nnpm install\n\n# TypeScript \nnpx tsc --noEmit\necho \"Frontend type check: $?\"\n\n# Vite \nnpm run build\necho \"Frontend build: $?\"\n\n# \nls -la dist/\nls -la dist/assets/\n```\n\n**Expected:**\n-  exit code 0\n- `dist/index.html`  `dist/assets/`  JS/CSS \n\n#### Step 3: \n\n```bash\ncd backend\n\n# 5\ntimeout 5 node dist/index.js 2>&1 || true\n\n# \n# curl -s http://localhost:5000/api/health | head -1\n```\n\n**Expected:**\n- `koma-fill server running on http://localhost:5000` \n- DB initialized \n- \n\n#### Step 4: grep \n\n```bash\n# Fix #4: filePath  export \ngrep -n \"filePath:\" backend/src/routes/manga.ts | grep -v \"downloadUrl\\|layoutPath\\|imageFilePath\\|const filePath\\|file_path\\|\\.filePath\"\n\n# Fix #5: Readable  exportService import\ngrep -n \"Readable\" backend/src/services/exportService.ts\n\n# Fix #6: winston  package.json \ngrep -n \"winston\" backend/package.json\n\n# Fix #7: @dnd-kit/utilities  frontend/package.json \ngrep -n \"dnd-kit/utilities\" frontend/package.json\n\n# Fix #8: CONFIG.ALLOWED_ORIGINS \ngrep -n \"ALLOWED_ORIGINS\" backend/src/config/constants.ts\ngrep -n \"ALLOWED_ORIGINS\\|CONFIG\" backend/src/app.ts\n```\n\n**Expected:**\n- Fix #4: export  `filePath` \n- Fix #5: `Readable`  import \n- Fix #6: `winston` \n- Fix #7: `@dnd-kit/utilities` \n- Fix #8: `ALLOWED_ORIGINS`  constants.ts  app.ts \n\n#### Step 5: LayoutEngine \n\n```bash\n# layoutEngine.ts \ngrep -A 20 \"\" backend/src/services/layoutEngine.ts\n# \ngrep -A 20 \"maxCharsPerLine\" backend/src/services/layoutEngine.ts\n```\n\n**Expected:** `.split(' ')` \n\n---\n\n### Final Report\n\n:\n\n```\n## Fix Verification Report\n\n| # | Fix | Status | Notes |\n|---|-----|--------|-------|\n| 1 | ImageUploader useEffect | / | |\n| 2 |  | / | |\n| 3 | SVG | / | |\n| 4 |  | / | |\n| 5 | Readable import | / | |\n| 6 | winston | / | |\n| 7 | @dnd-kit/utilities | / | |\n| 8 | CORS | / | |\n\nBackend build: /\nFrontend build: /\nServer startup: /\n```\n\n---\n\n## Appendix: \n\n:\n\n1. ****  ARCHITECTURE.md  Bearer \n2. **winston / pino Structured Logging**  \n3. **CONTEXT.md **  \n4. **API_SPEC.md **  \n5. ****  jest \n6. **`generation_log` **  API\n7. ****  \n8. **API**  PreviewPage  `handleDelete` \n: \nID: task-1770918401534-118872\nBranch: task/task-1770918401534-118872\nWorktree: Users/yuyafujita/Projects/koma-fill/.worktrees/task-1770918401534-118872",
        "branchColor": "#e8e84f",
        "index": 15
      },
      {
        "type": "anchor",
        "label": "[] ClaudeCode3: # KAMUI-4D Bug Fix ",
        "branch": "task/task-1770918401706-38620f",
        "worktreePath": "/Users/yuyafujita/Projects/koma-fill/.worktrees/task-1770918401706-38620f",
        "parentCommitHash": "21c659994cdba8f6164acd549bc5b77b6f2b8504",
        "lane": 7,
        "isMerged": false,
        "mergeCommitHash": null,
        "statusChildren": [
          {
            "type": "unstaged",
            "label": " [task/task-1770918401706-38620f] (8)",
            "files": [
              "backend/src/app.ts",
              "backend/src/config/constants.ts",
              "backend/src/routes/manga.ts",
              "backend/src/services/exportService.ts",
              "backend/src/services/layoutEngine.ts",
              "frontend/package.json",
              "frontend/src/components/ImageUploader.tsx",
              "package-lock.json"
            ],
            "branch": "task/task-1770918401706-38620f",
            "targetCommitHash": "21c659994cdba8f6164acd549bc5b77b6f2b8504",
            "worktreePath": "/Users/yuyafujita/Projects/koma-fill/.worktrees/task-1770918401706-38620f",
            "timestamp": 1770921960641,
            "sortOrder": 0,
            "lane": 7,
            "branchColor": "#b84fe8",
            "index": 9
          },
          {
            "type": "staged",
            "label": " [task/task-1770918401706-38620f] (1)",
            "files": [
              "ackend/package.json"
            ],
            "branch": "task/task-1770918401706-38620f",
            "targetCommitHash": "21c659994cdba8f6164acd549bc5b77b6f2b8504",
            "worktreePath": "/Users/yuyafujita/Projects/koma-fill/.worktrees/task-1770918401706-38620f",
            "timestamp": 1770921960641,
            "sortOrder": 1,
            "lane": 7,
            "branchColor": "#b84fe8",
            "index": 10
          }
        ],
        "isDefaultWorktree": false,
        "renderMode": "node",
        "shouldHide": false,
        "tagLabel": "task/task-1770918401706-38620f",
        "taskId": "task-1770918401706-38620f",
        "taskStatus": "working",
        "taskStatusLabel": "",
        "taskName": "ClaudeCode3: # KAMUI-4D Bug Fix & Improvement Prompts for koma-fill\n## Post-Implementation Review  Multi-Agent Fix Guide\n\n**Version:** 1.1 (Post-Review Fix)\n**Project:** koma-fill - AI-powered manga panel generation system\n**Target:** KAMUI-4D Editor (Multi-AI CLI parallel execution)\n**Author:** Code Review by Claude (2026-02-13)\n\n---\n\n## Overview\n\n **3 + 1 + 4** \n\n### Issue Summary\n\n| # |  |  |  | Task |\n|---|------|--------|------|------|\n| 1 | Bug |  High | ImageUploader  useEffect  | Task 2 |\n| 2 | Bug |  High |  | Task 1 |\n| 3 | Bug |  Medium | SVG | Task 1 |\n| 4 | Security |  High |  | Task 1 |\n| 5 | Cleanup |  Low | exportService.ts  import | Task 1 |\n| 6 | Cleanup |  Low | winston  | Task 1 |\n| 7 | Improvement |  Medium | @dnd-kit/utilities  package.json  | Task 2 |\n| 8 | Improvement |  Medium | CORS origin  | Task 1 |\n\n---\n\n## Execution Strategy\n\n```\nTask 1 (Backend)   Agent A  #2,#3,#4,#5,#6,#8\nTask 2 (Frontend)  Agent B  #1,#7\nTask 3 (Verify)    Agent C   & Task 1,2 \n```\n\n**:** Task 1  Task 2 Task 3 \n\n```\nTimeline:\n  \n   Task 1 (Backend)      20-30 min\n   Agent A              \n  \n                           \n              Task 3 (Verify)   10-15 min\n                            Agent C          \n    \n   Task 2 (Frontend)     10-15 min\n   Agent B              \n  \n```\n\n---\n\n## Task 1:  (Agent A)\n### LayoutEngine / Security / Cleanup\n\n**Time Estimate:** 20-30 minutes\n**Difficulty:** Intermediate\n**Dependencies:** None\n\n### Objective\nCORS\n\n### Target Files\n\n```\nbackend/src/\n services/\n    layoutEngine.ts          [MODIFY]  (#2, #3)\n    exportService.ts         [MODIFY] import (#5)\n routes/\n    manga.ts                 [MODIFY]  (#4)\n app.ts                       [MODIFY] CORS (#8)\n config/\n     constants.ts             [MODIFY] ALLOWED_ORIGINS (#8)\nbackend/package.json             [MODIFY] winston (#6)\n```\n\n---\n\n### Fix #2: \n\n**File:** `backend/src/services/layoutEngine.ts`\n**Lines:** 299-313\n**Problem:** `bubble.text.split(' ')` 1\n\n**Current Code ():**\n```typescript\n// \nconst words = bubble.text.split(' ');\nconst lines: string[] = [];\nlet currentLine = '';\nconst maxCharsPerLine = 30;\n\nfor (const word of words) {\n  if ((currentLine + word).length > maxCharsPerLine) {\n    if (currentLine) lines.push(currentLine.trim());\n    currentLine = word + ' ';\n  } else {\n    currentLine += word + ' ';\n  }\n}\nif (currentLine) lines.push(currentLine.trim());\n```\n\n**Fix: **\n```typescript\n// : \nconst maxCharsPerLine = 15; // \nconst lines: string[] = [];\n\n// \nconst hasSpaces = bubble.text.includes(' ');\n\nif (hasSpaces) {\n  // : \n  const words = bubble.text.split(' ');\n  let currentLine = '';\n  for (const word of words) {\n    if ((currentLine + word).length > maxCharsPerLine) {\n      if (currentLine) lines.push(currentLine.trim());\n      currentLine = word + ' ';\n    } else {\n      currentLine += word + ' ';\n    }\n  }\n  if (currentLine) lines.push(currentLine.trim());\n} else {\n  // : \n  const text = bubble.text;\n  for (let i = 0; i < text.length; i += maxCharsPerLine) {\n    lines.push(text.slice(i, i + maxCharsPerLine));\n  }\n}\n```\n\n**Adjustment:**  `bubbleHeight` \n `const bubbleHeight = 60;` (265) :\n\n```typescript\n// bubbleHeight \nconst lineHeight = 20;\nconst verticalPadding = 20;\nconst bubbleHeight = Math.max(50, lines.length * lineHeight + verticalPadding);\n```\n\n**:** `bubbleHeight` ****\n`generateSpeechBubbleSvg` :\n1. lines\n2. bubbleHeight\n3. bubbleX/targetY\n4. shapePath\n5. textElements\n\n\n---\n\n### Fix #3: SVG\n\n**File:** `backend/src/services/layoutEngine.ts`\n**Line:** 320\n**Problem:** SVG `width`/`height` `sharp.composite()` \n\n**Current Code ():**\n```typescript\nconst svg = `<svg width=\"${panelPos.width + panelPos.x}\" height=\"${panelPos.height + panelPos.y}\" xmlns=\"http://www.w3.org/2000/svg\">\n```\n\n**Fix: addSpeechBubbles **\n\nStep 1: `generateSpeechBubbleSvg` :\n```typescript\nprivate generateSpeechBubbleSvg(\n  bubble: SpeechBubble,\n  panelPos: PanelPosition,\n  targetY: number,\n  layoutWidth: number,   //  \n  layoutHeight: number   //  \n): Buffer {\n```\n\nStep 2: SVG:\n```typescript\nconst svg = `<svg width=\"${layoutWidth}\" height=\"${layoutHeight}\" xmlns=\"http://www.w3.org/2000/svg\">\n```\n\nStep 3: `addSpeechBubbles`  (122):\n```typescript\nconst bubbleSvg = this.generateSpeechBubbleSvg(\n  bubble,\n  panelPos,\n  targetY,\n  layout.width,    //  \n  layout.height    //  \n);\n```\n\n---\n\n### Fix #4: \n\n**File:** `backend/src/routes/manga.ts`\n**Lines:** 664-673\n**Problem:**  `filePath: filePath` : `/app/uploads/xxx/panel.png`\n\n**Current Code ():**\n```typescript\nres.json({\n  message: 'Export successful',\n  projectId,\n  format: exportFormat,\n  downloadUrl: `/uploads/${projectId}/${path.basename(filePath)}`,\n  filePath: filePath,         //  \n  fileSize: result.fileSize,\n});\n```\n\n**Fix:**\n```typescript\nres.json({\n  message: 'Export successful',\n  projectId,\n  format: exportFormat,\n  downloadUrl: `/uploads/${projectId}/${path.basename(filePath)}`,\n  fileSize: result.fileSize,\n});\n```\n\n`filePath` OK `downloadUrl` \n\n---\n\n### Fix #5: exportService.ts  import\n\n**File:** `backend/src/services/exportService.ts`\n**Line:** 16\n\n**Current Code:**\n```typescript\nimport { Readable } from 'stream';\n```\n\n**Fix:** `Readable` \n\n---\n\n### Fix #6:  winston \n\n**File:** `backend/package.json`\n\n**Action:**\n```bash\ncd backend\nnpm uninstall winston\n```\n\n`winston`  import  `console.log` / `console.error` \n\n**Note:** Structured Logging `pino`  `winston` \n\n---\n\n### Fix #8: CORS origin \n\n**File:** `backend/src/config/constants.ts`\n\n**:** CONFIG  `ALLOWED_ORIGINS` :\n```typescript\nexport const CONFIG = {\n  // Server\n  PORT: parseInt(process.env.PORT || '5000', 10),\n  NODE_ENV: process.env.NODE_ENV || 'development',\n  BASE_URL: process.env.BASE_URL || 'http://localhost:5000',\n  ALLOWED_ORIGINS: process.env.ALLOWED_ORIGINS\n    ? process.env.ALLOWED_ORIGINS.split(',')\n    : ['http://localhost:3000'],\n\n  // ... \n```\n\n**File:** `backend/src/app.ts`\n\n**Current Code:**\n```typescript\napp.use(cors({\n  origin: process.env.NODE_ENV === 'production'\n    ? process.env.ALLOWED_ORIGINS?.split(',')\n    : ['http://localhost:3000'],\n}));\n```\n\n**Fix:**\n```typescript\nimport { CONFIG } from './config/constants';\n\n// ... (import)\n\napp.use(cors({\n  origin: CONFIG.NODE_ENV === 'production'\n    ? CONFIG.ALLOWED_ORIGINS\n    : CONFIG.ALLOWED_ORIGINS,\n}));\n```\n\n**:** `app.ts`  `CONFIG`  import  `app.ts`  `config/constants`  import \n\n---\n\n### Verification (Task 1)\n\n:\n\n```bash\ncd backend\n\n# TypeScript \nnpx tsc --noEmit\n\n# \nnpm ls --depth=0\n\n# \nnpm run build\n```\n\n**Expected:** \n\n---\n\n## Task 2:  (Agent B)\n### ImageUploader Bug Fix & Dependency Cleanup\n\n**Time Estimate:** 10-15 minutes\n**Difficulty:** Easy\n**Dependencies:** None\n\n### Objective\nImageUploader `package.json` \n\n### Target Files\n\n```\nfrontend/\n src/\n    components/\n        ImageUploader.tsx    [MODIFY] useEffect (#1)\n package.json                 [MODIFY] @dnd-kit/utilities (#7)\n```\n\n---\n\n### Fix #1: ImageUploader  useEffect \n\n**File:** `frontend/src/components/ImageUploader.tsx`\n**Lines:** 25-29\n**Problem:** `useEffect`  `images`  ** ObjectURL  revoke **\n\n**Current Code ():**\n```typescript\nuseEffect(() => {\n  return () => {\n    images.forEach((image) => URL.revokeObjectURL(image.previewUrl));\n  };\n}, [images]);\n```\n\n**:**\n1. A  `images = [A]`\n2. B  `images`  effect \n3.  `images.forEach(URL.revokeObjectURL)` AURL revoke \n4. : ABURL\n\n**Fix:  revoke  +  revoke **\n\n```typescript\n// URL\nuseEffect(() => {\n  return () => {\n    // URL\n    // eslint-disable-next-line react-hooks/exhaustive-deps -- intentionally run only on unmount\n    images.forEach((image) => URL.revokeObjectURL(image.previewUrl));\n  };\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n}, []);\n```\n\n**:** `removeImage` 73-81 `URL.revokeObjectURL` \n\n**:** `eslint-disable` :\n- React  `react-hooks/exhaustive-deps`  `images` \n- \n- `images`  `useRef`  `removeImage`  revoke  cleanup \n\n**Alternative Fix:**\n`useRef`  `images` :\n\n```typescript\nconst imagesRef = useRef<UploadedImage[]>([]);\n\n// imagesref\nuseEffect(() => {\n  imagesRef.current = images;\n}, [images]);\n\n// URL\nuseEffect(() => {\n  return () => {\n    imagesRef.current.forEach((image) => URL.revokeObjectURL(image.previewUrl));\n  };\n}, []);\n```\n\n**:** Alternative FixuseRef ESLint \n\n---\n\n### Fix #7: @dnd-kit/utilities  package.json \n\n**File:** `frontend/package.json`\n\n**Action:**\n```bash\ncd frontend\nnpm install @dnd-kit/utilities\n```\n\n**Reason:** `PanelGrid.tsx`  `@dnd-kit/utilities`  `CSS` `package.json` `@dnd-kit/sortable`  transitive dependency  break\n\n---\n\n### Verification (Task 2)\n\n:\n\n```bash\ncd frontend\n\n# TypeScript \nnpx tsc --noEmit\n\n# \nnpm run build\n\n# package.json \nnpm ls @dnd-kit/utilities\n```\n\n**Expected:** `dist/` \n\n---\n\n## Task 3:  (Agent C)\n### Build Verification & Integration Test\n\n**Time Estimate:** 10-15 minutes\n**Difficulty:** Easy\n**Dependencies:** Task 1  Task 2 \n\n### Objective\nTask 1, 2 TypeScript \n\n### Verification Checklist\n\n#### Step 1: Backend \n\n```bash\ncd backend\n\n# winston\nnpm install\n\n# TypeScript \nnpx tsc --noEmit\necho \"Backend type check: $?\"\n\n# \nnpm run build\necho \"Backend build: $?\"\n\n# \nls -la dist/services/layoutEngine.js\nls -la dist/services/exportService.js\nls -la dist/routes/manga.js\nls -la dist/app.js\n```\n\n**Expected:**\n-  exit code 0\n- `dist/`  `.js`  `.d.ts` \n- `dist/services/exportService.js`  `Readable`  import \n\n#### Step 2: Frontend \n\n```bash\ncd frontend\n\n# @dnd-kit/utilities\nnpm install\n\n# TypeScript \nnpx tsc --noEmit\necho \"Frontend type check: $?\"\n\n# Vite \nnpm run build\necho \"Frontend build: $?\"\n\n# \nls -la dist/\nls -la dist/assets/\n```\n\n**Expected:**\n-  exit code 0\n- `dist/index.html`  `dist/assets/`  JS/CSS \n\n#### Step 3: \n\n```bash\ncd backend\n\n# 5\ntimeout 5 node dist/index.js 2>&1 || true\n\n# \n# curl -s http://localhost:5000/api/health | head -1\n```\n\n**Expected:**\n- `koma-fill server running on http://localhost:5000` \n- DB initialized \n- \n\n#### Step 4: grep \n\n```bash\n# Fix #4: filePath  export \ngrep -n \"filePath:\" backend/src/routes/manga.ts | grep -v \"downloadUrl\\|layoutPath\\|imageFilePath\\|const filePath\\|file_path\\|\\.filePath\"\n\n# Fix #5: Readable  exportService import\ngrep -n \"Readable\" backend/src/services/exportService.ts\n\n# Fix #6: winston  package.json \ngrep -n \"winston\" backend/package.json\n\n# Fix #7: @dnd-kit/utilities  frontend/package.json \ngrep -n \"dnd-kit/utilities\" frontend/package.json\n\n# Fix #8: CONFIG.ALLOWED_ORIGINS \ngrep -n \"ALLOWED_ORIGINS\" backend/src/config/constants.ts\ngrep -n \"ALLOWED_ORIGINS\\|CONFIG\" backend/src/app.ts\n```\n\n**Expected:**\n- Fix #4: export  `filePath` \n- Fix #5: `Readable`  import \n- Fix #6: `winston` \n- Fix #7: `@dnd-kit/utilities` \n- Fix #8: `ALLOWED_ORIGINS`  constants.ts  app.ts \n\n#### Step 5: LayoutEngine \n\n```bash\n# layoutEngine.ts \ngrep -A 20 \"\" backend/src/services/layoutEngine.ts\n# \ngrep -A 20 \"maxCharsPerLine\" backend/src/services/layoutEngine.ts\n```\n\n**Expected:** `.split(' ')` \n\n---\n\n### Final Report\n\n:\n\n```\n## Fix Verification Report\n\n| # | Fix | Status | Notes |\n|---|-----|--------|-------|\n| 1 | ImageUploader useEffect | / | |\n| 2 |  | / | |\n| 3 | SVG | / | |\n| 4 |  | / | |\n| 5 | Readable import | / | |\n| 6 | winston | / | |\n| 7 | @dnd-kit/utilities | / | |\n| 8 | CORS | / | |\n\nBackend build: /\nFrontend build: /\nServer startup: /\n```\n\n---\n\n## Appendix: \n\n:\n\n1. ****  ARCHITECTURE.md  Bearer \n2. **winston / pino Structured Logging**  \n3. **CONTEXT.md **  \n4. **API_SPEC.md **  \n5. ****  jest \n6. **`generation_log` **  API\n7. ****  \n8. **API**  PreviewPage  `handleDelete` ",
        "tooltip": ": ClaudeCode3: # KAMUI-4D Bug Fix & Improvement Prompts for koma-fill\n## Post-Implementation Review  Multi-Agent Fix Guide\n\n**Version:** 1.1 (Post-Review Fix)\n**Project:** koma-fill - AI-powered manga panel generation system\n**Target:** KAMUI-4D Editor (Multi-AI CLI parallel execution)\n**Author:** Code Review by Claude (2026-02-13)\n\n---\n\n## Overview\n\n **3 + 1 + 4** \n\n### Issue Summary\n\n| # |  |  |  | Task |\n|---|------|--------|------|------|\n| 1 | Bug |  High | ImageUploader  useEffect  | Task 2 |\n| 2 | Bug |  High |  | Task 1 |\n| 3 | Bug |  Medium | SVG | Task 1 |\n| 4 | Security |  High |  | Task 1 |\n| 5 | Cleanup |  Low | exportService.ts  import | Task 1 |\n| 6 | Cleanup |  Low | winston  | Task 1 |\n| 7 | Improvement |  Medium | @dnd-kit/utilities  package.json  | Task 2 |\n| 8 | Improvement |  Medium | CORS origin  | Task 1 |\n\n---\n\n## Execution Strategy\n\n```\nTask 1 (Backend)   Agent A  #2,#3,#4,#5,#6,#8\nTask 2 (Frontend)  Agent B  #1,#7\nTask 3 (Verify)    Agent C   & Task 1,2 \n```\n\n**:** Task 1  Task 2 Task 3 \n\n```\nTimeline:\n  \n   Task 1 (Backend)      20-30 min\n   Agent A              \n  \n                           \n              Task 3 (Verify)   10-15 min\n                            Agent C          \n    \n   Task 2 (Frontend)     10-15 min\n   Agent B              \n  \n```\n\n---\n\n## Task 1:  (Agent A)\n### LayoutEngine / Security / Cleanup\n\n**Time Estimate:** 20-30 minutes\n**Difficulty:** Intermediate\n**Dependencies:** None\n\n### Objective\nCORS\n\n### Target Files\n\n```\nbackend/src/\n services/\n    layoutEngine.ts          [MODIFY]  (#2, #3)\n    exportService.ts         [MODIFY] import (#5)\n routes/\n    manga.ts                 [MODIFY]  (#4)\n app.ts                       [MODIFY] CORS (#8)\n config/\n     constants.ts             [MODIFY] ALLOWED_ORIGINS (#8)\nbackend/package.json             [MODIFY] winston (#6)\n```\n\n---\n\n### Fix #2: \n\n**File:** `backend/src/services/layoutEngine.ts`\n**Lines:** 299-313\n**Problem:** `bubble.text.split(' ')` 1\n\n**Current Code ():**\n```typescript\n// \nconst words = bubble.text.split(' ');\nconst lines: string[] = [];\nlet currentLine = '';\nconst maxCharsPerLine = 30;\n\nfor (const word of words) {\n  if ((currentLine + word).length > maxCharsPerLine) {\n    if (currentLine) lines.push(currentLine.trim());\n    currentLine = word + ' ';\n  } else {\n    currentLine += word + ' ';\n  }\n}\nif (currentLine) lines.push(currentLine.trim());\n```\n\n**Fix: **\n```typescript\n// : \nconst maxCharsPerLine = 15; // \nconst lines: string[] = [];\n\n// \nconst hasSpaces = bubble.text.includes(' ');\n\nif (hasSpaces) {\n  // : \n  const words = bubble.text.split(' ');\n  let currentLine = '';\n  for (const word of words) {\n    if ((currentLine + word).length > maxCharsPerLine) {\n      if (currentLine) lines.push(currentLine.trim());\n      currentLine = word + ' ';\n    } else {\n      currentLine += word + ' ';\n    }\n  }\n  if (currentLine) lines.push(currentLine.trim());\n} else {\n  // : \n  const text = bubble.text;\n  for (let i = 0; i < text.length; i += maxCharsPerLine) {\n    lines.push(text.slice(i, i + maxCharsPerLine));\n  }\n}\n```\n\n**Adjustment:**  `bubbleHeight` \n `const bubbleHeight = 60;` (265) :\n\n```typescript\n// bubbleHeight \nconst lineHeight = 20;\nconst verticalPadding = 20;\nconst bubbleHeight = Math.max(50, lines.length * lineHeight + verticalPadding);\n```\n\n**:** `bubbleHeight` ****\n`generateSpeechBubbleSvg` :\n1. lines\n2. bubbleHeight\n3. bubbleX/targetY\n4. shapePath\n5. textElements\n\n\n---\n\n### Fix #3: SVG\n\n**File:** `backend/src/services/layoutEngine.ts`\n**Line:** 320\n**Problem:** SVG `width`/`height` `sharp.composite()` \n\n**Current Code ():**\n```typescript\nconst svg = `<svg width=\"${panelPos.width + panelPos.x}\" height=\"${panelPos.height + panelPos.y}\" xmlns=\"http://www.w3.org/2000/svg\">\n```\n\n**Fix: addSpeechBubbles **\n\nStep 1: `generateSpeechBubbleSvg` :\n```typescript\nprivate generateSpeechBubbleSvg(\n  bubble: SpeechBubble,\n  panelPos: PanelPosition,\n  targetY: number,\n  layoutWidth: number,   //  \n  layoutHeight: number   //  \n): Buffer {\n```\n\nStep 2: SVG:\n```typescript\nconst svg = `<svg width=\"${layoutWidth}\" height=\"${layoutHeight}\" xmlns=\"http://www.w3.org/2000/svg\">\n```\n\nStep 3: `addSpeechBubbles`  (122):\n```typescript\nconst bubbleSvg = this.generateSpeechBubbleSvg(\n  bubble,\n  panelPos,\n  targetY,\n  layout.width,    //  \n  layout.height    //  \n);\n```\n\n---\n\n### Fix #4: \n\n**File:** `backend/src/routes/manga.ts`\n**Lines:** 664-673\n**Problem:**  `filePath: filePath` : `/app/uploads/xxx/panel.png`\n\n**Current Code ():**\n```typescript\nres.json({\n  message: 'Export successful',\n  projectId,\n  format: exportFormat,\n  downloadUrl: `/uploads/${projectId}/${path.basename(filePath)}`,\n  filePath: filePath,         //  \n  fileSize: result.fileSize,\n});\n```\n\n**Fix:**\n```typescript\nres.json({\n  message: 'Export successful',\n  projectId,\n  format: exportFormat,\n  downloadUrl: `/uploads/${projectId}/${path.basename(filePath)}`,\n  fileSize: result.fileSize,\n});\n```\n\n`filePath` OK `downloadUrl` \n\n---\n\n### Fix #5: exportService.ts  import\n\n**File:** `backend/src/services/exportService.ts`\n**Line:** 16\n\n**Current Code:**\n```typescript\nimport { Readable } from 'stream';\n```\n\n**Fix:** `Readable` \n\n---\n\n### Fix #6:  winston \n\n**File:** `backend/package.json`\n\n**Action:**\n```bash\ncd backend\nnpm uninstall winston\n```\n\n`winston`  import  `console.log` / `console.error` \n\n**Note:** Structured Logging `pino`  `winston` \n\n---\n\n### Fix #8: CORS origin \n\n**File:** `backend/src/config/constants.ts`\n\n**:** CONFIG  `ALLOWED_ORIGINS` :\n```typescript\nexport const CONFIG = {\n  // Server\n  PORT: parseInt(process.env.PORT || '5000', 10),\n  NODE_ENV: process.env.NODE_ENV || 'development',\n  BASE_URL: process.env.BASE_URL || 'http://localhost:5000',\n  ALLOWED_ORIGINS: process.env.ALLOWED_ORIGINS\n    ? process.env.ALLOWED_ORIGINS.split(',')\n    : ['http://localhost:3000'],\n\n  // ... \n```\n\n**File:** `backend/src/app.ts`\n\n**Current Code:**\n```typescript\napp.use(cors({\n  origin: process.env.NODE_ENV === 'production'\n    ? process.env.ALLOWED_ORIGINS?.split(',')\n    : ['http://localhost:3000'],\n}));\n```\n\n**Fix:**\n```typescript\nimport { CONFIG } from './config/constants';\n\n// ... (import)\n\napp.use(cors({\n  origin: CONFIG.NODE_ENV === 'production'\n    ? CONFIG.ALLOWED_ORIGINS\n    : CONFIG.ALLOWED_ORIGINS,\n}));\n```\n\n**:** `app.ts`  `CONFIG`  import  `app.ts`  `config/constants`  import \n\n---\n\n### Verification (Task 1)\n\n:\n\n```bash\ncd backend\n\n# TypeScript \nnpx tsc --noEmit\n\n# \nnpm ls --depth=0\n\n# \nnpm run build\n```\n\n**Expected:** \n\n---\n\n## Task 2:  (Agent B)\n### ImageUploader Bug Fix & Dependency Cleanup\n\n**Time Estimate:** 10-15 minutes\n**Difficulty:** Easy\n**Dependencies:** None\n\n### Objective\nImageUploader `package.json` \n\n### Target Files\n\n```\nfrontend/\n src/\n    components/\n        ImageUploader.tsx    [MODIFY] useEffect (#1)\n package.json                 [MODIFY] @dnd-kit/utilities (#7)\n```\n\n---\n\n### Fix #1: ImageUploader  useEffect \n\n**File:** `frontend/src/components/ImageUploader.tsx`\n**Lines:** 25-29\n**Problem:** `useEffect`  `images`  ** ObjectURL  revoke **\n\n**Current Code ():**\n```typescript\nuseEffect(() => {\n  return () => {\n    images.forEach((image) => URL.revokeObjectURL(image.previewUrl));\n  };\n}, [images]);\n```\n\n**:**\n1. A  `images = [A]`\n2. B  `images`  effect \n3.  `images.forEach(URL.revokeObjectURL)` AURL revoke \n4. : ABURL\n\n**Fix:  revoke  +  revoke **\n\n```typescript\n// URL\nuseEffect(() => {\n  return () => {\n    // URL\n    // eslint-disable-next-line react-hooks/exhaustive-deps -- intentionally run only on unmount\n    images.forEach((image) => URL.revokeObjectURL(image.previewUrl));\n  };\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n}, []);\n```\n\n**:** `removeImage` 73-81 `URL.revokeObjectURL` \n\n**:** `eslint-disable` :\n- React  `react-hooks/exhaustive-deps`  `images` \n- \n- `images`  `useRef`  `removeImage`  revoke  cleanup \n\n**Alternative Fix:**\n`useRef`  `images` :\n\n```typescript\nconst imagesRef = useRef<UploadedImage[]>([]);\n\n// imagesref\nuseEffect(() => {\n  imagesRef.current = images;\n}, [images]);\n\n// URL\nuseEffect(() => {\n  return () => {\n    imagesRef.current.forEach((image) => URL.revokeObjectURL(image.previewUrl));\n  };\n}, []);\n```\n\n**:** Alternative FixuseRef ESLint \n\n---\n\n### Fix #7: @dnd-kit/utilities  package.json \n\n**File:** `frontend/package.json`\n\n**Action:**\n```bash\ncd frontend\nnpm install @dnd-kit/utilities\n```\n\n**Reason:** `PanelGrid.tsx`  `@dnd-kit/utilities`  `CSS` `package.json` `@dnd-kit/sortable`  transitive dependency  break\n\n---\n\n### Verification (Task 2)\n\n:\n\n```bash\ncd frontend\n\n# TypeScript \nnpx tsc --noEmit\n\n# \nnpm run build\n\n# package.json \nnpm ls @dnd-kit/utilities\n```\n\n**Expected:** `dist/` \n\n---\n\n## Task 3:  (Agent C)\n### Build Verification & Integration Test\n\n**Time Estimate:** 10-15 minutes\n**Difficulty:** Easy\n**Dependencies:** Task 1  Task 2 \n\n### Objective\nTask 1, 2 TypeScript \n\n### Verification Checklist\n\n#### Step 1: Backend \n\n```bash\ncd backend\n\n# winston\nnpm install\n\n# TypeScript \nnpx tsc --noEmit\necho \"Backend type check: $?\"\n\n# \nnpm run build\necho \"Backend build: $?\"\n\n# \nls -la dist/services/layoutEngine.js\nls -la dist/services/exportService.js\nls -la dist/routes/manga.js\nls -la dist/app.js\n```\n\n**Expected:**\n-  exit code 0\n- `dist/`  `.js`  `.d.ts` \n- `dist/services/exportService.js`  `Readable`  import \n\n#### Step 2: Frontend \n\n```bash\ncd frontend\n\n# @dnd-kit/utilities\nnpm install\n\n# TypeScript \nnpx tsc --noEmit\necho \"Frontend type check: $?\"\n\n# Vite \nnpm run build\necho \"Frontend build: $?\"\n\n# \nls -la dist/\nls -la dist/assets/\n```\n\n**Expected:**\n-  exit code 0\n- `dist/index.html`  `dist/assets/`  JS/CSS \n\n#### Step 3: \n\n```bash\ncd backend\n\n# 5\ntimeout 5 node dist/index.js 2>&1 || true\n\n# \n# curl -s http://localhost:5000/api/health | head -1\n```\n\n**Expected:**\n- `koma-fill server running on http://localhost:5000` \n- DB initialized \n- \n\n#### Step 4: grep \n\n```bash\n# Fix #4: filePath  export \ngrep -n \"filePath:\" backend/src/routes/manga.ts | grep -v \"downloadUrl\\|layoutPath\\|imageFilePath\\|const filePath\\|file_path\\|\\.filePath\"\n\n# Fix #5: Readable  exportService import\ngrep -n \"Readable\" backend/src/services/exportService.ts\n\n# Fix #6: winston  package.json \ngrep -n \"winston\" backend/package.json\n\n# Fix #7: @dnd-kit/utilities  frontend/package.json \ngrep -n \"dnd-kit/utilities\" frontend/package.json\n\n# Fix #8: CONFIG.ALLOWED_ORIGINS \ngrep -n \"ALLOWED_ORIGINS\" backend/src/config/constants.ts\ngrep -n \"ALLOWED_ORIGINS\\|CONFIG\" backend/src/app.ts\n```\n\n**Expected:**\n- Fix #4: export  `filePath` \n- Fix #5: `Readable`  import \n- Fix #6: `winston` \n- Fix #7: `@dnd-kit/utilities` \n- Fix #8: `ALLOWED_ORIGINS`  constants.ts  app.ts \n\n#### Step 5: LayoutEngine \n\n```bash\n# layoutEngine.ts \ngrep -A 20 \"\" backend/src/services/layoutEngine.ts\n# \ngrep -A 20 \"maxCharsPerLine\" backend/src/services/layoutEngine.ts\n```\n\n**Expected:** `.split(' ')` \n\n---\n\n### Final Report\n\n:\n\n```\n## Fix Verification Report\n\n| # | Fix | Status | Notes |\n|---|-----|--------|-------|\n| 1 | ImageUploader useEffect | / | |\n| 2 |  | / | |\n| 3 | SVG | / | |\n| 4 |  | / | |\n| 5 | Readable import | / | |\n| 6 | winston | / | |\n| 7 | @dnd-kit/utilities | / | |\n| 8 | CORS | / | |\n\nBackend build: /\nFrontend build: /\nServer startup: /\n```\n\n---\n\n## Appendix: \n\n:\n\n1. ****  ARCHITECTURE.md  Bearer \n2. **winston / pino Structured Logging**  \n3. **CONTEXT.md **  \n4. **API_SPEC.md **  \n5. ****  jest \n6. **`generation_log` **  API\n7. ****  \n8. **API**  PreviewPage  `handleDelete` \n: \nID: task-1770918401706-38620f\nBranch: task/task-1770918401706-38620f\nWorktree: Users/yuyafujita/Projects/koma-fill/.worktrees/task-1770918401706-38620f",
        "branchColor": "#b84fe8",
        "index": 16
      },
      {
        "type": "anchor",
        "label": "[] Monitor: # KAMUI-4D Bug Fix & ",
        "branch": "task/task-1770918405559-058889",
        "worktreePath": "/Users/yuyafujita/Projects/koma-fill/.worktrees/task-1770918405559-058889",
        "parentCommitHash": "21c659994cdba8f6164acd549bc5b77b6f2b8504",
        "lane": 8,
        "isMerged": false,
        "mergeCommitHash": null,
        "statusChildren": [
          {
            "type": "unstaged",
            "label": " [task/task-1770918405559-058889] (3)",
            "files": [
              "evaluation-report-6tasks-600.html",
              "evaluation-report-6tasks.html",
              "evaluation-report.html"
            ],
            "branch": "task/task-1770918405559-058889",
            "targetCommitHash": "21c659994cdba8f6164acd549bc5b77b6f2b8504",
            "worktreePath": "/Users/yuyafujita/Projects/koma-fill/.worktrees/task-1770918405559-058889",
            "timestamp": 1770921960641,
            "sortOrder": 0,
            "lane": 8,
            "branchColor": "#4fe84f",
            "index": 11
          }
        ],
        "isDefaultWorktree": false,
        "renderMode": "node",
        "shouldHide": false,
        "tagLabel": "task/task-1770918405559-058889",
        "taskId": "task-1770918405559-058889",
        "taskStatus": "working",
        "taskStatusLabel": "",
        "taskName": "Monitor: # KAMUI-4D Bug Fix & Improvement Prompts for koma-fill\n## Post-Implementation Review  Multi-Agent Fix Guide\n\n**Version:** 1.1 (Post-Review Fix)\n**Project:** koma-fill - AI-powered manga panel generation system\n**Target:** KAMUI-4D Editor (Multi-AI CLI parallel execution)\n**Author:** Code Review by Claude (2026-02-13)\n\n---\n\n## Overview\n\n **3 + 1 + 4** \n\n### Issue Summary\n\n| # |  |  |  | Task |\n|---|------|--------|------|------|\n| 1 | Bug |  High | ImageUploader  useEffect  | Task 2 |\n| 2 | Bug |  High |  | Task 1 |\n| 3 | Bug |  Medium | SVG | Task 1 |\n| 4 | Security |  High |  | Task 1 |\n| 5 | Cleanup |  Low | exportService.ts  import | Task 1 |\n| 6 | Cleanup |  Low | winston  | Task 1 |\n| 7 | Improvement |  Medium | @dnd-kit/utilities  package.json  | Task 2 |\n| 8 | Improvement |  Medium | CORS origin  | Task 1 |\n\n---\n\n## Execution Strategy\n\n```\nTask 1 (Backend)   Agent A  #2,#3,#4,#5,#6,#8\nTask 2 (Frontend)  Agent B  #1,#7\nTask 3 (Verify)    Agent C   & Task 1,2 \n```\n\n**:** Task 1  Task 2 Task 3 \n\n```\nTimeline:\n  \n   Task 1 (Backend)      20-30 min\n   Agent A              \n  \n                           \n              Task 3 (Verify)   10-15 min\n                            Agent C          \n    \n   Task 2 (Frontend)     10-15 min\n   Agent B              \n  \n```\n\n---\n\n## Task 1:  (Agent A)\n### LayoutEngine / Security / Cleanup\n\n**Time Estimate:** 20-30 minutes\n**Difficulty:** Intermediate\n**Dependencies:** None\n\n### Objective\nCORS\n\n### Target Files\n\n```\nbackend/src/\n services/\n    layoutEngine.ts          [MODIFY]  (#2, #3)\n    exportService.ts         [MODIFY] import (#5)\n routes/\n    manga.ts                 [MODIFY]  (#4)\n app.ts                       [MODIFY] CORS (#8)\n config/\n     constants.ts             [MODIFY] ALLOWED_ORIGINS (#8)\nbackend/package.json             [MODIFY] winston (#6)\n```\n\n---\n\n### Fix #2: \n\n**File:** `backend/src/services/layoutEngine.ts`\n**Lines:** 299-313\n**Problem:** `bubble.text.split(' ')` 1\n\n**Current Code ():**\n```typescript\n// \nconst words = bubble.text.split(' ');\nconst lines: string[] = [];\nlet currentLine = '';\nconst maxCharsPerLine = 30;\n\nfor (const word of words) {\n  if ((currentLine + word).length > maxCharsPerLine) {\n    if (currentLine) lines.push(currentLine.trim());\n    currentLine = word + ' ';\n  } else {\n    currentLine += word + ' ';\n  }\n}\nif (currentLine) lines.push(currentLine.trim());\n```\n\n**Fix: **\n```typescript\n// : \nconst maxCharsPerLine = 15; // \nconst lines: string[] = [];\n\n// \nconst hasSpaces = bubble.text.includes(' ');\n\nif (hasSpaces) {\n  // : \n  const words = bubble.text.split(' ');\n  let currentLine = '';\n  for (const word of words) {\n    if ((currentLine + word).length > maxCharsPerLine) {\n      if (currentLine) lines.push(currentLine.trim());\n      currentLine = word + ' ';\n    } else {\n      currentLine += word + ' ';\n    }\n  }\n  if (currentLine) lines.push(currentLine.trim());\n} else {\n  // : \n  const text = bubble.text;\n  for (let i = 0; i < text.length; i += maxCharsPerLine) {\n    lines.push(text.slice(i, i + maxCharsPerLine));\n  }\n}\n```\n\n**Adjustment:**  `bubbleHeight` \n `const bubbleHeight = 60;` (265) :\n\n```typescript\n// bubbleHeight \nconst lineHeight = 20;\nconst verticalPadding = 20;\nconst bubbleHeight = Math.max(50, lines.length * lineHeight + verticalPadding);\n```\n\n**:** `bubbleHeight` ****\n`generateSpeechBubbleSvg` :\n1. lines\n2. bubbleHeight\n3. bubbleX/targetY\n4. shapePath\n5. textElements\n\n\n---\n\n### Fix #3: SVG\n\n**File:** `backend/src/services/layoutEngine.ts`\n**Line:** 320\n**Problem:** SVG `width`/`height` `sharp.composite()` \n\n**Current Code ():**\n```typescript\nconst svg = `<svg width=\"${panelPos.width + panelPos.x}\" height=\"${panelPos.height + panelPos.y}\" xmlns=\"http://www.w3.org/2000/svg\">\n```\n\n**Fix: addSpeechBubbles **\n\nStep 1: `generateSpeechBubbleSvg` :\n```typescript\nprivate generateSpeechBubbleSvg(\n  bubble: SpeechBubble,\n  panelPos: PanelPosition,\n  targetY: number,\n  layoutWidth: number,   //  \n  layoutHeight: number   //  \n): Buffer {\n```\n\nStep 2: SVG:\n```typescript\nconst svg = `<svg width=\"${layoutWidth}\" height=\"${layoutHeight}\" xmlns=\"http://www.w3.org/2000/svg\">\n```\n\nStep 3: `addSpeechBubbles`  (122):\n```typescript\nconst bubbleSvg = this.generateSpeechBubbleSvg(\n  bubble,\n  panelPos,\n  targetY,\n  layout.width,    //  \n  layout.height    //  \n);\n```\n\n---\n\n### Fix #4: \n\n**File:** `backend/src/routes/manga.ts`\n**Lines:** 664-673\n**Problem:**  `filePath: filePath` : `/app/uploads/xxx/panel.png`\n\n**Current Code ():**\n```typescript\nres.json({\n  message: 'Export successful',\n  projectId,\n  format: exportFormat,\n  downloadUrl: `/uploads/${projectId}/${path.basename(filePath)}`,\n  filePath: filePath,         //  \n  fileSize: result.fileSize,\n});\n```\n\n**Fix:**\n```typescript\nres.json({\n  message: 'Export successful',\n  projectId,\n  format: exportFormat,\n  downloadUrl: `/uploads/${projectId}/${path.basename(filePath)}`,\n  fileSize: result.fileSize,\n});\n```\n\n`filePath` OK `downloadUrl` \n\n---\n\n### Fix #5: exportService.ts  import\n\n**File:** `backend/src/services/exportService.ts`\n**Line:** 16\n\n**Current Code:**\n```typescript\nimport { Readable } from 'stream';\n```\n\n**Fix:** `Readable` \n\n---\n\n### Fix #6:  winston \n\n**File:** `backend/package.json`\n\n**Action:**\n```bash\ncd backend\nnpm uninstall winston\n```\n\n`winston`  import  `console.log` / `console.error` \n\n**Note:** Structured Logging `pino`  `winston` \n\n---\n\n### Fix #8: CORS origin \n\n**File:** `backend/src/config/constants.ts`\n\n**:** CONFIG  `ALLOWED_ORIGINS` :\n```typescript\nexport const CONFIG = {\n  // Server\n  PORT: parseInt(process.env.PORT || '5000', 10),\n  NODE_ENV: process.env.NODE_ENV || 'development',\n  BASE_URL: process.env.BASE_URL || 'http://localhost:5000',\n  ALLOWED_ORIGINS: process.env.ALLOWED_ORIGINS\n    ? process.env.ALLOWED_ORIGINS.split(',')\n    : ['http://localhost:3000'],\n\n  // ... \n```\n\n**File:** `backend/src/app.ts`\n\n**Current Code:**\n```typescript\napp.use(cors({\n  origin: process.env.NODE_ENV === 'production'\n    ? process.env.ALLOWED_ORIGINS?.split(',')\n    : ['http://localhost:3000'],\n}));\n```\n\n**Fix:**\n```typescript\nimport { CONFIG } from './config/constants';\n\n// ... (import)\n\napp.use(cors({\n  origin: CONFIG.NODE_ENV === 'production'\n    ? CONFIG.ALLOWED_ORIGINS\n    : CONFIG.ALLOWED_ORIGINS,\n}));\n```\n\n**:** `app.ts`  `CONFIG`  import  `app.ts`  `config/constants`  import \n\n---\n\n### Verification (Task 1)\n\n:\n\n```bash\ncd backend\n\n# TypeScript \nnpx tsc --noEmit\n\n# \nnpm ls --depth=0\n\n# \nnpm run build\n```\n\n**Expected:** \n\n---\n\n## Task 2:  (Agent B)\n### ImageUploader Bug Fix & Dependency Cleanup\n\n**Time Estimate:** 10-15 minutes\n**Difficulty:** Easy\n**Dependencies:** None\n\n### Objective\nImageUploader `package.json` \n\n### Target Files\n\n```\nfrontend/\n src/\n    components/\n        ImageUploader.tsx    [MODIFY] useEffect (#1)\n package.json                 [MODIFY] @dnd-kit/utilities (#7)\n```\n\n---\n\n### Fix #1: ImageUploader  useEffect \n\n**File:** `frontend/src/components/ImageUploader.tsx`\n**Lines:** 25-29\n**Problem:** `useEffect`  `images`  ** ObjectURL  revoke **\n\n**Current Code ():**\n```typescript\nuseEffect(() => {\n  return () => {\n    images.forEach((image) => URL.revokeObjectURL(image.previewUrl));\n  };\n}, [images]);\n```\n\n**:**\n1. A  `images = [A]`\n2. B  `images`  effect \n3.  `images.forEach(URL.revokeObjectURL)` AURL revoke \n4. : ABURL\n\n**Fix:  revoke  +  revoke **\n\n```typescript\n// URL\nuseEffect(() => {\n  return () => {\n    // URL\n    // eslint-disable-next-line react-hooks/exhaustive-deps -- intentionally run only on unmount\n    images.forEach((image) => URL.revokeObjectURL(image.previewUrl));\n  };\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n}, []);\n```\n\n**:** `removeImage` 73-81 `URL.revokeObjectURL` \n\n**:** `eslint-disable` :\n- React  `react-hooks/exhaustive-deps`  `images` \n- \n- `images`  `useRef`  `removeImage`  revoke  cleanup \n\n**Alternative Fix:**\n`useRef`  `images` :\n\n```typescript\nconst imagesRef = useRef<UploadedImage[]>([]);\n\n// imagesref\nuseEffect(() => {\n  imagesRef.current = images;\n}, [images]);\n\n// URL\nuseEffect(() => {\n  return () => {\n    imagesRef.current.forEach((image) => URL.revokeObjectURL(image.previewUrl));\n  };\n}, []);\n```\n\n**:** Alternative FixuseRef ESLint \n\n---\n\n### Fix #7: @dnd-kit/utilities  package.json \n\n**File:** `frontend/package.json`\n\n**Action:**\n```bash\ncd frontend\nnpm install @dnd-kit/utilities\n```\n\n**Reason:** `PanelGrid.tsx`  `@dnd-kit/utilities`  `CSS` `package.json` `@dnd-kit/sortable`  transitive dependency  break\n\n---\n\n### Verification (Task 2)\n\n:\n\n```bash\ncd frontend\n\n# TypeScript \nnpx tsc --noEmit\n\n# \nnpm run build\n\n# package.json \nnpm ls @dnd-kit/utilities\n```\n\n**Expected:** `dist/` \n\n---\n\n## Task 3:  (Agent C)\n### Build Verification & Integration Test\n\n**Time Estimate:** 10-15 minutes\n**Difficulty:** Easy\n**Dependencies:** Task 1  Task 2 \n\n### Objective\nTask 1, 2 TypeScript \n\n### Verification Checklist\n\n#### Step 1: Backend \n\n```bash\ncd backend\n\n# winston\nnpm install\n\n# TypeScript \nnpx tsc --noEmit\necho \"Backend type check: $?\"\n\n# \nnpm run build\necho \"Backend build: $?\"\n\n# \nls -la dist/services/layoutEngine.js\nls -la dist/services/exportService.js\nls -la dist/routes/manga.js\nls -la dist/app.js\n```\n\n**Expected:**\n-  exit code 0\n- `dist/`  `.js`  `.d.ts` \n- `dist/services/exportService.js`  `Readable`  import \n\n#### Step 2: Frontend \n\n```bash\ncd frontend\n\n# @dnd-kit/utilities\nnpm install\n\n# TypeScript \nnpx tsc --noEmit\necho \"Frontend type check: $?\"\n\n# Vite \nnpm run build\necho \"Frontend build: $?\"\n\n# \nls -la dist/\nls -la dist/assets/\n```\n\n**Expected:**\n-  exit code 0\n- `dist/index.html`  `dist/assets/`  JS/CSS \n\n#### Step 3: \n\n```bash\ncd backend\n\n# 5\ntimeout 5 node dist/index.js 2>&1 || true\n\n# \n# curl -s http://localhost:5000/api/health | head -1\n```\n\n**Expected:**\n- `koma-fill server running on http://localhost:5000` \n- DB initialized \n- \n\n#### Step 4: grep \n\n```bash\n# Fix #4: filePath  export \ngrep -n \"filePath:\" backend/src/routes/manga.ts | grep -v \"downloadUrl\\|layoutPath\\|imageFilePath\\|const filePath\\|file_path\\|\\.filePath\"\n\n# Fix #5: Readable  exportService import\ngrep -n \"Readable\" backend/src/services/exportService.ts\n\n# Fix #6: winston  package.json \ngrep -n \"winston\" backend/package.json\n\n# Fix #7: @dnd-kit/utilities  frontend/package.json \ngrep -n \"dnd-kit/utilities\" frontend/package.json\n\n# Fix #8: CONFIG.ALLOWED_ORIGINS \ngrep -n \"ALLOWED_ORIGINS\" backend/src/config/constants.ts\ngrep -n \"ALLOWED_ORIGINS\\|CONFIG\" backend/src/app.ts\n```\n\n**Expected:**\n- Fix #4: export  `filePath` \n- Fix #5: `Readable`  import \n- Fix #6: `winston` \n- Fix #7: `@dnd-kit/utilities` \n- Fix #8: `ALLOWED_ORIGINS`  constants.ts  app.ts \n\n#### Step 5: LayoutEngine \n\n```bash\n# layoutEngine.ts \ngrep -A 20 \"\" backend/src/services/layoutEngine.ts\n# \ngrep -A 20 \"maxCharsPerLine\" backend/src/services/layoutEngine.ts\n```\n\n**Expected:** `.split(' ')` \n\n---\n\n### Final Report\n\n:\n\n```\n## Fix Verification Report\n\n| # | Fix | Status | Notes |\n|---|-----|--------|-------|\n| 1 | ImageUploader useEffect | / | |\n| 2 |  | / | |\n| 3 | SVG | / | |\n| 4 |  | / | |\n| 5 | Readable import | / | |\n| 6 | winston | / | |\n| 7 | @dnd-kit/utilities | / | |\n| 8 | CORS | / | |\n\nBackend build: /\nFrontend build: /\nServer startup: /\n```\n\n---\n\n## Appendix: \n\n:\n\n1. ****  ARCHITECTURE.md  Bearer \n2. **winston / pino Structured Logging**  \n3. **CONTEXT.md **  \n4. **API_SPEC.md **  \n5. ****  jest \n6. **`generation_log` **  API\n7. ****  \n8. **API**  PreviewPage  `handleDelete` ",
        "tooltip": ": Monitor: # KAMUI-4D Bug Fix & Improvement Prompts for koma-fill\n## Post-Implementation Review  Multi-Agent Fix Guide\n\n**Version:** 1.1 (Post-Review Fix)\n**Project:** koma-fill - AI-powered manga panel generation system\n**Target:** KAMUI-4D Editor (Multi-AI CLI parallel execution)\n**Author:** Code Review by Claude (2026-02-13)\n\n---\n\n## Overview\n\n **3 + 1 + 4** \n\n### Issue Summary\n\n| # |  |  |  | Task |\n|---|------|--------|------|------|\n| 1 | Bug |  High | ImageUploader  useEffect  | Task 2 |\n| 2 | Bug |  High |  | Task 1 |\n| 3 | Bug |  Medium | SVG | Task 1 |\n| 4 | Security |  High |  | Task 1 |\n| 5 | Cleanup |  Low | exportService.ts  import | Task 1 |\n| 6 | Cleanup |  Low | winston  | Task 1 |\n| 7 | Improvement |  Medium | @dnd-kit/utilities  package.json  | Task 2 |\n| 8 | Improvement |  Medium | CORS origin  | Task 1 |\n\n---\n\n## Execution Strategy\n\n```\nTask 1 (Backend)   Agent A  #2,#3,#4,#5,#6,#8\nTask 2 (Frontend)  Agent B  #1,#7\nTask 3 (Verify)    Agent C   & Task 1,2 \n```\n\n**:** Task 1  Task 2 Task 3 \n\n```\nTimeline:\n  \n   Task 1 (Backend)      20-30 min\n   Agent A              \n  \n                           \n              Task 3 (Verify)   10-15 min\n                            Agent C          \n    \n   Task 2 (Frontend)     10-15 min\n   Agent B              \n  \n```\n\n---\n\n## Task 1:  (Agent A)\n### LayoutEngine / Security / Cleanup\n\n**Time Estimate:** 20-30 minutes\n**Difficulty:** Intermediate\n**Dependencies:** None\n\n### Objective\nCORS\n\n### Target Files\n\n```\nbackend/src/\n services/\n    layoutEngine.ts          [MODIFY]  (#2, #3)\n    exportService.ts         [MODIFY] import (#5)\n routes/\n    manga.ts                 [MODIFY]  (#4)\n app.ts                       [MODIFY] CORS (#8)\n config/\n     constants.ts             [MODIFY] ALLOWED_ORIGINS (#8)\nbackend/package.json             [MODIFY] winston (#6)\n```\n\n---\n\n### Fix #2: \n\n**File:** `backend/src/services/layoutEngine.ts`\n**Lines:** 299-313\n**Problem:** `bubble.text.split(' ')` 1\n\n**Current Code ():**\n```typescript\n// \nconst words = bubble.text.split(' ');\nconst lines: string[] = [];\nlet currentLine = '';\nconst maxCharsPerLine = 30;\n\nfor (const word of words) {\n  if ((currentLine + word).length > maxCharsPerLine) {\n    if (currentLine) lines.push(currentLine.trim());\n    currentLine = word + ' ';\n  } else {\n    currentLine += word + ' ';\n  }\n}\nif (currentLine) lines.push(currentLine.trim());\n```\n\n**Fix: **\n```typescript\n// : \nconst maxCharsPerLine = 15; // \nconst lines: string[] = [];\n\n// \nconst hasSpaces = bubble.text.includes(' ');\n\nif (hasSpaces) {\n  // : \n  const words = bubble.text.split(' ');\n  let currentLine = '';\n  for (const word of words) {\n    if ((currentLine + word).length > maxCharsPerLine) {\n      if (currentLine) lines.push(currentLine.trim());\n      currentLine = word + ' ';\n    } else {\n      currentLine += word + ' ';\n    }\n  }\n  if (currentLine) lines.push(currentLine.trim());\n} else {\n  // : \n  const text = bubble.text;\n  for (let i = 0; i < text.length; i += maxCharsPerLine) {\n    lines.push(text.slice(i, i + maxCharsPerLine));\n  }\n}\n```\n\n**Adjustment:**  `bubbleHeight` \n `const bubbleHeight = 60;` (265) :\n\n```typescript\n// bubbleHeight \nconst lineHeight = 20;\nconst verticalPadding = 20;\nconst bubbleHeight = Math.max(50, lines.length * lineHeight + verticalPadding);\n```\n\n**:** `bubbleHeight` ****\n`generateSpeechBubbleSvg` :\n1. lines\n2. bubbleHeight\n3. bubbleX/targetY\n4. shapePath\n5. textElements\n\n\n---\n\n### Fix #3: SVG\n\n**File:** `backend/src/services/layoutEngine.ts`\n**Line:** 320\n**Problem:** SVG `width`/`height` `sharp.composite()` \n\n**Current Code ():**\n```typescript\nconst svg = `<svg width=\"${panelPos.width + panelPos.x}\" height=\"${panelPos.height + panelPos.y}\" xmlns=\"http://www.w3.org/2000/svg\">\n```\n\n**Fix: addSpeechBubbles **\n\nStep 1: `generateSpeechBubbleSvg` :\n```typescript\nprivate generateSpeechBubbleSvg(\n  bubble: SpeechBubble,\n  panelPos: PanelPosition,\n  targetY: number,\n  layoutWidth: number,   //  \n  layoutHeight: number   //  \n): Buffer {\n```\n\nStep 2: SVG:\n```typescript\nconst svg = `<svg width=\"${layoutWidth}\" height=\"${layoutHeight}\" xmlns=\"http://www.w3.org/2000/svg\">\n```\n\nStep 3: `addSpeechBubbles`  (122):\n```typescript\nconst bubbleSvg = this.generateSpeechBubbleSvg(\n  bubble,\n  panelPos,\n  targetY,\n  layout.width,    //  \n  layout.height    //  \n);\n```\n\n---\n\n### Fix #4: \n\n**File:** `backend/src/routes/manga.ts`\n**Lines:** 664-673\n**Problem:**  `filePath: filePath` : `/app/uploads/xxx/panel.png`\n\n**Current Code ():**\n```typescript\nres.json({\n  message: 'Export successful',\n  projectId,\n  format: exportFormat,\n  downloadUrl: `/uploads/${projectId}/${path.basename(filePath)}`,\n  filePath: filePath,         //  \n  fileSize: result.fileSize,\n});\n```\n\n**Fix:**\n```typescript\nres.json({\n  message: 'Export successful',\n  projectId,\n  format: exportFormat,\n  downloadUrl: `/uploads/${projectId}/${path.basename(filePath)}`,\n  fileSize: result.fileSize,\n});\n```\n\n`filePath` OK `downloadUrl` \n\n---\n\n### Fix #5: exportService.ts  import\n\n**File:** `backend/src/services/exportService.ts`\n**Line:** 16\n\n**Current Code:**\n```typescript\nimport { Readable } from 'stream';\n```\n\n**Fix:** `Readable` \n\n---\n\n### Fix #6:  winston \n\n**File:** `backend/package.json`\n\n**Action:**\n```bash\ncd backend\nnpm uninstall winston\n```\n\n`winston`  import  `console.log` / `console.error` \n\n**Note:** Structured Logging `pino`  `winston` \n\n---\n\n### Fix #8: CORS origin \n\n**File:** `backend/src/config/constants.ts`\n\n**:** CONFIG  `ALLOWED_ORIGINS` :\n```typescript\nexport const CONFIG = {\n  // Server\n  PORT: parseInt(process.env.PORT || '5000', 10),\n  NODE_ENV: process.env.NODE_ENV || 'development',\n  BASE_URL: process.env.BASE_URL || 'http://localhost:5000',\n  ALLOWED_ORIGINS: process.env.ALLOWED_ORIGINS\n    ? process.env.ALLOWED_ORIGINS.split(',')\n    : ['http://localhost:3000'],\n\n  // ... \n```\n\n**File:** `backend/src/app.ts`\n\n**Current Code:**\n```typescript\napp.use(cors({\n  origin: process.env.NODE_ENV === 'production'\n    ? process.env.ALLOWED_ORIGINS?.split(',')\n    : ['http://localhost:3000'],\n}));\n```\n\n**Fix:**\n```typescript\nimport { CONFIG } from './config/constants';\n\n// ... (import)\n\napp.use(cors({\n  origin: CONFIG.NODE_ENV === 'production'\n    ? CONFIG.ALLOWED_ORIGINS\n    : CONFIG.ALLOWED_ORIGINS,\n}));\n```\n\n**:** `app.ts`  `CONFIG`  import  `app.ts`  `config/constants`  import \n\n---\n\n### Verification (Task 1)\n\n:\n\n```bash\ncd backend\n\n# TypeScript \nnpx tsc --noEmit\n\n# \nnpm ls --depth=0\n\n# \nnpm run build\n```\n\n**Expected:** \n\n---\n\n## Task 2:  (Agent B)\n### ImageUploader Bug Fix & Dependency Cleanup\n\n**Time Estimate:** 10-15 minutes\n**Difficulty:** Easy\n**Dependencies:** None\n\n### Objective\nImageUploader `package.json` \n\n### Target Files\n\n```\nfrontend/\n src/\n    components/\n        ImageUploader.tsx    [MODIFY] useEffect (#1)\n package.json                 [MODIFY] @dnd-kit/utilities (#7)\n```\n\n---\n\n### Fix #1: ImageUploader  useEffect \n\n**File:** `frontend/src/components/ImageUploader.tsx`\n**Lines:** 25-29\n**Problem:** `useEffect`  `images`  ** ObjectURL  revoke **\n\n**Current Code ():**\n```typescript\nuseEffect(() => {\n  return () => {\n    images.forEach((image) => URL.revokeObjectURL(image.previewUrl));\n  };\n}, [images]);\n```\n\n**:**\n1. A  `images = [A]`\n2. B  `images`  effect \n3.  `images.forEach(URL.revokeObjectURL)` AURL revoke \n4. : ABURL\n\n**Fix:  revoke  +  revoke **\n\n```typescript\n// URL\nuseEffect(() => {\n  return () => {\n    // URL\n    // eslint-disable-next-line react-hooks/exhaustive-deps -- intentionally run only on unmount\n    images.forEach((image) => URL.revokeObjectURL(image.previewUrl));\n  };\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n}, []);\n```\n\n**:** `removeImage` 73-81 `URL.revokeObjectURL` \n\n**:** `eslint-disable` :\n- React  `react-hooks/exhaustive-deps`  `images` \n- \n- `images`  `useRef`  `removeImage`  revoke  cleanup \n\n**Alternative Fix:**\n`useRef`  `images` :\n\n```typescript\nconst imagesRef = useRef<UploadedImage[]>([]);\n\n// imagesref\nuseEffect(() => {\n  imagesRef.current = images;\n}, [images]);\n\n// URL\nuseEffect(() => {\n  return () => {\n    imagesRef.current.forEach((image) => URL.revokeObjectURL(image.previewUrl));\n  };\n}, []);\n```\n\n**:** Alternative FixuseRef ESLint \n\n---\n\n### Fix #7: @dnd-kit/utilities  package.json \n\n**File:** `frontend/package.json`\n\n**Action:**\n```bash\ncd frontend\nnpm install @dnd-kit/utilities\n```\n\n**Reason:** `PanelGrid.tsx`  `@dnd-kit/utilities`  `CSS` `package.json` `@dnd-kit/sortable`  transitive dependency  break\n\n---\n\n### Verification (Task 2)\n\n:\n\n```bash\ncd frontend\n\n# TypeScript \nnpx tsc --noEmit\n\n# \nnpm run build\n\n# package.json \nnpm ls @dnd-kit/utilities\n```\n\n**Expected:** `dist/` \n\n---\n\n## Task 3:  (Agent C)\n### Build Verification & Integration Test\n\n**Time Estimate:** 10-15 minutes\n**Difficulty:** Easy\n**Dependencies:** Task 1  Task 2 \n\n### Objective\nTask 1, 2 TypeScript \n\n### Verification Checklist\n\n#### Step 1: Backend \n\n```bash\ncd backend\n\n# winston\nnpm install\n\n# TypeScript \nnpx tsc --noEmit\necho \"Backend type check: $?\"\n\n# \nnpm run build\necho \"Backend build: $?\"\n\n# \nls -la dist/services/layoutEngine.js\nls -la dist/services/exportService.js\nls -la dist/routes/manga.js\nls -la dist/app.js\n```\n\n**Expected:**\n-  exit code 0\n- `dist/`  `.js`  `.d.ts` \n- `dist/services/exportService.js`  `Readable`  import \n\n#### Step 2: Frontend \n\n```bash\ncd frontend\n\n# @dnd-kit/utilities\nnpm install\n\n# TypeScript \nnpx tsc --noEmit\necho \"Frontend type check: $?\"\n\n# Vite \nnpm run build\necho \"Frontend build: $?\"\n\n# \nls -la dist/\nls -la dist/assets/\n```\n\n**Expected:**\n-  exit code 0\n- `dist/index.html`  `dist/assets/`  JS/CSS \n\n#### Step 3: \n\n```bash\ncd backend\n\n# 5\ntimeout 5 node dist/index.js 2>&1 || true\n\n# \n# curl -s http://localhost:5000/api/health | head -1\n```\n\n**Expected:**\n- `koma-fill server running on http://localhost:5000` \n- DB initialized \n- \n\n#### Step 4: grep \n\n```bash\n# Fix #4: filePath  export \ngrep -n \"filePath:\" backend/src/routes/manga.ts | grep -v \"downloadUrl\\|layoutPath\\|imageFilePath\\|const filePath\\|file_path\\|\\.filePath\"\n\n# Fix #5: Readable  exportService import\ngrep -n \"Readable\" backend/src/services/exportService.ts\n\n# Fix #6: winston  package.json \ngrep -n \"winston\" backend/package.json\n\n# Fix #7: @dnd-kit/utilities  frontend/package.json \ngrep -n \"dnd-kit/utilities\" frontend/package.json\n\n# Fix #8: CONFIG.ALLOWED_ORIGINS \ngrep -n \"ALLOWED_ORIGINS\" backend/src/config/constants.ts\ngrep -n \"ALLOWED_ORIGINS\\|CONFIG\" backend/src/app.ts\n```\n\n**Expected:**\n- Fix #4: export  `filePath` \n- Fix #5: `Readable`  import \n- Fix #6: `winston` \n- Fix #7: `@dnd-kit/utilities` \n- Fix #8: `ALLOWED_ORIGINS`  constants.ts  app.ts \n\n#### Step 5: LayoutEngine \n\n```bash\n# layoutEngine.ts \ngrep -A 20 \"\" backend/src/services/layoutEngine.ts\n# \ngrep -A 20 \"maxCharsPerLine\" backend/src/services/layoutEngine.ts\n```\n\n**Expected:** `.split(' ')` \n\n---\n\n### Final Report\n\n:\n\n```\n## Fix Verification Report\n\n| # | Fix | Status | Notes |\n|---|-----|--------|-------|\n| 1 | ImageUploader useEffect | / | |\n| 2 |  | / | |\n| 3 | SVG | / | |\n| 4 |  | / | |\n| 5 | Readable import | / | |\n| 6 | winston | / | |\n| 7 | @dnd-kit/utilities | / | |\n| 8 | CORS | / | |\n\nBackend build: /\nFrontend build: /\nServer startup: /\n```\n\n---\n\n## Appendix: \n\n:\n\n1. ****  ARCHITECTURE.md  Bearer \n2. **winston / pino Structured Logging**  \n3. **CONTEXT.md **  \n4. **API_SPEC.md **  \n5. ****  jest \n6. **`generation_log` **  API\n7. ****  \n8. **API**  PreviewPage  `handleDelete` \n: \nID: task-1770918405559-058889\nBranch: task/task-1770918405559-058889\nWorktree: Users/yuyafujita/Projects/koma-fill/.worktrees/task-1770918405559-058889",
        "branchColor": "#4fe84f",
        "index": 17
      },
      {
        "type": "commit",
        "label": "feat: add kamui assets, docs, and update configs",
        "commit": {
          "hash": "21c659994cdba8f6164acd549bc5b77b6f2b8504",
          "subject": "feat: add kamui assets, docs, and update configs",
          "author": "Yuya Fujita",
          "timestamp": 1770918340,
          "parents": [
            "65530e0f6502c434a6bdd5af2933a64d422f3c94"
          ],
          "parent": "65530e0f6502c434a6bdd5af2933a64d422f3c94",
          "refs": "origin/main, origin/HEAD, task/task-1770918405559-058889, task/task-1770918401706-38620f, task/task-1770918401534-118872, task/task-1770918401380-e8add6, task/task-1770918401073-c21f64, task/task-1770918400875-2630f2",
          "branches": [
            "origin/main",
            "origin/HEAD",
            "task/task-1770918405559-058889",
            "task/task-1770918401706-38620f",
            "task/task-1770918401534-118872",
            "task/task-1770918401380-e8add6",
            "task/task-1770918401073-c21f64",
            "task/task-1770918400875-2630f2",
            "main",
            "task/task-1770918400673-d21f34"
          ]
        },
        "commitHash": "21c659994cdba8f6164acd549bc5b77b6f2b8504",
        "lane": 0,
        "parentLinks": [
          {
            "hash": "65530e0f6502c434a6bdd5af2933a64d422f3c94",
            "lane": 0
          }
        ],
        "primaryBranchName": "main",
        "branchColor": "#4f85e8",
        "branchTags": [],
        "worktrees": [
          {
            "path": "/Users/yuyafujita/Projects/koma-fill/.worktrees/task-1770918400875-2630f2",
            "head": "21c659994cdba8f6164acd549bc5b77b6f2b8504",
            "branch": "task/task-1770918400875-2630f2",
            "isMerged": false,
            "mergeCommitHash": null,
            "status": {
              "staged": [],
              "unstaged": [],
              "untracked": [],
              "capturedAt": 1770921960618
            },
            "normalizedPath": "/Users/yuyafujita/Projects/koma-fill/.worktrees/task-1770918400875-2630f2",
            "lane": 4
          },
          {
            "path": "/Users/yuyafujita/Projects/koma-fill/.worktrees/task-1770918401073-c21f64",
            "head": "21c659994cdba8f6164acd549bc5b77b6f2b8504",
            "branch": "task/task-1770918401073-c21f64",
            "isMerged": false,
            "mergeCommitHash": null,
            "status": {
              "staged": [],
              "unstaged": [],
              "untracked": [],
              "capturedAt": 1770921960618
            },
            "normalizedPath": "/Users/yuyafujita/Projects/koma-fill/.worktrees/task-1770918401073-c21f64",
            "lane": 5
          },
          {
            "path": "/Users/yuyafujita/Projects/koma-fill/.worktrees/task-1770918401380-e8add6",
            "head": "21c659994cdba8f6164acd549bc5b77b6f2b8504",
            "branch": "task/task-1770918401380-e8add6",
            "isMerged": false,
            "mergeCommitHash": null,
            "status": {
              "staged": [
                {
                  "path": "ackend/package.json",
                  "originalPath": null,
                  "status": "modified",
                  "rawPath": "ackend/package.json",
                  "timestamp": 1770921960631
                }
              ],
              "unstaged": [
                {
                  "path": "backend/src/app.ts",
                  "originalPath": null,
                  "status": "modified",
                  "rawPath": "backend/src/app.ts",
                  "timestamp": 1770921960631
                },
                {
                  "path": "backend/src/config/constants.ts",
                  "originalPath": null,
                  "status": "modified",
                  "rawPath": "backend/src/config/constants.ts",
                  "timestamp": 1770921960631
                },
                {
                  "path": "backend/src/routes/manga.ts",
                  "originalPath": null,
                  "status": "modified",
                  "rawPath": "backend/src/routes/manga.ts",
                  "timestamp": 1770921960631
                },
                {
                  "path": "backend/src/services/exportService.ts",
                  "originalPath": null,
                  "status": "modified",
                  "rawPath": "backend/src/services/exportService.ts",
                  "timestamp": 1770921960631
                },
                {
                  "path": "backend/src/services/layoutEngine.ts",
                  "originalPath": null,
                  "status": "modified",
                  "rawPath": "backend/src/services/layoutEngine.ts",
                  "timestamp": 1770921960631
                },
                {
                  "path": "frontend/package.json",
                  "originalPath": null,
                  "status": "modified",
                  "rawPath": "frontend/package.json",
                  "timestamp": 1770921960631
                },
                {
                  "path": "frontend/src/components/ImageUploader.tsx",
                  "originalPath": null,
                  "status": "modified",
                  "rawPath": "frontend/src/components/ImageUploader.tsx",
                  "timestamp": 1770921960631
                },
                {
                  "path": "package-lock.json",
                  "originalPath": null,
                  "status": "modified",
                  "rawPath": "package-lock.json",
                  "timestamp": 1770921960631
                }
              ],
              "untracked": [],
              "capturedAt": 1770921960631
            },
            "normalizedPath": "/Users/yuyafujita/Projects/koma-fill/.worktrees/task-1770918401380-e8add6",
            "lane": 3
          },
          {
            "path": "/Users/yuyafujita/Projects/koma-fill/.worktrees/task-1770918401534-118872",
            "head": "21c659994cdba8f6164acd549bc5b77b6f2b8504",
            "branch": "task/task-1770918401534-118872",
            "isMerged": false,
            "mergeCommitHash": null,
            "status": {
              "staged": [
                {
                  "path": "ackend/package.json",
                  "originalPath": null,
                  "status": "modified",
                  "rawPath": "ackend/package.json",
                  "timestamp": 1770921960630
                }
              ],
              "unstaged": [
                {
                  "path": "backend/src/app.ts",
                  "originalPath": null,
                  "status": "modified",
                  "rawPath": "backend/src/app.ts",
                  "timestamp": 1770921960630
                },
                {
                  "path": "backend/src/config/constants.ts",
                  "originalPath": null,
                  "status": "modified",
                  "rawPath": "backend/src/config/constants.ts",
                  "timestamp": 1770921960630
                },
                {
                  "path": "backend/src/routes/manga.ts",
                  "originalPath": null,
                  "status": "modified",
                  "rawPath": "backend/src/routes/manga.ts",
                  "timestamp": 1770921960630
                },
                {
                  "path": "backend/src/services/exportService.ts",
                  "originalPath": null,
                  "status": "modified",
                  "rawPath": "backend/src/services/exportService.ts",
                  "timestamp": 1770921960630
                },
                {
                  "path": "backend/src/services/layoutEngine.ts",
                  "originalPath": null,
                  "status": "modified",
                  "rawPath": "backend/src/services/layoutEngine.ts",
                  "timestamp": 1770921960630
                },
                {
                  "path": "frontend/package.json",
                  "originalPath": null,
                  "status": "modified",
                  "rawPath": "frontend/package.json",
                  "timestamp": 1770921960630
                },
                {
                  "path": "frontend/src/components/ImageUploader.tsx",
                  "originalPath": null,
                  "status": "modified",
                  "rawPath": "frontend/src/components/ImageUploader.tsx",
                  "timestamp": 1770921960630
                },
                {
                  "path": "package-lock.json",
                  "originalPath": null,
                  "status": "modified",
                  "rawPath": "package-lock.json",
                  "timestamp": 1770921960630
                }
              ],
              "untracked": [],
              "capturedAt": 1770921960630
            },
            "normalizedPath": "/Users/yuyafujita/Projects/koma-fill/.worktrees/task-1770918401534-118872",
            "lane": 6
          },
          {
            "path": "/Users/yuyafujita/Projects/koma-fill/.worktrees/task-1770918401706-38620f",
            "head": "21c659994cdba8f6164acd549bc5b77b6f2b8504",
            "branch": "task/task-1770918401706-38620f",
            "isMerged": false,
            "mergeCommitHash": null,
            "status": {
              "staged": [
                {
                  "path": "ackend/package.json",
                  "originalPath": null,
                  "status": "modified",
                  "rawPath": "ackend/package.json",
                  "timestamp": 1770921960641
                }
              ],
              "unstaged": [
                {
                  "path": "backend/src/app.ts",
                  "originalPath": null,
                  "status": "modified",
                  "rawPath": "backend/src/app.ts",
                  "timestamp": 1770921960641
                },
                {
                  "path": "backend/src/config/constants.ts",
                  "originalPath": null,
                  "status": "modified",
                  "rawPath": "backend/src/config/constants.ts",
                  "timestamp": 1770921960641
                },
                {
                  "path": "backend/src/routes/manga.ts",
                  "originalPath": null,
                  "status": "modified",
                  "rawPath": "backend/src/routes/manga.ts",
                  "timestamp": 1770921960641
                },
                {
                  "path": "backend/src/services/exportService.ts",
                  "originalPath": null,
                  "status": "modified",
                  "rawPath": "backend/src/services/exportService.ts",
                  "timestamp": 1770921960641
                },
                {
                  "path": "backend/src/services/layoutEngine.ts",
                  "originalPath": null,
                  "status": "modified",
                  "rawPath": "backend/src/services/layoutEngine.ts",
                  "timestamp": 1770921960641
                },
                {
                  "path": "frontend/package.json",
                  "originalPath": null,
                  "status": "modified",
                  "rawPath": "frontend/package.json",
                  "timestamp": 1770921960641
                },
                {
                  "path": "frontend/src/components/ImageUploader.tsx",
                  "originalPath": null,
                  "status": "modified",
                  "rawPath": "frontend/src/components/ImageUploader.tsx",
                  "timestamp": 1770921960641
                },
                {
                  "path": "package-lock.json",
                  "originalPath": null,
                  "status": "modified",
                  "rawPath": "package-lock.json",
                  "timestamp": 1770921960641
                }
              ],
              "untracked": [],
              "capturedAt": 1770921960641
            },
            "normalizedPath": "/Users/yuyafujita/Projects/koma-fill/.worktrees/task-1770918401706-38620f",
            "lane": 7
          },
          {
            "path": "/Users/yuyafujita/Projects/koma-fill/.worktrees/task-1770918405559-058889",
            "head": "21c659994cdba8f6164acd549bc5b77b6f2b8504",
            "branch": "task/task-1770918405559-058889",
            "isMerged": false,
            "mergeCommitHash": null,
            "status": {
              "staged": [],
              "unstaged": [],
              "untracked": [
                {
                  "path": "evaluation-report-6tasks-600.html",
                  "status": "untracked",
                  "rawPath": "evaluation-report-6tasks-600.html",
                  "timestamp": 1770921960641
                },
                {
                  "path": "evaluation-report-6tasks.html",
                  "status": "untracked",
                  "rawPath": "evaluation-report-6tasks.html",
                  "timestamp": 1770921960641
                },
                {
                  "path": "evaluation-report.html",
                  "status": "untracked",
                  "rawPath": "evaluation-report.html",
                  "timestamp": 1770921960641
                }
              ],
              "capturedAt": 1770921960641
            },
            "normalizedPath": "/Users/yuyafujita/Projects/koma-fill/.worktrees/task-1770918405559-058889",
            "lane": 8
          }
        ],
        "index": 18
      },
      {
        "type": "commit",
        "label": "Merge branch 'task/task-1770909068463-2984dc'",
        "commit": {
          "hash": "65530e0f6502c434a6bdd5af2933a64d422f3c94",
          "subject": "Merge branch 'task/task-1770909068463-2984dc'",
          "author": "Yuya Fujita",
          "timestamp": 1770909741,
          "parents": [
            "c27bd61af6650e7c8fe59b133b858bebf9bd0eb3",
            "f504fb330085dd678241be890191ac269c049851"
          ],
          "parent": "c27bd61af6650e7c8fe59b133b858bebf9bd0eb3",
          "refs": "",
          "branches": [
            "main",
            "task/task-1770918400673-d21f34",
            "task/task-1770918401380-e8add6",
            "task/task-1770918400875-2630f2",
            "task/task-1770918401073-c21f64",
            "task/task-1770918401534-118872",
            "task/task-1770918401706-38620f",
            "task/task-1770918405559-058889",
            "task/task-1770909068463-2984dc"
          ]
        },
        "commitHash": "65530e0f6502c434a6bdd5af2933a64d422f3c94",
        "lane": 0,
        "parentLinks": [
          {
            "hash": "c27bd61af6650e7c8fe59b133b858bebf9bd0eb3",
            "lane": 0
          },
          {
            "hash": "f504fb330085dd678241be890191ac269c049851",
            "lane": 2
          }
        ],
        "primaryBranchName": "main",
        "branchColor": "#4f85e8",
        "branchTags": [
          "task/task-1770909068463-2984dc"
        ],
        "index": 19
      },
      {
        "type": "commit",
        "label": "Update .kamui tasks state on main before merge",
        "commit": {
          "hash": "c27bd61af6650e7c8fe59b133b858bebf9bd0eb3",
          "subject": "Update .kamui tasks state on main before merge",
          "author": "Yuya Fujita",
          "timestamp": 1770909737,
          "parents": [
            "1515fedca072442ad0656037229bce50b2e341f3"
          ],
          "parent": "1515fedca072442ad0656037229bce50b2e341f3",
          "refs": "",
          "branches": [
            "main",
            "task/task-1770918400673-d21f34",
            "task/task-1770918401380-e8add6",
            "task/task-1770918400875-2630f2",
            "task/task-1770918401073-c21f64",
            "task/task-1770918401534-118872",
            "task/task-1770918401706-38620f",
            "task/task-1770918405559-058889"
          ]
        },
        "commitHash": "c27bd61af6650e7c8fe59b133b858bebf9bd0eb3",
        "lane": 0,
        "parentLinks": [
          {
            "hash": "1515fedca072442ad0656037229bce50b2e341f3",
            "lane": 0
          }
        ],
        "primaryBranchName": "main",
        "branchColor": "#4f85e8",
        "branchTags": [],
        "index": 20
      },
      {
        "type": "commit",
        "label": "Implement frontend manga workflow and complete backend regen",
        "commit": {
          "hash": "f504fb330085dd678241be890191ac269c049851",
          "subject": "Implement frontend manga workflow and complete backend regeneration/image utilities",
          "author": "Yuya Fujita",
          "timestamp": 1770909669,
          "parents": [
            "1515fedca072442ad0656037229bce50b2e341f3"
          ],
          "parent": "1515fedca072442ad0656037229bce50b2e341f3",
          "refs": "task/task-1770909068463-2984dc",
          "branches": [
            "task/task-1770909068463-2984dc",
            "task/task-1770918400673-d21f34",
            "task/task-1770918401380-e8add6",
            "task/task-1770918400875-2630f2",
            "task/task-1770918401073-c21f64",
            "task/task-1770918401534-118872",
            "task/task-1770918401706-38620f",
            "task/task-1770918405559-058889"
          ]
        },
        "commitHash": "f504fb330085dd678241be890191ac269c049851",
        "lane": 2,
        "parentLinks": [
          {
            "hash": "1515fedca072442ad0656037229bce50b2e341f3",
            "lane": 0
          }
        ],
        "primaryBranchName": "task/task-1770909068463-2984dc",
        "branchColor": "#4fe8b8",
        "branchTags": [],
        "worktrees": [
          {
            "path": "/Users/yuyafujita/Projects/koma-fill/.worktrees/task-1770909068463-2984dc",
            "head": "f504fb330085dd678241be890191ac269c049851",
            "branch": "task/task-1770909068463-2984dc",
            "isMerged": true,
            "mergeCommitHash": "65530e0f6502c434a6bdd5af2933a64d422f3c94",
            "status": {
              "staged": [],
              "unstaged": [],
              "untracked": [],
              "capturedAt": 1770921960581
            },
            "normalizedPath": "/Users/yuyafujita/Projects/koma-fill/.worktrees/task-1770909068463-2984dc",
            "lane": 2
          }
        ],
        "index": 21
      },
      {
        "type": "unstaged",
        "label": " [task/task-1770909068262-a5d61b] (1)",
        "files": [
          "backend/data/.gitkeep"
        ],
        "branch": "task/task-1770909068262-a5d61b",
        "targetCommitHash": "1515fedca072442ad0656037229bce50b2e341f3",
        "worktreePath": "/Users/yuyafujita/Projects/koma-fill/.worktrees/task-1770909068262-a5d61b",
        "timestamp": 1770921960568,
        "sortOrder": 0,
        "lane": 9,
        "branchColor": "#e84f7f",
        "index": 22
      },
      {
        "type": "staged",
        "label": " [task/task-1770909068675-7f6691] (1)",
        "files": [
          "ackend/src/routes/manga.ts"
        ],
        "branch": "task/task-1770909068675-7f6691",
        "targetCommitHash": "1515fedca072442ad0656037229bce50b2e341f3",
        "worktreePath": "/Users/yuyafujita/Projects/koma-fill/.worktrees/task-1770909068675-7f6691",
        "timestamp": 1770921960581,
        "sortOrder": 1,
        "lane": 10,
        "branchColor": "#e8a84f",
        "index": 23
      },
      {
        "type": "anchor",
        "label": "[] CodexCLI1: # KAMUI-4D Parallel T",
        "branch": "task/task-1770909068262-a5d61b",
        "worktreePath": "/Users/yuyafujita/Projects/koma-fill/.worktrees/task-1770909068262-a5d61b",
        "parentCommitHash": "1515fedca072442ad0656037229bce50b2e341f3",
        "lane": 9,
        "isMerged": false,
        "mergeCommitHash": null,
        "statusChildren": [
          {
            "type": "unstaged",
            "label": " [task/task-1770909068262-a5d61b] (1)",
            "files": [
              "backend/data/.gitkeep"
            ],
            "branch": "task/task-1770909068262-a5d61b",
            "targetCommitHash": "1515fedca072442ad0656037229bce50b2e341f3",
            "worktreePath": "/Users/yuyafujita/Projects/koma-fill/.worktrees/task-1770909068262-a5d61b",
            "timestamp": 1770921960568,
            "sortOrder": 0,
            "lane": 9,
            "branchColor": "#e84f7f",
            "index": 22
          }
        ],
        "isDefaultWorktree": false,
        "renderMode": "node",
        "shouldHide": false,
        "tagLabel": "task/task-1770909068262-a5d61b",
        "taskId": "task-1770909068262-a5d61b",
        "taskStatus": "working",
        "taskStatusLabel": "",
        "taskName": "CodexCLI1: # KAMUI-4D Parallel Task Prompts for koma-fill\n## Manga Generation AI System - Multi-Agent Implementation Guide\n\n**Version:** 1.0\n**Project:** koma-fill - AI-powered manga panel generation system\n**Target:** KAMUI-4D Editor (Multi-AI CLI parallel execution)\n\n---\n\n## How to Use These Prompts in KAMUI-4D\n\nThis document contains **5 independent task prompts** designed to run in parallel across multiple AI coding agents. Each prompt is self-contained and can be executed independently without blocking other tasks.\n\n### Setup Instructions\n\n1. **Install dependencies** (run once before starting tasks):\n   ```bash\n   cd /mnt/Projects/koma-fill/backend\n   npm install\n\n   cd /mnt/Projects/koma-fill/frontend\n   npm install\n   ```\n\n2. **Environment Configuration**:\n   Create `/mnt/Projects/koma-fill/.env`:\n   ```\n   NODE_ENV=development\n   PORT=5000\n   BASE_URL=http://localhost:5000\n   OPENAI_API_KEY=your_openai_api_key_here\n   OPENAI_ORG_ID=your_org_id_optional\n   DATABASE_PATH=./data/koma-fill.db\n   STORAGE_PATH=./uploads\n   MAX_IMAGE_SIZE_MB=20\n   DALLE_RATE_LIMIT_PER_MINUTE=5\n   VISION_RATE_LIMIT_PER_MINUTE=30\n   MAX_RETRIES_PER_PANEL=3\n   ALLOWED_ORIGINS=http://localhost:3000\n   ```\n\n3. **Execution Strategy**:\n   - Copy each task prompt below into a separate KAMUI-4D session/agent\n   - **Tasks 1-5 can ALL start simultaneously** (no blocking dependencies)\n   - Each task should run independently in its own AI CLI session\n   - Monitor each agent's progress via console output\n   - **Integration testing** should happen after all 5 tasks complete (see bottom of doc)\n\n4. **Task Dependencies**:\n   ```\n   Task 1 (Backend)  provides database & API contracts\n   Task 2 (Vision)  uses Task 1's API, reads backend/src/models/types.ts\n   Task 3 (Images)  uses Task 1's API, reads backend/src/models/types.ts\n   Task 4 (Layout)  uses Task 1's API, reads backend/src/models/types.ts\n   Task 5 (Frontend)  calls Tasks 1-4 via REST API\n   ```\n   **All tasks can start immediately** - they communicate via file system and API contracts.\n\n---\n\n## Task 1: Backend (Agent A)\n### Express Server, SQLite Database & CRUD Routes Foundation\n\n**Time Estimate:** 45-60 minutes\n**Difficulty:** Intermediate\n**Dependencies:** None (this is the foundation layer)\n\n### Objective\nSet up a fully functional Express.js backend with SQLite database, implement CRUD operations for manga projects and panels, configure file upload handling with multer, and provide a solid API foundation for other agents to build upon.\n\n### Target Files to Create/Modify\n\n```\nbackend/\n src/\n    database/\n       connection.ts          [NEW] SQLite connection & initialization\n       schema.ts              [NEW] Table schema definitions\n    index.ts                   [MODIFY] Add DB initialization\n    app.ts                     [COMPLETE] Already done - verify middleware\n    routes/\n       manga.ts               [IMPLEMENT] Route handlers with DB calls\n    middleware/\n        errorHandler.ts        [VERIFY] Already complete\n uploads/                        [CREATE] Directory for image storage\n data/                           [CREATE] Directory for SQLite DB\n```\n\n### TypeScript Interfaces (from `/mnt/Projects/koma-fill/backend/src/models/types.ts`)\n\nKey types you'll use:\n```typescript\n// Core entities\nMangaProject {\n  id: string;                    // UUID\n  name: string;\n  description?: string;\n  status: ProjectStatus;         // 'draft' | 'analyzing' | 'generating' | 'complete' | 'exported'\n  layoutConfig: LayoutConfig;\n  generationSettings: GenerationSettings;\n  panels: Panel[];\n  keyImages: KeyImage[];\n  totalCost: number;\n  createdAt: string;             // ISO datetime\n  updatedAt: string;\n}\n\nPanel {\n  id: string;                    // UUID\n  projectId: string;\n  panelIndex: number;            // 0-based\n  imageUrl?: string;\n  imageFilePath?: string;\n  prompt?: string;\n  storyBeat?: string;\n  speechBubbleText?: string;\n  status: PanelStatus;           // 'pending' | 'generated' | 'failed' | 'placeholder'\n  retryCount: number;\n  generatedAt?: string;\n  createdAt: string;\n}\n\nKeyImage {\n  id: string;                    // UUID\n  projectId: string;\n  imageFilePath: string;\n  position: ImagePosition;       // 'start' | 'end' | number\n  analysis?: ImageAnalysis;\n  createdAt: string;\n}\n\nLayoutConfig {\n  totalPanels: number;           // 4, 6, 8, etc.\n  format: LayoutFormat;          // 'vertical' | 'horizontal' | 'square'\n  readingOrder: ReadingOrder;    // 'japanese' | 'western'\n  gutterSize: number;            // px\n  borderWidth: number;           // px\n  borderColor: string;           // hex #RRGGBB\n  backgroundColor: string;       // hex\n  pageWidth: number;             // px\n  pageHeight: number;            // px\n}\n\nGenerationSettings {\n  imageStyle: string;            // e.g., \"manga style, black and white ink\"\n  aspectRatio: 'square' | 'wide' | 'tall';\n  qualityLevel: 'standard' | 'hd';\n  negativePrompt?: string;\n  seed?: number;\n}\n```\n\n### Implementation Checklist\n\n#### 1. Create Database Connection Module (`backend/src/database/connection.ts`)\n```typescript\n// Requirements:\n- Initialize better-sqlite3 connection\n- Create/open database at DATABASE_PATH from .env\n- Export initDatabase() async function\n- Enable foreign keys constraint\n- Handle database file creation if needed\n- Connection should be cached/singleton\n```\n\n#### 2. Create Database Schema Module (`backend/src/database/schema.ts`)\n```typescript\n// SQL Schema Requirements:\nCREATE TABLE projects (\n  id TEXT PRIMARY KEY,\n  name TEXT NOT NULL,\n  description TEXT,\n  status TEXT NOT NULL,\n  layoutConfig JSON NOT NULL,\n  generationSettings JSON NOT NULL,\n  totalCost REAL DEFAULT 0,\n  createdAt TEXT NOT NULL,\n  updatedAt TEXT NOT NULL\n);\n\nCREATE TABLE panels (\n  id TEXT PRIMARY KEY,\n  projectId TEXT NOT NULL,\n  panelIndex INTEGER NOT NULL,\n  imageUrl TEXT,\n  imageFilePath TEXT,\n  prompt TEXT,\n  storyBeat TEXT,\n  speechBubbleText TEXT,\n  status TEXT NOT NULL,\n  retryCount INTEGER DEFAULT 0,\n  generatedAt TEXT,\n  createdAt TEXT NOT NULL,\n  FOREIGN KEY (projectId) REFERENCES projects(id)\n);\n\nCREATE TABLE keyImages (\n  id TEXT PRIMARY KEY,\n  projectId TEXT NOT NULL,\n  imageFilePath TEXT NOT NULL,\n  position TEXT NOT NULL,\n  analysis JSON,\n  createdAt TEXT NOT NULL,\n  FOREIGN KEY (projectId) REFERENCES projects(id)\n);\n\nCREATE INDEX idx_project_status ON projects(status);\nCREATE INDEX idx_panel_project ON panels(projectId);\nCREATE INDEX idx_panel_status ON panels(status);\n```\n\n#### 3. Modify `backend/src/index.ts`\n```typescript\n// Add:\n- Import { initDatabase } from './database/connection'\n- Call await initDatabase() before app.listen()\n- Log database initialization success\n```\n\n#### 4. Create Repository Layer (`backend/src/repositories/`)\n```typescript\n// Create:\n- ProjectRepository with methods:\n  - createProject(data: CreateMangaRequest): Promise<MangaProject>\n  - getProject(id: string): Promise<MangaProject | null>\n  - listProjects(limit: number, offset: number): Promise<MangaProject[]>\n  - updateProject(id: string, updates: Partial<MangaProject>): Promise<MangaProject>\n  - deleteProject(id: string): Promise<void>\n\n- PanelRepository with methods:\n  - createPanel(projectId: string, data: Panel): Promise<Panel>\n  - getPanelsByProject(projectId: string): Promise<Panel[]>\n  - getPanel(panelId: string): Promise<Panel | null>\n  - updatePanel(panelId: string, updates: Partial<Panel>): Promise<Panel>\n  - updatePanelStatus(panelId: string, status: PanelStatus): Promise<void>\n\n- KeyImageRepository with methods:\n  - createKeyImage(projectId: string, data: KeyImage): Promise<KeyImage>\n  - getKeyImages(projectId: string): Promise<KeyImage[]>\n  - updateKeyImageAnalysis(imageId: string, analysis: ImageAnalysis): Promise<void>\n```\n\n#### 5. Implement Routes in `backend/src/routes/manga.ts`\nReplace TODO comments with actual implementations:\n\n- **POST /api/manga/create**\n  - Validate CreateMangaRequest using Joi\n  - Generate unique project ID (uuid)\n  - Create project in database with 'draft' status\n  - Create initial panel records (count = layoutConfig.totalPanels)\n  - Return created MangaProject with 201 status\n\n- **POST /api/manga/:projectId/upload**\n  - Files already handled by multer middleware\n  - Save KeyImage records to database with file paths\n  - Store position information\n  - Return array of KeyImage objects\n\n- **GET /api/manga/:projectId**\n  - Fetch project + panels + key images from database\n  - Return complete MangaProject object\n  - Throw NotFoundError if project doesn't exist\n\n- **GET /api/manga**\n  - Implement pagination (limit/offset query params)\n  - Return array of projects\n  - Include total count header\n\n- **PUT /api/manga/:projectId/reorder**\n  - Parse ReorderPanelsRequest body\n  - Update panelIndex for each panel based on new order\n  - Return updated panels array\n\n### Testing Requirements\n\nAfter implementation, verify:\n\n```bash\n# 1. Database initialization\nnpm run dev\n# Check console: \" configured\" for database\n\n# 2. Create project\ncurl -X POST http://localhost:5000/api/manga/create \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\n    \"projectName\": \"Test Manga\",\n    \"storyPrompt\": \"A hero on a quest\",\n    \"layoutConfig\": { \"totalPanels\": 4 }\n  }'\n\n# 3. Get project\ncurl http://localhost:5000/api/manga/{projectId}\n\n# 4. Upload images\ncurl -X POST http://localhost:5000/api/manga/{projectId}/upload \\\n  -F \"images=@test1.jpg\" \\\n  -F \"images=@test2.jpg\"\n\n# 5. Check database\nsqlite3 data/koma-fill.db \"SELECT * FROM projects; SELECT * FROM panels;\"\n```\n\n### Files This Task Provides to Other Agents\n\n- **Database schema** - Tasks 2, 3, 4, 5 will read/write to these tables\n- **API contracts** - manga.ts route signatures that Tasks 2-4 will call\n- **File storage structure** - uploads/ directory path that Task 3 will use\n- **Type definitions** - already in backend/src/models/types.ts (reference only)\n\n### Output Validation Checklist\n\n- [ ] Database file created at `data/koma-fill.db`\n- [ ] All 3 tables created with correct schema\n- [ ] Repositories implement CRUD operations\n- [ ] All route handlers work without TODO comments\n- [ ] multer uploads save files to `uploads/` directory\n- [ ] POST /create returns 201 with MangaProject object\n- [ ] GET /:projectId returns full project with panels\n- [ ] Error handler catches and responds appropriately\n- [ ] No TypeScript compilation errors\n- [ ] npm run dev starts without errors\n\n---\n\n## Task 2: + (Agent B)\n### Vision API Integration & DALL-E Prompt Generation\n\n**Time Estimate:** 50-60 minutes\n**Difficulty:** Intermediate\n**Dependencies:** Task 1 (needs database & API routes available)\n\n### Objective\nImplement OpenAI Vision API integration to analyze uploaded key images and extract character/style information. Then implement story-to-panel prompt generation using GPT-4o to create DALL-E 3 compatible prompts that maintain consistency across panels.\n\n### Target Files to Create/Modify\n\n```\nbackend/\n src/\n     services/\n         imageAnalysisService.ts      [IMPLEMENT] Vision API analysis\n         promptGenerationService.ts   [CREATE] Story  panel prompts\n```\n\n### System Prompts (Already Provided)\n\nBoth vision analysis prompts are defined in `imageAnalysisService.ts`:\n- `QUICK_ANALYSIS_PROMPT` - fast, ~500 tokens\n- `DETAILED_ANALYSIS_PROMPT` - thorough, ~2000 tokens\n\nThese guide the Vision API to return structured JSON matching the `ImageAnalysis` interface.\n\n### TypeScript Interfaces\n\n```typescript\n// Input: Key image file path (from Task 1)\n// Output: ImageAnalysis object\n\nImageAnalysis {\n  description: string;\n  characters: CharacterInfo[];\n  objects: string[];\n  colors: string[];\n  composition: string;\n  mood: string;\n  artStyle: string;\n  suggestedTransitions: string[];\n}\n\nCharacterInfo {\n  name?: string;\n  appearance: string;        // detailed physical description\n  emotion: string;\n  position: string;          // screen position (e.g., \"center-left\")\n}\n\n// Panel prompt generation\nPanelPrompt {\n  panelIndex: number;\n  dallePrompt: string;       // Full DALL-E 3 prompt (100-300 words)\n  storyBeat: string;         // What happens in this panel\n  visualFocus: string;       // Main visual element\n  transitionType: TransitionType;  // 'cut' | 'pan' | 'zoom_in' | 'zoom_out' | 'fade' | 'action'\n  suggestedDialogue?: string;\n}\n```\n\n### Implementation Details\n\n#### ImageAnalysisService (`backend/src/services/imageAnalysisService.ts`)\n\n**Constructor:**\n```typescript\nconstructor() {\n  this.openai = new OpenAI({\n    apiKey: CONFIG.OPENAI_API_KEY,\n    organization: CONFIG.OPENAI_ORG_ID\n  });\n}\n```\n\n**Method: analyzeImage(imageBase64: string, depth: 'quick' | 'detailed')**\n- Input: Base64-encoded image data from KeyImage file\n- Implementation:\n  1. Read image file and convert to Base64 (if not already)\n  2. Call `this.openai.chat.completions.create()`:\n     - model: CONFIG.VISION_MODEL ('gpt-4o')\n     - messages: [\n       { role: 'system', content: QUICK_ANALYSIS_PROMPT or DETAILED_ANALYSIS_PROMPT }\n       { role: 'user', content: [\n         { type: 'image_url', image_url: { url: `data:image/png;base64,${imageBase64}` } }\n       ]}\n     ]\n     - response_format: { type: 'json_object' }\n     - max_tokens: depth === 'quick' ? 500 : 2000\n  3. Parse response.choices[0].message.content as JSON\n  4. Validate against ImageAnalysis schema\n  5. Return ImageAnalysis object\n\n**Method: analyzeMultiple(images, depth)**\n- Input: Array of { base64, position } objects\n- Use Promise.all with rate limiting (max CONFIG.VISION_RATE_LIMIT_PER_MINUTE calls/min)\n- Implement backoff if rate limited\n- Return array of ImageAnalysis objects\n\n**Method: extractCharacters(analysis)**\n- Optional: Deep-dive character extraction\n- Can call another Vision API pass if needed for more detail\n\n#### PromptGenerationService (NEW FILE - `backend/src/services/promptGenerationService.ts`)\n\n**Constructor:**\n```typescript\nconstructor() {\n  this.openai = new OpenAI({ apiKey: CONFIG.OPENAI_API_KEY });\n}\n```\n\n**Method: generatePanelPrompts(request: GeneratePromptsRequest)**\n\nInput:\n```typescript\nGeneratePromptsRequest {\n  storyPrompt: string;           // User's story\n  panelCount: number;            // Total panels to generate\n  characterConsistency: boolean; // Whether to maintain character consistency\n}\n```\n\nImplementation:\n1. **Story Breakdown Phase:**\n   - Call GPT-4o to split story into N panel beats\n   - System prompt should guide structure like:\n   ```\n   \"You are a manga story expert. Break the provided story into exactly {panelCount}\n    distinct visual beats. Each beat should be 1-2 sentences describing what happens\n    visually in that panel. Format as JSON array of objects with 'panelIndex' and 'beat' fields.\"\n   ```\n\n2. **Character Consistency Analysis:**\n   - If characterConsistency=true and keyImages were analyzed:\n     - Retrieve stored ImageAnalysis for key images\n     - Create character consistency profile (appearance, emotion arcs, etc.)\n     - Include in subsequent prompts\n\n3. **DALL-E 3 Prompt Generation:**\n   - For each story beat, create detailed DALL-E 3 prompt\n   - System prompt pattern:\n   ```\n   \"You are a DALL-E 3 prompt expert specializing in manga panels.\n    Given a story beat, generate a detailed visual prompt (100-300 words) that:\n    - Specifies art style: {generationSettings.imageStyle}\n    - Maintains character consistency: {characterProfile}\n    - Follows manga composition principles\n    - Uses specific visual terms (angle, lighting, pose, emotion)\n    - Avoids abstract concepts; be concrete and visual\n    - Follows DALL-E 3 content policy\n\n    Return JSON with: { dallePrompt, visualFocus, transitionType, suggestedDialogue }\"\n   ```\n\n4. **Transition Logic:**\n   - Analyze flow between consecutive beats\n   - Suggest transition type ('cut', 'pan', 'zoom_in', etc.)\n   - Update imageUrl in previous panel to support transitions\n\n5. **Return Value:**\n   - Array of PanelPrompt objects, one per panel\n   - Each with populated dallePrompt, storyBeat, visualFocus, transitionType\n\n### Database Integration\n\nAfter generating prompts, save to Panel table:\n- Update each panel's `prompt` field with `dallePrompt`\n- Update `storyBeat` field\n- Update `status` to 'pending' (ready for image generation)\n\n### API Integration\n\nImplement route handlers in `backend/src/routes/manga.ts`:\n\n**POST /api/manga/:projectId/analyze**\n```typescript\n// 1. Fetch project and keyImages from DB\n// 2. Read image files and convert to Base64\n// 3. Call imageAnalysisService.analyzeMultiple()\n// 4. Store analysis results in DB (keyImages.analysis)\n// 5. Update project status to 'analyzing'  'complete'\n// 6. Return analysis results\n```\n\n**POST /api/manga/:projectId/generate-prompts**\n```typescript\n// 1. Validate GeneratePromptsRequest\n// 2. Fetch project and keyImages analyses from DB\n// 3. Call promptGenerationService.generatePanelPrompts()\n// 4. Update panel records with generated prompts\n// 5. Update project status to 'generating'\n// 6. Return array of PanelPrompt objects\n```\n\n### Testing Requirements\n\n```bash\n# 1. Prepare test image\n# (Use any PNG/JPG with a character or scene)\n\n# 2. Create project and upload image (Task 1)\nPROJECT_ID=$(curl -s -X POST http://localhost:5000/api/manga/create \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"projectName\":\"Test\",\"storyPrompt\":\"A hero finds treasure\"}' | jq -r '.id')\n\n# 3. Upload test image\ncurl -X POST http://localhost:5000/api/manga/$PROJECT_ID/upload \\\n  -F \"images=@test_image.jpg\"\n\n# 4. Analyze images\ncurl -X POST http://localhost:5000/api/manga/$PROJECT_ID/analyze \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"analysisDepth\":\"quick\"}'\n\n# 5. Generate prompts\ncurl -X POST http://localhost:5000/api/manga/$PROJECT_ID/generate-prompts \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\n    \"storyPrompt\": \"A hero finds treasure in a dark cave\",\n    \"panelCount\": 4,\n    \"characterConsistency\": true\n  }'\n\n# 6. Verify output\ncurl http://localhost:5000/api/manga/$PROJECT_ID | jq '.panels[].prompt'\n```\n\n### Files This Task Provides to Other Agents\n\n- **Panel prompt data** - Stored in DB panels table, used by Task 3 for image generation\n- **Character analysis** - Used by Task 5 frontend for display\n- **Art style consistency** - Guides Task 3's image generation\n\n### Output Validation Checklist\n\n- [ ] ImageAnalysisService.analyzeImage() calls Vision API successfully\n- [ ] Vision API responses parse correctly to ImageAnalysis\n- [ ] PromptGenerationService generates DALL-E-compatible prompts\n- [ ] Panel prompts maintain character consistency (if enabled)\n- [ ] Transition types are correctly assigned\n- [ ] All panel records updated in database with prompts\n- [ ] /analyze endpoint returns ImageAnalysis array\n- [ ] /generate-prompts endpoint returns PanelPrompt array\n- [ ] Error handling for API failures (rate limits, auth, etc.)\n- [ ] No TypeScript compilation errors\n\n---\n\n## Task 3: DALL-E 3 (Agent C)\n### Image Generation with Retry Logic & Progress Streaming\n\n**Time Estimate:** 50-70 minutes\n**Difficulty:** Intermediate-Advanced\n**Dependencies:** Task 1 (DB & API), Task 2 (panel prompts)\n\n### Objective\nImplement DALL-E 3 image generation with robust error handling, exponential backoff retry logic, local image storage, Server-Sent Events (SSE) streaming for real-time progress updates, and cost tracking per API call.\n\n### Target Files to Create/Modify\n\n```\nbackend/\n src/\n     services/\n         imageGenerationService.ts    [IMPLEMENT] DALL-E 3 API integration\n         (imageProcessor.ts)          [REFERENCE] Utility for image processing\n```\n\n### TypeScript Interfaces\n\n```typescript\nGeneratedPanel {\n  panelIndex: number;\n  imageUrl: string;              // DALL-E public URL (temporary)\n  localFilePath: string;         // /uploads/{projectId}/panel_{index}.png\n  prompt: string;                // Original prompt sent\n  revisedPrompt?: string;        // DALL-E 3's revised prompt (if modified)\n  costUsd: number;               // API call cost\n}\n\n// Request type\nGenerateImagesRequest {\n  panelIndices?: number[];       // undefined = all panels\n  batchMode: 'sequential' | 'parallel';\n}\n\n// Progress event (sent via SSE)\nProgressEvent {\n  type: 'progress' | 'complete' | 'error';\n  stage: string;                 // 'generating_images'\n  currentStep: number;           // Current panel index\n  totalSteps: number;            // Total panels\n  percentage: number;            // 0-100\n  message: string;               // Human-readable status\n  panelId?: string;\n  panelIndex?: number;\n  error?: string;                // Error message if type='error'\n}\n```\n\n### Implementation Details\n\n#### ImageGenerationService (`backend/src/services/imageGenerationService.ts`)\n\n**Constructor & Initialization:**\n```typescript\nconstructor() {\n  this.openai = new OpenAI({ apiKey: CONFIG.OPENAI_API_KEY });\n  this.uploadDir = path.resolve(CONFIG.STORAGE_PATH);\n}\n```\n\n**Method: generatePanel() - Single Panel Generation**\n\n```typescript\nasync generatePanel(\n  prompt: string,\n  panelIndex: number,\n  projectId: string,\n  settings?: GenerationSettings\n): Promise<GeneratedPanel>\n```\n\nImplementation:\n1. **Image Size Calculation:**\n   - Map aspectRatio to DALL-E 3 size:\n     - 'square'  '1024x1024'\n     - 'wide'  '1792x1024'\n     - 'tall'  '1024x1792'\n\n2. **API Call (with retry logic in wrapper):**\n   ```typescript\n   const response = await this.openai.images.generate({\n     model: CONFIG.DALLE_MODEL,           // 'dall-e-3'\n     prompt: prompt,\n     n: 1,\n     size: size,\n     quality: settings?.qualityLevel === 'hd' ? 'hd' : 'standard',\n     style: 'natural',                    // or 'vivid' for more dramatic\n   });\n   ```\n\n3. **Extract Response Data:**\n   - imageUrl = response.data[0].url\n   - revisedPrompt = response.data[0].revised_prompt\n   - Calculate cost based on settings.qualityLevel:\n     - standard: $0.040 per image\n     - hd: $0.080 per image\n\n4. **Download & Save Image:**\n   - Call this.downloadAndSave(imageUrl, projectId, panelIndex)\n   - Saves as PNG: `{STORAGE_PATH}/{projectId}/panel_{panelIndex}.png`\n   - Returns localFilePath\n\n5. **Return GeneratedPanel object**\n\n**Method: generateBatch() - Batch Generation with Mode Selection**\n\n```typescript\nasync generateBatch(\n  panelPrompts: PanelPrompt[],\n  projectId: string,\n  batchMode: 'sequential' | 'parallel',\n  settings?: GenerationSettings,\n  onProgress?: (event: ProgressEvent) => void\n): Promise<GeneratedPanel[]>\n```\n\nImplementation:\n1. Validate inputs\n2. Route to sequential or parallel handler\n3. Call onProgress callback with progress events\n4. Return array of GeneratedPanel\n\n**Method: generateSequential() - Rate-Limit Friendly**\n\n```typescript\nprivate async generateSequential(\n  panelPrompts: PanelPrompt[],\n  projectId: string,\n  settings?: GenerationSettings,\n  onProgress?: (event: ProgressEvent) => void\n): Promise<GeneratedPanel[]>\n```\n\nImplementation:\n1. Initialize results array\n2. For each panelPrompt (with index):\n   a. Call generatePanelWithRetry(panelPrompt, projectId, settings)\n   b. On success:\n      - Add to results array\n      - Call onProgress with percentage = (index + 1) / total * 100\n   c. On failure (after max retries):\n      - Update panel status to 'failed' in DB\n      - Log error\n      - Continue to next panel\n\n3. Return results array (may include failed panels with status='failed')\n\n**Method: generateParallel() - High Speed (Rate Limit Aware)**\n\n```typescript\nprivate async generateParallel(\n  panelPrompts: PanelPrompt[],\n  projectId: string,\n  settings?: GenerationSettings,\n  onProgress?: (event: ProgressEvent) => void\n): Promise<GeneratedPanel[]>\n```\n\nImplementation:\n1. **Batch Control:**\n   - Max concurrent = Math.floor(CONFIG.DALLE_RATE_LIMIT_PER_MINUTE / 2)\n   - Split panelPrompts into batches of max concurrent\n\n2. **For each batch:**\n   - Create Promise.allSettled() for batch\n   - Wait for all to settle\n   - Process results\n   - Send progress update to onProgress\n   - Delay before next batch (respect rate limits)\n\n3. **Failure Handling:**\n   - Collect failed panels\n   - Retry failed panels sequentially (exponential backoff)\n   - Update onProgress for retries\n\n4. **Return results array**\n\n**Method: generatePanelWithRetry() - Core Retry Logic**\n\n```typescript\nprivate async generatePanelWithRetry(\n  panelPrompt: PanelPrompt,\n  projectId: string,\n  settings?: GenerationSettings,\n  retryCount: number = 0\n): Promise<GeneratedPanel>\n```\n\nImplementation:\n1. Try to generate panel via generatePanel()\n2. On success: Return GeneratedPanel\n3. On failure:\n   - If retryCount < CONFIG.MAX_RETRIES_PER_PANEL:\n     - Calculate backoff delay: 2^retryCount * 1000ms (exponential)\n     - Wait for delay\n     - Recursively call with retryCount++\n   - If max retries exceeded:\n     - Throw error with panel index info\n\n**Exponential Backoff Formula:**\n```\ndelay(attempt) = base_delay * (2 ^ attempt) + random jitter\ndelay(0) = 1000ms (1 second)\ndelay(1) = 2000ms (2 seconds)\ndelay(2) = 4000ms (4 seconds)\n+ add random(0, 500ms) jitter to avoid thundering herd\n```\n\n**Method: downloadAndSave() - Store Images Locally**\n\n```typescript\nprivate async downloadAndSave(\n  imageUrl: string,\n  projectId: string,\n  panelIndex: number\n): Promise<string>\n```\n\nImplementation:\n1. Create project uploads directory if not exists: `{STORAGE_PATH}/{projectId}/`\n2. Fetch image from URL using axios or native fetch:\n   ```typescript\n   const response = await fetch(imageUrl);\n   const arrayBuffer = await response.arrayBuffer();\n   const buffer = Buffer.from(arrayBuffer);\n   ```\n3. Save to disk:\n   ```typescript\n   const filePath = path.join(this.uploadDir, projectId, `panel_${panelIndex}.png`);\n   await fs.writeFile(filePath, buffer);\n   ```\n4. Return relative or absolute path\n\n**Method: getImageSize() - Aspect Ratio to DALL-E Size**\n\n```typescript\nprivate getImageSize(\n  aspectRatio: string\n): '1024x1024' | '1792x1024' | '1024x1792'\n```\n\nSelf-explanatory mapping function.\n\n### Route Handler Integration\n\nImplement in `backend/src/routes/manga.ts`:\n\n**POST /api/manga/:projectId/generate-images - SSE Streaming**\n\n```typescript\nrouter.post('/:projectId/generate-images', async (req, res, next) => {\n  try {\n    const { projectId } = req.params;\n    const { panelIndices, batchMode } = req.body as GenerateImagesRequest;\n\n    // Set up SSE response\n    res.setHeader('Content-Type', 'text/event-stream');\n    res.setHeader('Cache-Control', 'no-cache');\n    res.setHeader('Connection', 'keep-alive');\n\n    // Fetch project and panels from DB\n    const project = await getProject(projectId);\n    if (!project) throw new NotFoundError('Project');\n\n    // Filter panels (all or specific indices)\n    const panelsToGenerate = project.panels.filter(\n      p => !panelIndices || panelIndices.includes(p.panelIndex)\n    );\n\n    // Generate prompts array\n    const panelPrompts: PanelPrompt[] = panelsToGenerate.map(p => ({\n      panelIndex: p.panelIndex,\n      dallePrompt: p.prompt!,\n      storyBeat: p.storyBeat!,\n      visualFocus: 'main subject',  // Extract from context if available\n      transitionType: 'cut',        // Default, could be from DB\n    }));\n\n    // Call imageGenerationService\n    imageGenService.generateBatch(\n      panelPrompts,\n      projectId,\n      batchMode,\n      project.generationSettings,\n      (progressEvent) => {\n        // Send progress as SSE\n        res.write(`data: ${JSON.stringify(progressEvent)}\\n\\n`);\n      }\n    ).then(generatedPanels => {\n      // Update database with generated images\n      for (const panel of generatedPanels) {\n        updatePanelImage(panel.panelIndex, {\n          imageUrl: panel.imageUrl,\n          imageFilePath: panel.localFilePath,\n          revisedPrompt: panel.revisedPrompt,\n          status: panel.revisedPrompt ? 'generated' : 'generated',\n        });\n      }\n\n      // Send completion event\n      res.write(`data: ${JSON.stringify({\n        type: 'complete',\n        message: 'Image generation complete',\n        totalCost: generatedPanels.reduce((sum, p) => sum + p.costUsd, 0),\n      })}\\n\\n`);\n\n      res.end();\n    }).catch(err => {\n      res.write(`data: ${JSON.stringify({\n        type: 'error',\n        message: err.message,\n      })}\\n\\n`);\n      res.end();\n    });\n  } catch (err) {\n    next(err);\n  }\n});\n```\n\n### Cost Tracking\n\n**Implementation:**\n- Track cost per API call in GeneratedPanel.costUsd\n- Sum across all panels: `totalCost = sum(generatedPanels.map(p => p.costUsd))`\n- Update project.totalCost in DB: `project.totalCost += generatedPanels totalCost`\n- Log costs for each call (useful for budget monitoring)\n\n**Cost Constants (from types.ts):**\n```typescript\nAPI_COSTS = {\n  VISION_PER_CALL: 0.025,    // GPT-4V\n  DALLE3_STANDARD: 0.040,    // per image\n  DALLE3_HD: 0.080,          // per image\n}\n```\n\n### Testing Requirements\n\n```bash\n# 1. Set up test project (with prompts from Task 2)\nPROJECT_ID=\"test-project-id\"\n# Or use output from Task 2 test\n\n# 2. Generate images (sequential mode)\ncurl -X POST http://localhost:5000/api/manga/$PROJECT_ID/generate-images \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"batchMode\": \"sequential\"}' \\\n  -H \"Accept: text/event-stream\"\n\n# 3. Verify local image files created\nls -la uploads/$PROJECT_ID/\n\n# 4. Check database for updated image URLs\nsqlite3 data/koma-fill.db \"SELECT panelIndex, imageFilePath, status FROM panels WHERE projectId='$PROJECT_ID';\"\n\n# 5. Verify cost tracking\ncurl http://localhost:5000/api/manga/$PROJECT_ID | jq '.totalCost'\n```\n\n### Files This Task Provides to Other Agents\n\n- **Generated panel images** - Stored in uploads/{projectId}/, used by Task 4\n- **Image file paths** - Updated in DB, used by Task 4 for layout composition\n- **Cost tracking** - Used by frontend for budget display\n\n### Output Validation Checklist\n\n- [ ] DALL-E 3 API calls succeed with valid prompts\n- [ ] Retry logic works with exponential backoff\n- [ ] Images download and save to {STORAGE_PATH}/{projectId}/\n- [ ] SSE streaming sends progress events correctly\n- [ ] onProgress callback fires with accurate percentage\n- [ ] Cost calculation correct (0.04 standard, 0.08 HD)\n- [ ] Panel records updated with imageUrl and imageFilePath\n- [ ] Sequential and parallel modes both work\n- [ ] Rate limiting respected (max 5 calls/min by default)\n- [ ] Error handling for network issues, API failures\n- [ ] No TypeScript compilation errors\n\n---\n\n## Task 4: + (Agent D)\n### Manga Layout Composition & Multi-Format Export\n\n**Time Estimate:** 45-60 minutes\n**Difficulty:** Intermediate (Sharp library learning curve)\n**Dependencies:** Task 1 (DB), Task 3 (generated images)\n\n### Objective\nImplement Sharp-based manga layout composition with grid calculation, panel resizing and positioning, border/gutter rendering, speech bubble overlay, and PNG/JPG/PDF export functionality.\n\n### Target Files to Create/Modify\n\n```\nbackend/\n src/\n     services/\n        layoutEngine.ts          [IMPLEMENT] Panel composition & layout\n        exportService.ts         [CREATE] PNG/JPG/PDF export\n     utils/\n         imageProcessor.ts        [HELPER] Image processing utilities\n```\n\n### TypeScript Interfaces\n\n```typescript\n// Layout composition result\nComposedLayout {\n  buffer: Buffer;                    // PNG image buffer\n  width: number;                     // Page width (px)\n  height: number;                    // Page height (px)\n  format: 'png';\n  panelPositions: PanelPosition[];   // Position data for each panel\n}\n\nPanelPosition {\n  panelIndex: number;\n  x: number;                         // Offset from top-left (px)\n  y: number;\n  width: number;                     // Panel width (px)\n  height: number;                    // Panel height (px)\n}\n\n// Input to layout engine\nLayoutConfig {\n  totalPanels: number;               // 4, 6, 8, etc.\n  format: LayoutFormat;              // 'vertical' | 'horizontal' | 'square'\n  readingOrder: ReadingOrder;        // 'japanese' | 'western'\n  gutterSize: number;                // Space between panels (px)\n  borderWidth: number;               // Panel border thickness (px)\n  borderColor: string;               // Hex color\n  backgroundColor: string;           // Hex color\n  pageWidth: number;                 // Canvas width (px)\n  pageHeight: number;                // Canvas height (px)\n}\n```\n\n### Implementation Details\n\n#### LayoutEngine (`backend/src/services/layoutEngine.ts`)\n\n**Method: composePanels() - Main Composition Function**\n\n```typescript\nasync composePanels(\n  panelImagePaths: string[],\n  config: LayoutConfig = DEFAULT_LAYOUT_CONFIG\n): Promise<ComposedLayout>\n```\n\nImplementation Steps:\n\n1. **Calculate Grid:**\n   ```typescript\n   const grid = this.calculateGrid(panelImagePaths.length, config);\n   // Returns { cols: number, rows: number }\n   ```\n   Already implemented - use it.\n\n2. **Calculate Panel Positions:**\n   ```typescript\n   const positions = this.calculatePanelPositions(grid, config);\n   // Returns: PanelPosition[] with x, y, width, height for each panel\n   ```\n   Already implemented - use it.\n\n3. **Create Background Canvas:**\n   ```typescript\n   import sharp from 'sharp';\n\n   let canvas = sharp({\n     create: {\n       width: config.pageWidth,\n       height: config.pageHeight,\n       channels: 4,                    // RGBA\n       background: config.backgroundColor,  // Parsed from hex\n     }\n   });\n   ```\n\n4. **Load & Resize Panel Images:**\n   ```typescript\n   const composites = await Promise.all(\n     panelImagePaths.map(async (imgPath, i) => {\n       if (!fs.existsSync(imgPath)) {\n         throw new Error(`Panel image not found: ${imgPath}`);\n       }\n\n       const position = positions[i];\n       const resized = await sharp(imgPath)\n         .resize(position.width, position.height, {\n           fit: 'cover',              // Fill panel, crop if needed\n           withoutEnlargement: false\n         })\n         .toBuffer();\n\n       return {\n         input: resized,\n         left: position.x,\n         top: position.y\n       };\n     })\n   );\n   ```\n\n5. **Composite Panels Onto Canvas:**\n   ```typescript\n   let result = await canvas.composite(composites).png();\n   ```\n\n6. **Add Borders (Optional - if borderWidth > 0):**\n   - Use SVG overlay to draw rectangles around each panel\n   - Create SVG:\n     ```svg\n     <svg width=\"800\" height=\"1200\">\n       <!-- For each panel position -->\n       <rect x=\"10\" y=\"10\" width=\"390\" height=\"590\"\n             fill=\"none\" stroke=\"black\" stroke-width=\"2\" />\n     </svg>\n     ```\n   - Composite SVG overlay:\n     ```typescript\n     const borderSvg = this.generateBorderSvg(positions, config);\n     result = await result.composite([{\n       input: borderSvg,\n       top: 0,\n       left: 0\n     }]);\n     ```\n\n7. **Return ComposedLayout:**\n   ```typescript\n   const buffer = await result.toBuffer();\n   return {\n     buffer,\n     width: config.pageWidth,\n     height: config.pageHeight,\n     format: 'png',\n     panelPositions: positions\n   };\n   ```\n\n**Method: addSpeechBubbles() - Overlay Speech Bubbles**\n\n```typescript\nasync addSpeechBubbles(\n  layout: ComposedLayout,\n  bubbles: SpeechBubble[]\n): Promise<ComposedLayout>\n```\n\nImplementation:\n\n1. **For each speech bubble:**\n   - Get panel position from layout.panelPositions[bubble.panelIndex]\n   - Calculate bubble position within panel:\n     - 'top'  y = panel.y + 30\n     - 'middle'  y = panel.y + panel.height/2 - 30\n     - 'bottom'  y = panel.y + panel.height - 60\n\n2. **Create SVG speech bubble:**\n   ```typescript\n   const svg = this.generateSpeechBubbleSvg(bubble, position, style);\n   // Generates SVG with text, shape varies by style:\n   // 'rounded', 'cloud', 'spiked', 'rectangular'\n   ```\n\n3. **Composite all bubble SVGs:**\n   ```typescript\n   let result = sharp(layout.buffer);\n   const bubbleSvgs = bubbles.map((bubble, idx) =>\n     this.generateSpeechBubbleSvg(bubble, panelPositions[bubble.panelIndex])\n   );\n\n   result = await result.composite(\n     bubbleSvgs.map((svg, i) => ({ input: svg }))\n   );\n   ```\n\n4. **Return updated ComposedLayout**\n\n**Helper: generateBorderSvg()**\n```typescript\nprivate generateBorderSvg(\n  positions: PanelPosition[],\n  config: LayoutConfig\n): Buffer\n```\n\nGenerate SVG with rectangle borders around each panel:\n```svg\n<svg width=\"800\" height=\"1200\">\n  <rect x=\"10\" y=\"10\" width=\"390\" height=\"590\"\n        fill=\"none\" stroke=\"#000000\" stroke-width=\"2\" />\n  <!-- repeated for each panel -->\n</svg>\n```\n\nConvert to Buffer and return.\n\n**Helper: generateSpeechBubbleSvg()**\n```typescript\nprivate generateSpeechBubbleSvg(\n  bubble: SpeechBubble,\n  panelPosition: PanelPosition,\n  targetY: number  // top/middle/bottom\n): Buffer\n```\n\nGenerate SVG with speech bubble shape. Example for 'rounded':\n```svg\n<svg width=\"300\" height=\"100\">\n  <!-- Rounded rectangle -->\n  <path d=\"M 10,10 Q 10,10 20,10 L 270,10 Q 280,10 280,20 L 280,70 Q 280,80 270,80 L 30,80 Q 20,80 20,70 L 20,40 L 0,60 L 20,50 L 20,20 Q 20,10 10,10\"\n        fill=\"white\" stroke=\"black\" stroke-width=\"1\" />\n  <text x=\"20\" y=\"50\" font-family=\"Arial\" font-size=\"14\">Your text here</text>\n</svg>\n```\n\nReturn SVG as Buffer via:\n```typescript\nconst svgBuffer = Buffer.from(svgString, 'utf-8');\n```\n\n### ExportService (`backend/src/services/exportService.ts`) - NEW FILE\n\nImplement export to PNG, JPG, PDF formats.\n\n```typescript\nexport class ExportService {\n  async exportPNG(\n    layout: ComposedLayout,\n    filepath: string,\n    compression: 'low' | 'medium' | 'high'\n  ): Promise<void>\n\n  async exportJPG(\n    layout: ComposedLayout,\n    filepath: string,\n    quality: number  // 60-95\n  ): Promise<void>\n\n  async exportPDF(\n    layout: ComposedLayout,\n    filepath: string,\n    metadata: { title?: string; author?: string }\n  ): Promise<void>\n}\n```\n\n**exportPNG():**\n```typescript\nasync exportPNG(layout, filepath, compression) {\n  const compressionLevel = compression === 'high' ? 9 : compression === 'medium' ? 6 : 1;\n  await sharp(layout.buffer)\n    .png({ compressionLevel })\n    .toFile(filepath);\n}\n```\n\n**exportJPG():**\n```typescript\nasync exportJPG(layout, filepath, quality = 80) {\n  await sharp(layout.buffer)\n    .jpeg({ quality, mozjpeg: true })\n    .toFile(filepath);\n}\n```\n\n**exportPDF():**\nRequires pdfkit library:\n```typescript\nimport PDFDocument from 'pdfkit';\nimport { createWriteStream } from 'fs';\n\nasync exportPDF(layout, filepath, metadata = {}) {\n  const doc = new PDFDocument({\n    size: [layout.width, layout.height]\n  });\n\n  if (metadata.title) doc.title(metadata.title);\n  if (metadata.author) doc.author(metadata.author);\n\n  // Add image to PDF\n  doc.image(layout.buffer, 0, 0, {\n    width: layout.width,\n    height: layout.height\n  });\n\n  doc.pipe(createWriteStream(filepath));\n  doc.end();\n}\n```\n\n### Route Handler Integration\n\nImplement in `backend/src/routes/manga.ts`:\n\n**POST /api/manga/:projectId/layout**\n```typescript\nrouter.post('/:projectId/layout', async (req: Request, res: Response, next: NextFunction) => {\n  try {\n    const { projectId } = req.params;\n    const { speechBubbles } = req.body as GenerateLayoutRequest;\n\n    // Fetch project and panels from DB\n    const project = await getProject(projectId);\n    if (!project) throw new NotFoundError('Project');\n\n    // Get panel image paths\n    const panelPaths = project.panels\n      .sort((a, b) => a.panelIndex - b.panelIndex)\n      .map(p => p.imageFilePath)\n      .filter(path => path !== undefined);\n\n    // Compose layout\n    const layoutEngine = new LayoutEngine();\n    let layout = await layoutEngine.composePanels(panelPaths, project.layoutConfig);\n\n    // Add speech bubbles if provided\n    if (speechBubbles && speechBubbles.length > 0) {\n      layout = await layoutEngine.addSpeechBubbles(layout, speechBubbles);\n    }\n\n    // Save layout buffer to temporary file for preview\n    const layoutPath = path.join(CONFIG.STORAGE_PATH, projectId, 'layout.png');\n    await fs.writeFile(layoutPath, layout.buffer);\n\n    // Update project status\n    await updateProject(projectId, { status: 'complete' });\n\n    // Return layout info\n    res.json({\n      message: 'Layout composed successfully',\n      projectId,\n      layoutPath: `/uploads/${projectId}/layout.png`,\n      panelPositions: layout.panelPositions,\n      dimensions: { width: layout.width, height: layout.height }\n    });\n  } catch (err) {\n    next(err);\n  }\n});\n```\n\n**POST /api/manga/:projectId/export**\n```typescript\nrouter.post('/:projectId/export', async (req: Request, res: Response, next: NextFunction) => {\n  try {\n    const { projectId } = req.params;\n    const { format, compression, resolution, title, author } = req.body as ExportRequest;\n\n    // Fetch project layout\n    const layoutPath = path.join(CONFIG.STORAGE_PATH, projectId, 'layout.png');\n    if (!fs.existsSync(layoutPath)) {\n      throw new Error('Layout not yet generated. Call /layout endpoint first.');\n    }\n\n    const layoutBuffer = await fs.promises.readFile(layoutPath);\n    const layout: ComposedLayout = {\n      buffer: layoutBuffer,\n      width: 800,  // From project.layoutConfig\n      height: 1200,\n      format: 'png',\n      panelPositions: []  // Could fetch from DB if needed\n    };\n\n    // Export to requested format\n    const exportService = new ExportService();\n    const timestamp = Date.now();\n    const exportPath = path.join(CONFIG.STORAGE_PATH, projectId, `manga_${timestamp}.${format}`);\n\n    if (format === 'png') {\n      await exportService.exportPNG(layout, exportPath, compression as 'low' | 'medium' | 'high');\n    } else if (format === 'jpg') {\n      const qualityMap = { low: 60, medium: 80, high: 95 };\n      await exportService.exportJPG(layout, exportPath, qualityMap[compression]);\n    } else if (format === 'pdf') {\n      await exportService.exportPDF(layout, exportPath, { title, author });\n    }\n\n    // Update project status\n    await updateProject(projectId, { status: 'exported' });\n\n    res.json({\n      message: 'Export successful',\n      projectId,\n      format,\n      downloadUrl: `/uploads/${projectId}/manga_${timestamp}.${format}`,\n      filePath: exportPath\n    });\n  } catch (err) {\n    next(err);\n  }\n});\n```\n\n### Testing Requirements\n\n```bash\n# 1. Generate layout from Task 3 images\nPROJECT_ID=\"test-project-id\"\ncurl -X POST http://localhost:5000/api/manga/$PROJECT_ID/layout \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\n    \"speechBubbles\": [\n      {\n        \"panelIndex\": 0,\n        \"text\": \"Wow!\",\n        \"position\": \"top\",\n        \"style\": \"rounded\"\n      }\n    ]\n  }'\n\n# 2. View composed layout\nopen http://localhost:5000/uploads/$PROJECT_ID/layout.png\n\n# 3. Export to PNG\ncurl -X POST http://localhost:5000/api/manga/$PROJECT_ID/export \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\n    \"format\": \"png\",\n    \"compression\": \"medium\",\n    \"resolution\": \"web\",\n    \"title\": \"My Manga\"\n  }'\n\n# 4. Export to PDF\ncurl -X POST http://localhost:5000/api/manga/$PROJECT_ID/export \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\n    \"format\": \"pdf\",\n    \"compression\": \"medium\",\n    \"title\": \"My Manga\",\n    \"author\": \"AI Creator\"\n  }'\n\n# 5. Verify files exist\nls -lh uploads/$PROJECT_ID/\n```\n\n### Files This Task Provides to Other Agents\n\n- **Composed layout image** - Used by frontend for preview\n- **Export files** - PNG/JPG/PDF outputs for download\n- **Layout metadata** - Panel positions for debugging/display\n\n### Output Validation Checklist\n\n- [ ] calculateGrid() and calculatePanelPositions() methods work correctly\n- [ ] composePanels() successfully combines images with sharp\n- [ ] Borders render correctly around panels\n- [ ] Speech bubbles overlay without distortion\n- [ ] Multiple speech bubble styles work ('rounded', 'cloud', 'spiked', 'rectangular')\n- [ ] Layout PNG saved and readable\n- [ ] exportPNG() produces valid PNG files\n- [ ] exportJPG() produces valid JPG files with quality control\n- [ ] exportPDF() produces valid PDF with metadata\n- [ ] /layout endpoint returns correct panel positions\n- [ ] /export endpoint returns download URLs\n- [ ] Compression settings affect file size appropriately\n- [ ] No TypeScript compilation errors\n\n---\n\n## Task 5: React (Agent E)\n### Complete React UI with Component Implementation\n\n**Time Estimate:** 60-80 minutes\n**Difficulty:** Intermediate (React component patterns)\n**Dependencies:** Tasks 1-4 (backend API must be running)\n\n### Objective\nComplete all React components for the koma-fill frontend including image upload with drag-drop, story prompt editor, panel grid with drag-and-drop reordering, complete manga generation workflow orchestration, real-time SSE progress updates, and multi-format export options. Configure Tailwind CSS for styling.\n\n### Target Files to Create/Modify\n\n```\nfrontend/\n src/\n    components/\n       ImageUploader.tsx           [IMPLEMENT] Dropzone with position selector\n       StoryPromptEditor.tsx       [ENHANCE] Add sample prompts\n       PanelGrid.tsx               [IMPLEMENT] Drag-and-drop reordering\n       LayoutSelector.tsx          [VERIFY] Layout config UI\n       ExportOptions.tsx           [VERIFY] Export format selection\n       ProgressBar.tsx             [CREATE] Real-time progress display\n    hooks/\n       useMangaGeneration.ts       [IMPLEMENT] Full workflow orchestration\n    services/\n       apiClient.ts                [IMPLEMENT] API client with SSE support\n    pages/\n       CreateMangaPage.tsx         [IMPLEMENT] Main workflow page\n       PreviewPage.tsx             [IMPLEMENT] Result preview & download\n    App.tsx                         [UPDATE] Routing\n    main.tsx                        [VERIFY] Entry point\n    index.css                       [UPDATE] Tailwind directives\n tailwind.config.js                  [CREATE] Tailwind configuration\n postcss.config.js                   [CREATE] PostCSS configuration\n package.json                        [UPDATE] Add Tailwind dependencies\n tsconfig.json                       [VERIFY] TypeScript config\n```\n\n### TypeScript Interfaces (from `frontend/src/types/index.ts`)\n\nAlready defined - reference for component props.\n\n### Implementation Details\n\n#### 1. Tailwind CSS Setup\n\n**Install Dependencies:**\n```bash\ncd frontend\nnpm install -D tailwindcss postcss autoprefixer\nnpx tailwindcss init -p\n```\n\n**tailwind.config.js:**\n```javascript\nexport default {\n  content: [\n    './index.html',\n    './src/**/*.{js,ts,jsx,tsx}',\n  ],\n  theme: {\n    extend: {\n      colors: {\n        manga: {\n          dark: '#1a1a1a',\n          light: '#f5f5f5',\n        }\n      }\n    },\n  },\n  plugins: [],\n}\n```\n\n**postcss.config.js:**\n```javascript\nexport default {\n  plugins: {\n    tailwindcss: {},\n    autoprefixer: {},\n  },\n}\n```\n\n**frontend/src/index.css:**\n```css\n@tailwind base;\n@tailwind components;\n@tailwind utilities;\n\n@layer components {\n  .btn-primary {\n    @apply px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700 transition;\n  }\n  .btn-secondary {\n    @apply px-4 py-2 bg-gray-300 text-gray-800 rounded-lg hover:bg-gray-400 transition;\n  }\n  .input-field {\n    @apply w-full px-3 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500;\n  }\n}\n```\n\n#### 2. API Client (`frontend/src/services/apiClient.ts`)\n\n```typescript\nimport { MangaProject, Panel, GenerationProgress, ProgressEvent } from '../types';\n\nconst API_BASE = import.meta.env.VITE_API_URL || 'http://localhost:5000/api';\n\nexport class APIClient {\n  /**\n   * Create new manga project\n   */\n  async createProject(name: string, storyPrompt: string, layoutConfig?: any) {\n    const response = await fetch(`${API_BASE}/manga/create`, {\n      method: 'POST',\n      headers: { 'Content-Type': 'application/json' },\n      body: JSON.stringify({\n        projectName: name,\n        storyPrompt,\n        layoutConfig\n      })\n    });\n    if (!response.ok) throw new Error(await response.text());\n    return response.json() as Promise<MangaProject>;\n  }\n\n  /**\n   * Upload key images\n   */\n  async uploadImages(projectId: string, files: File[]) {\n    const formData = new FormData();\n    files.forEach(file => formData.append('images', file));\n\n    const response = await fetch(`${API_BASE}/manga/${projectId}/upload`, {\n      method: 'POST',\n      body: formData\n    });\n    if (!response.ok) throw new Error(await response.text());\n    return response.json();\n  }\n\n  /**\n   * Analyze images using Vision API\n   */\n  async analyzeImages(projectId: string, depth: 'quick' | 'detailed' = 'quick') {\n    const response = await fetch(`${API_BASE}/manga/${projectId}/analyze`, {\n      method: 'POST',\n      headers: { 'Content-Type': 'application/json' },\n      body: JSON.stringify({ analysisDepth: depth })\n    });\n    if (!response.ok) throw new Error(await response.text());\n    return response.json();\n  }\n\n  /**\n   * Generate panel prompts\n   */\n  async generatePrompts(projectId: string, storyPrompt: string, panelCount: number) {\n    const response = await fetch(`${API_BASE}/manga/${projectId}/generate-prompts`, {\n      method: 'POST',\n      headers: { 'Content-Type': 'application/json' },\n      body: JSON.stringify({\n        storyPrompt,\n        panelCount,\n        characterConsistency: true\n      })\n    });\n    if (!response.ok) throw new Error(await response.text());\n    return response.json() as Promise<Panel[]>;\n  }\n\n  /**\n   * Generate images via DALL-E 3 (SSE streaming)\n   */\n  streamImageGeneration(\n    projectId: string,\n    batchMode: 'sequential' | 'parallel',\n    onProgress: (event: ProgressEvent) => void,\n    onError: (error: Error) => void\n  ): () => void {\n    const eventSource = new EventSource(\n      `${API_BASE}/manga/${projectId}/generate-images?batchMode=${batchMode}`\n    );\n\n    eventSource.onmessage = (event) => {\n      try {\n        const data = JSON.parse(event.data);\n        onProgress(data);\n      } catch (e) {\n        console.error('Failed to parse SSE message:', e);\n      }\n    };\n\n    eventSource.onerror = () => {\n      onError(new Error('Generation failed or connection lost'));\n      eventSource.close();\n    };\n\n    // Return cleanup function\n    return () => eventSource.close();\n  }\n\n  /**\n   * Compose layout with speech bubbles\n   */\n  async composeLayout(projectId: string, speechBubbles?: any) {\n    const response = await fetch(`${API_BASE}/manga/${projectId}/layout`, {\n      method: 'POST',\n      headers: { 'Content-Type': 'application/json' },\n      body: JSON.stringify({ speechBubbles })\n    });\n    if (!response.ok) throw new Error(await response.text());\n    return response.json();\n  }\n\n  /**\n   * Export to PNG/JPG/PDF\n   */\n  async exportManga(\n    projectId: string,\n    format: 'png' | 'jpg' | 'pdf',\n    compression: 'low' | 'medium' | 'high' = 'medium',\n    title?: string,\n    author?: string\n  ) {\n    const response = await fetch(`${API_BASE}/manga/${projectId}/export`, {\n      method: 'POST',\n      headers: { 'Content-Type': 'application/json' },\n      body: JSON.stringify({\n        format,\n        compression,\n        resolution: 'web',\n        title,\n        author\n      })\n    });\n    if (!response.ok) throw new Error(await response.text());\n    return response.json();\n  }\n\n  /**\n   * Fetch project details\n   */\n  async getProject(projectId: string) {\n    const response = await fetch(`${API_BASE}/manga/${projectId}`);\n    if (!response.ok) throw new Error(await response.text());\n    return response.json() as Promise<MangaProject>;\n  }\n\n  /**\n   * Reorder panels\n   */\n  async reorderPanels(projectId: string, panelOrder: number[]) {\n    const response = await fetch(`${API_BASE}/manga/${projectId}/reorder`, {\n      method: 'PUT',\n      headers: { 'Content-Type': 'application/json' },\n      body: JSON.stringify({ panelOrder })\n    });\n    if (!response.ok) throw new Error(await response.text());\n    return response.json();\n  }\n}\n\nexport const apiClient = new APIClient();\n```\n\n#### 3. useMangaGeneration Hook (`frontend/src/hooks/useMangaGeneration.ts`)\n\n```typescript\nimport { useState, useCallback } from 'react';\nimport { apiClient } from '../services/apiClient';\nimport { MangaProject, GenerationProgress, UploadedImage } from '../types';\n\nexport function useMangaGeneration() {\n  const [project, setProject] = useState<MangaProject | null>(null);\n  const [progress, setProgress] = useState<GenerationProgress>({\n    stage: 'idle',\n    currentStep: 0,\n    totalSteps: 0,\n    percentage: 0,\n    message: ''\n  });\n  const [error, setError] = useState<string | null>(null);\n\n  /**\n   * Complete workflow: Create  Upload  Analyze  Generate Prompts  Generate Images  Layout\n   */\n  const generateManga = useCallback(async (\n    projectName: string,\n    storyPrompt: string,\n    uploadedImages: UploadedImage[],\n    layoutConfig: any,\n    generationSettings: any\n  ) => {\n    try {\n      setError(null);\n\n      // Stage 1: Create project\n      setProgress({\n        stage: 'uploading',\n        currentStep: 0,\n        totalSteps: 5,\n        percentage: 20,\n        message: 'Creating project...'\n      });\n      const newProject = await apiClient.createProject(projectName, storyPrompt, layoutConfig);\n      setProject(newProject);\n\n      // Stage 2: Upload images\n      setProgress({\n        stage: 'uploading',\n        currentStep: 1,\n        totalSteps: 5,\n        percentage: 40,\n        message: 'Uploading reference images...'\n      });\n      const files = uploadedImages.map(img => img.file);\n      await apiClient.uploadImages(newProject.id, files);\n\n      // Stage 3: Analyze images\n      setProgress({\n        stage: 'analyzing',\n        currentStep: 2,\n        totalSteps: 5,\n        percentage: 60,\n        message: 'Analyzing images with Vision API...'\n      });\n      await apiClient.analyzeImages(newProject.id, 'detailed');\n\n      // Stage 4: Generate prompts\n      setProgress({\n        stage: 'generating_prompts',\n        currentStep: 3,\n        totalSteps: 5,\n        percentage: 70,\n        message: 'Generating panel prompts...'\n      });\n      await apiClient.generatePrompts(\n        newProject.id,\n        storyPrompt,\n        layoutConfig.totalPanels\n      );\n\n      // Stage 5: Generate images (with SSE streaming)\n      setProgress({\n        stage: 'generating_images',\n        currentStep: 4,\n        totalSteps: 5,\n        percentage: 75,\n        message: 'Starting image generation...'\n      });\n\n      await new Promise<void>((resolve, reject) => {\n        const cleanup = apiClient.streamImageGeneration(\n          newProject.id,\n          'sequential',  // or 'parallel' based on user preference\n          (progressEvent) => {\n            if (progressEvent.type === 'complete') {\n              setProgress(prev => ({\n                ...prev,\n                percentage: 90,\n                message: 'Image generation complete!'\n              }));\n              resolve();\n            } else if (progressEvent.type === 'error') {\n              reject(new Error(progressEvent.error || 'Generation failed'));\n            } else {\n              setProgress({\n                stage: 'generating_images',\n                currentStep: 4 + (progressEvent.currentStep || 0) * 0.1,\n                totalSteps: 5,\n                percentage: 75 + (progressEvent.percentage || 0) * 0.15,\n                message: progressEvent.message,\n                currentPanelIndex: progressEvent.panelIndex\n              });\n            }\n          },\n          reject\n        );\n      });\n\n      // Stage 6: Compose layout\n      setProgress({\n        stage: 'composing_layout',\n        currentStep: 5,\n        totalSteps: 5,\n        percentage: 95,\n        message: 'Composing final layout...'\n      });\n      await apiClient.composeLayout(newProject.id);\n\n      // Complete\n      const finalProject = await apiClient.getProject(newProject.id);\n      setProject(finalProject);\n      setProgress({\n        stage: 'idle',\n        currentStep: 5,\n        totalSteps: 5,\n        percentage: 100,\n        message: 'Manga generation complete!'\n      });\n\n    } catch (err) {\n      const errorMsg = err instanceof Error ? err.message : 'Unknown error';\n      setError(errorMsg);\n      setProgress({\n        stage: 'idle',\n        currentStep: 0,\n        totalSteps: 0,\n        percentage: 0,\n        message: `Error: ${errorMsg}`\n      });\n    }\n  }, []);\n\n  const exportManga = useCallback(async (\n    projectId: string,\n    format: 'png' | 'jpg' | 'pdf',\n    compression: 'low' | 'medium' | 'high' = 'medium'\n  ) => {\n    try {\n      setError(null);\n      setProgress({\n        stage: 'exporting',\n        currentStep: 0,\n        totalSteps: 1,\n        percentage: 50,\n        message: `Exporting as ${format.toUpperCase()}...`\n      });\n\n      const result = await apiClient.exportManga(projectId, format, compression);\n\n      setProgress({\n        stage: 'idle',\n        currentStep: 1,\n        totalSteps: 1,\n        percentage: 100,\n        message: 'Export complete!'\n      });\n\n      return result;\n    } catch (err) {\n      const errorMsg = err instanceof Error ? err.message : 'Export failed';\n      setError(errorMsg);\n      throw err;\n    }\n  }, []);\n\n  return {\n    project,\n    progress,\n    error,\n    generateManga,\n    exportManga,\n    setError\n  };\n}\n```\n\n#### 4. Components\n\n**ImageUploader.tsx:**\n```typescript\nimport { useCallback, useState } from 'react';\nimport { UploadedImage, ImagePosition } from '../types';\n\ninterface ImageUploaderProps {\n  onImagesSelected: (images: UploadedImage[]) => void;\n}\n\nexport function ImageUploader({ onImagesSelected }: ImageUploaderProps) {\n  const [images, setImages] = useState<UploadedImage[]>([]);\n  const [selectedPosition, setSelectedPosition] = useState<ImagePosition>('start');\n\n  const handleDrop = useCallback((e: React.DragEvent) => {\n    e.preventDefault();\n    const files = Array.from(e.dataTransfer.files).filter(f => f.type.startsWith('image/'));\n    addImages(files);\n  }, []);\n\n  const handleFileInput = (e: React.ChangeEvent<HTMLInputElement>) => {\n    if (e.target.files) {\n      addImages(Array.from(e.target.files));\n    }\n  };\n\n  const addImages = (files: File[]) => {\n    const newImages = files.map(file => ({\n      file,\n      previewUrl: URL.createObjectURL(file),\n      position: selectedPosition\n    }));\n    setImages(prev => [...prev, ...newImages]);\n    onImagesSelected([...images, ...newImages]);\n  };\n\n  const removeImage = (index: number) => {\n    const updated = images.filter((_, i) => i !== index);\n    setImages(updated);\n    onImagesSelected(updated);\n  };\n\n  return (\n    <div className=\"w-full max-w-2xl\">\n      <div\n        onDrop={handleDrop}\n        onDragOver={e => e.preventDefault()}\n        className=\"border-2 border-dashed border-gray-300 rounded-lg p-8 text-center cursor-pointer hover:border-blue-500 transition\"\n      >\n        <p className=\"text-gray-600 mb-4\">Drag and drop images here or click to select</p>\n        <input\n          type=\"file\"\n          multiple\n          accept=\"image/*\"\n          onChange={handleFileInput}\n          className=\"hidden\"\n          id=\"image-input\"\n        />\n        <label htmlFor=\"image-input\" className=\"btn-primary cursor-pointer\">\n          Select Images\n        </label>\n      </div>\n\n      <div className=\"mt-4\">\n        <label className=\"block mb-2\">Position in Story:</label>\n        <select\n          value={selectedPosition}\n          onChange={e => setSelectedPosition(e.target.value as ImagePosition)}\n          className=\"input-field\"\n        >\n          <option value=\"start\">Start (Reference)</option>\n          <option value=\"end\">End (Reference)</option>\n          <option value={1}>Panel 1</option>\n          <option value={2}>Panel 2</option>\n        </select>\n      </div>\n\n      {images.length > 0 && (\n        <div className=\"mt-6 grid grid-cols-2 gap-4\">\n          {images.map((img, idx) => (\n            <div key={idx} className=\"relative\">\n              <img src={img.previewUrl} alt={`Preview ${idx}`} className=\"rounded-lg w-full h-48 object-cover\" />\n              <button\n                onClick={() => removeImage(idx)}\n                className=\"absolute top-2 right-2 bg-red-500 text-white rounded-full w-6 h-6 flex items-center justify-center hover:bg-red-600\"\n              >\n                \n              </button>\n            </div>\n          ))}\n        </div>\n      )}\n    </div>\n  );\n}\n```\n\n**StoryPromptEditor.tsx (Enhanced):**\n```typescript\nimport { useState } from 'react';\n\ninterface StoryPromptEditorProps {\n  value: string;\n  onChange: (value: string) => void;\n}\n\nconst SAMPLE_PROMPTS = [\n  'A young ninja discovers their hidden powers and must save their village from a mysterious threat.',\n  'Two rival chefs compete in a cooking tournament, discovering they have more in common than they thought.',\n  'A time traveler must prevent a catastrophic event by gathering clues from different eras.',\n];\n\nexport function StoryPromptEditor({ value, onChange }: StoryPromptEditorProps) {\n  const [isExpanded, setIsExpanded] = useState(false);\n\n  return (\n    <div className=\"w-full max-w-2xl\">\n      <label className=\"block text-lg font-semibold mb-2\">Your Story Prompt</label>\n\n      <textarea\n        value={value}\n        onChange={e => onChange(e.target.value)}\n        placeholder=\"Write your manga story here. Be descriptive about characters, setting, and plot...\"\n        className=\"input-field h-32 resize-none\"\n      />\n\n      <div className=\"mt-4\">\n        <button\n          onClick={() => setIsExpanded(!isExpanded)}\n          className=\"text-blue-600 hover:underline text-sm\"\n        >\n          {isExpanded ? 'Hide' : 'Show'} Sample Prompts\n        </button>\n\n        {isExpanded && (\n          <div className=\"mt-3 space-y-2\">\n            {SAMPLE_PROMPTS.map((prompt, idx) => (\n              <button\n                key={idx}\n                onClick={() => onChange(prompt)}\n                className=\"block w-full text-left p-3 bg-gray-100 hover:bg-gray-200 rounded-lg text-sm transition\"\n              >\n                {prompt}\n              </button>\n            ))}\n          </div>\n        )}\n      </div>\n    </div>\n  );\n}\n```\n\n**PanelGrid.tsx (with Drag-and-Drop):**\n```typescript\nimport { useState } from 'react';\nimport { Panel } from '../types';\nimport { DndContext, closestCenter, KeyboardSensor, PointerSensor, useSensor, useSensors } from '@dnd-kit/core';\nimport { SortableContext, sortableKeyboardCoordinates, verticalListSortingStrategy, useSortable } from '@dnd-kit/sortable';\nimport { CSS } from '@dnd-kit/utilities';\n\nfunction SortablePanel({ panel }: { panel: Panel }) {\n  const { attributes, listeners, setNodeRef, transform, transition } = useSortable({ id: panel.id });\n  const style = { transform: CSS.Transform.toString(transform), transition };\n\n  return (\n    <div ref={setNodeRef} style={style} {...attributes} {...listeners} className=\"p-4\">\n      <div className=\"bg-white rounded-lg shadow p-4 cursor-grab active:cursor-grabbing\">\n        <img\n          src={panel.imageUrl}\n          alt={`Panel ${panel.panelIndex}`}\n          className=\"w-full h-auto rounded mb-2\"\n        />\n        <p className=\"text-sm text-gray-600\">{panel.storyBeat}</p>\n        <span className={`inline-block mt-2 px-2 py-1 rounded text-xs text-white ${\n          panel.status === 'generated' ? 'bg-green-500' :\n          panel.status === 'pending' ? 'bg-blue-500' :\n          'bg-red-500'\n        }`}>\n          {panel.status}\n        </span>\n      </div>\n    </div>\n  );\n}\n\ninterface PanelGridProps {\n  panels: Panel[];\n  onReorder: (newOrder: Panel[]) => void;\n}\n\nexport function PanelGrid({ panels, onReorder }: PanelGridProps) {\n  const sensors = useSensors(\n    useSensor(PointerSensor),\n    useSensor(KeyboardSensor, { coordinateGetter: sortableKeyboardCoordinates })\n  );\n\n  const handleDragEnd = (event: any) => {\n    const { active, over } = event;\n    if (over && active.id !== over.id) {\n      const oldIndex = panels.findIndex(p => p.id === active.id);\n      const newIndex = panels.findIndex(p => p.id === over.id);\n      const newPanels = [...panels];\n      [newPanels[oldIndex], newPanels[newIndex]] = [newPanels[newIndex], newPanels[oldIndex]];\n      onReorder(newPanels);\n    }\n  };\n\n  return (\n    <DndContext sensors={sensors} collisionDetection={closestCenter} onDragEnd={handleDragEnd}>\n      <SortableContext items={panels.map(p => p.id)} strategy={verticalListSortingStrategy}>\n        <div className=\"grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-4\">\n          {panels.map(panel => (\n            <SortablePanel key={panel.id} panel={panel} />\n          ))}\n        </div>\n      </SortableContext>\n    </DndContext>\n  );\n}\n```\n\n**ProgressBar.tsx:**\n```typescript\nimport { GenerationProgress } from '../types';\n\nexport function ProgressBar({ progress }: { progress: GenerationProgress }) {\n  return (\n    <div className=\"w-full max-w-2xl\">\n      <div className=\"mb-2 flex justify-between\">\n        <span className=\"text-sm font-semibold\">{progress.message}</span>\n        <span className=\"text-sm text-gray-600\">{Math.round(progress.percentage)}%</span>\n      </div>\n      <div className=\"w-full h-3 bg-gray-200 rounded-full overflow-hidden\">\n        <div\n          className=\"h-full bg-blue-600 transition-all duration-300\"\n          style={{ width: `${progress.percentage}%` }}\n        />\n      </div>\n    </div>\n  );\n}\n```\n\n#### 5. Pages\n\n**CreateMangaPage.tsx:**\n```typescript\nimport { useState } from 'react';\nimport { ImageUploader } from '../components/ImageUploader';\nimport { StoryPromptEditor } from '../components/StoryPromptEditor';\nimport { LayoutSelector } from '../components/LayoutSelector';\nimport { ProgressBar } from '../components/ProgressBar';\nimport { useMangaGeneration } from '../hooks/useMangaGeneration';\nimport { UploadedImage, LayoutConfig } from '../types';\n\nexport function CreateMangaPage() {\n  const [projectName, setProjectName] = useState('');\n  const [storyPrompt, setStoryPrompt] = useState('');\n  const [uploadedImages, setUploadedImages] = useState<UploadedImage[]>([]);\n  const [layoutConfig, setLayoutConfig] = useState<LayoutConfig>({\n    totalPanels: 4,\n    format: 'vertical',\n    readingOrder: 'japanese',\n    gutterSize: 10,\n    borderWidth: 2,\n    borderColor: '#000000',\n    backgroundColor: '#FFFFFF',\n    pageWidth: 800,\n    pageHeight: 1200\n  });\n\n  const { progress, error, generateManga } = useMangaGeneration();\n\n  const handleStart = async () => {\n    if (!projectName || !storyPrompt) {\n      alert('Please enter project name and story prompt');\n      return;\n    }\n\n    await generateManga(projectName, storyPrompt, uploadedImages, layoutConfig, {\n      imageStyle: 'manga style',\n      aspectRatio: 'square',\n      qualityLevel: 'standard'\n    });\n  };\n\n  return (\n    <div className=\"min-h-screen bg-gray-50 py-12 px-4\">\n      <div className=\"max-w-4xl mx-auto space-y-8\">\n        <h1 className=\"text-4xl font-bold text-center mb-2\">koma-fill</h1>\n        <p className=\"text-center text-gray-600\">AI-Powered Manga Panel Generator</p>\n\n        {error && <div className=\"bg-red-100 border border-red-400 text-red-700 px-4 py-3 rounded\">{error}</div>}\n\n        {progress.stage === 'idle' ? (\n          <div className=\"space-y-8\">\n            <div className=\"bg-white p-6 rounded-lg shadow\">\n              <label className=\"block text-lg font-semibold mb-2\">Project Name</label>\n              <input\n                type=\"text\"\n                value={projectName}\n                onChange={e => setProjectName(e.target.value)}\n                className=\"input-field\"\n                placeholder=\"My Awesome Manga\"\n              />\n            </div>\n\n            <div className=\"bg-white p-6 rounded-lg shadow\">\n              <StoryPromptEditor value={storyPrompt} onChange={setStoryPrompt} />\n            </div>\n\n            <div className=\"bg-white p-6 rounded-lg shadow\">\n              <ImageUploader onImagesSelected={setUploadedImages} />\n            </div>\n\n            <div className=\"bg-white p-6 rounded-lg shadow\">\n              <LayoutSelector config={layoutConfig} onChange={setLayoutConfig} />\n            </div>\n\n            <button onClick={handleStart} className=\"btn-primary w-full text-lg py-3\">\n              Generate Manga\n            </button>\n          </div>\n        ) : (\n          <div className=\"bg-white p-6 rounded-lg shadow\">\n            <ProgressBar progress={progress} />\n          </div>\n        )}\n      </div>\n    </div>\n  );\n}\n```\n\n**PreviewPage.tsx:**\n```typescript\nimport { useParams, useNavigate } from 'react-router-dom';\nimport { useEffect, useState } from 'react';\nimport { apiClient } from '../services/apiClient';\nimport { PanelGrid } from '../components/PanelGrid';\nimport { ExportOptions } from '../components/ExportOptions';\nimport { MangaProject } from '../types';\n\nexport function PreviewPage() {\n  const { projectId } = useParams<{ projectId: string }>();\n  const navigate = useNavigate();\n  const [project, setProject] = useState<MangaProject | null>(null);\n  const [loading, setLoading] = useState(true);\n\n  useEffect(() => {\n    if (projectId) {\n      apiClient.getProject(projectId).then(setProject).finally(() => setLoading(false));\n    }\n  }, [projectId]);\n\n  if (loading) return <div className=\"flex justify-center py-12\">Loading...</div>;\n  if (!project) return <div className=\"text-center py-12\">Project not found</div>;\n\n  return (\n    <div className=\"min-h-screen bg-gray-50 py-12 px-4\">\n      <div className=\"max-w-6xl mx-auto\">\n        <button onClick={() => navigate('/')} className=\"btn-secondary mb-6\"> Back</button>\n\n        <h1 className=\"text-3xl font-bold mb-2\">{project.name}</h1>\n        <p className=\"text-gray-600 mb-6\">Project Status: {project.status}</p>\n\n        {project.panels.length > 0 && (\n          <div className=\"bg-white p-6 rounded-lg shadow mb-8\">\n            <h2 className=\"text-2xl font-semibold mb-4\">Panels</h2>\n            <PanelGrid panels={project.panels} onReorder={() => {}} />\n          </div>\n        )}\n\n        <div className=\"bg-white p-6 rounded-lg shadow\">\n          <h2 className=\"text-2xl font-semibold mb-4\">Export</h2>\n          <ExportOptions projectId={project.id} />\n        </div>\n      </div>\n    </div>\n  );\n}\n```\n\n#### 6. Update App.tsx\n\n```typescript\nimport { BrowserRouter as Router, Routes, Route, Navigate } from 'react-router-dom';\nimport { CreateMangaPage } from './pages/CreateMangaPage';\nimport { PreviewPage } from './pages/PreviewPage';\nimport './index.css';\n\nexport default function App() {\n  return (\n    <Router>\n      <Routes>\n        <Route path=\"/\" element={<CreateMangaPage />} />\n        <Route path=\"/project/:projectId\" element={<PreviewPage />} />\n        <Route path=\"*\" element={<Navigate to=\"/\" />} />\n      </Routes>\n    </Router>\n  );\n}\n```\n\n### package.json Updates\n\nAdd dependencies:\n```bash\nnpm install -D tailwindcss postcss autoprefixer\nnpm install react-router-dom @dnd-kit/core @dnd-kit/sortable @dnd-kit/utilities\n```\n\n### Testing Requirements\n\n```bash\n# 1. Start backend (from Task 1)\ncd backend && npm run dev\n\n# 2. In another terminal, start frontend\ncd frontend && npm run dev\n\n# 3. Open browser: http://localhost:3000\n\n# 4. Test workflow:\n# - Enter project name and story\n# - Upload reference images\n# - Configure layout\n# - Click \"Generate Manga\"\n# - Watch progress bar\n# - See panel grid with images\n# - Export to PNG/JPG/PDF\n```\n\n### Files This Task Uses from Other Agents\n\n- **API endpoints** from Task 1 (database & routes)\n- **Analysis data** from Task 2 (character consistency)\n- **Generated images** from Task 3 (panel images)\n- **Composed layouts** from Task 4 (final manga)\n\n### Output Validation Checklist\n\n- [ ] Tailwind CSS configured and working\n- [ ] ImageUploader component with drag-drop works\n- [ ] react-dropzone integration functional\n- [ ] StoryPromptEditor displays with sample prompts\n- [ ] Sample prompt insertion works\n- [ ] PanelGrid displays with drag-and-drop reordering\n- [ ] @dnd-kit integration functional\n- [ ] useMangaGeneration hook orchestrates full workflow\n- [ ] SSE progress streaming displays correctly\n- [ ] ProgressBar updates in real-time\n- [ ] apiClient makes correct API calls\n- [ ] All components have TypeScript types\n- [ ] CreateMangaPage workflow complete\n- [ ] PreviewPage shows generated manga\n- [ ] ExportOptions functional (PNG/JPG/PDF)\n- [ ] Routing works (create  preview)\n- [ ] Error handling displays user-friendly messages\n- [ ] npm run dev starts without errors\n- [ ] No TypeScript compilation errors\n\n---\n\n## Integration Testing (After All Tasks Complete)\n\nAfter all 5 agents finish their implementations, run the following integration tests:\n\n```bash\n# 1. Start backend\ncd /mnt/Projects/koma-fill/backend\nnpm install\nnpm run dev\n# Expected: \" koma-fill server running on http://localhost:5000\"\n\n# 2. Start frontend (new terminal)\ncd /mnt/Projects/koma-fill/frontend\nnpm install\nnpm run dev\n# Expected: \"VITE  ready in XXX ms\"\n\n# 3. Complete workflow test\n# Open http://localhost:3000 in browser\n# - Create project\n# - Upload 2 reference images\n# - Enter story prompt\n# - Select layout (4 panels)\n# - Click \"Generate Manga\"\n# - Wait for completion\n# - View generated panels\n# - Export to PNG\n# - Verify PNG file created in uploads/\n\n# 4. Verify database\nsqlite3 /mnt/Projects/koma-fill/data/koma-fill.db\n> SELECT COUNT(*) FROM projects;\n> SELECT COUNT(*) FROM panels;\n> SELECT COUNT(*) FROM keyImages;\n\n# 5. Check file structure\nls -la /mnt/Projects/koma-fill/uploads/\nls -la /mnt/Projects/koma-fill/data/\n\n# 6. API health check\ncurl http://localhost:5000/api/health\n# Expected: {\"status\":\"ok\",\"timestamp\":\"...\"}\n```\n\n### Known Integration Points to Verify\n\n- Task 1  Task 2: Panel prompts saved in DB, readable by frontend\n- Task 2  Task 3: Vision analysis influences character consistency in prompts\n- Task 3  Task 4: Generated images saved to disk, paths in database\n- Task 4  Task 5: Layout images served via `/uploads/` static directory\n- Task 5  All: Frontend calls all backend API endpoints successfully\n\n---\n\n## Success Criteria Summary\n\nAll 5 tasks completed when:\n\n1. **Backend (Task 1)**: Express server with SQLite database, all CRUD routes working\n2. **Vision & Prompts (Task 2)**: OpenAI Vision API analyzes images, GPT-4o generates DALL-E prompts\n3. **Image Generation (Task 3)**: DALL-E 3 generates 4+ images with retry logic, SSE progress works\n4. **Layout & Export (Task 4)**: Sharp composes panels into manga layout, exports PNG/JPG/PDF\n5. **Frontend (Task 5)**: React UI allows workflow from story  generated manga  export\n\n**Total Expected Time**: 4-5 hours per agent (can run in parallel)\n**Minimum Test Time**: 30 minutes for integration testing\n\nGood luck, KAMUI agents! \n\n---\n\n*Last Updated: 2025-02-12*\n*For issues or questions, refer to the specific task prompts above*",
        "tooltip": ": CodexCLI1: # KAMUI-4D Parallel Task Prompts for koma-fill\n## Manga Generation AI System - Multi-Agent Implementation Guide\n\n**Version:** 1.0\n**Project:** koma-fill - AI-powered manga panel generation system\n**Target:** KAMUI-4D Editor (Multi-AI CLI parallel execution)\n\n---\n\n## How to Use These Prompts in KAMUI-4D\n\nThis document contains **5 independent task prompts** designed to run in parallel across multiple AI coding agents. Each prompt is self-contained and can be executed independently without blocking other tasks.\n\n### Setup Instructions\n\n1. **Install dependencies** (run once before starting tasks):\n   ```bash\n   cd /mnt/Projects/koma-fill/backend\n   npm install\n\n   cd /mnt/Projects/koma-fill/frontend\n   npm install\n   ```\n\n2. **Environment Configuration**:\n   Create `/mnt/Projects/koma-fill/.env`:\n   ```\n   NODE_ENV=development\n   PORT=5000\n   BASE_URL=http://localhost:5000\n   OPENAI_API_KEY=your_openai_api_key_here\n   OPENAI_ORG_ID=your_org_id_optional\n   DATABASE_PATH=./data/koma-fill.db\n   STORAGE_PATH=./uploads\n   MAX_IMAGE_SIZE_MB=20\n   DALLE_RATE_LIMIT_PER_MINUTE=5\n   VISION_RATE_LIMIT_PER_MINUTE=30\n   MAX_RETRIES_PER_PANEL=3\n   ALLOWED_ORIGINS=http://localhost:3000\n   ```\n\n3. **Execution Strategy**:\n   - Copy each task prompt below into a separate KAMUI-4D session/agent\n   - **Tasks 1-5 can ALL start simultaneously** (no blocking dependencies)\n   - Each task should run independently in its own AI CLI session\n   - Monitor each agent's progress via console output\n   - **Integration testing** should happen after all 5 tasks complete (see bottom of doc)\n\n4. **Task Dependencies**:\n   ```\n   Task 1 (Backend)  provides database & API contracts\n   Task 2 (Vision)  uses Task 1's API, reads backend/src/models/types.ts\n   Task 3 (Images)  uses Task 1's API, reads backend/src/models/types.ts\n   Task 4 (Layout)  uses Task 1's API, reads backend/src/models/types.ts\n   Task 5 (Frontend)  calls Tasks 1-4 via REST API\n   ```\n   **All tasks can start immediately** - they communicate via file system and API contracts.\n\n---\n\n## Task 1: Backend (Agent A)\n### Express Server, SQLite Database & CRUD Routes Foundation\n\n**Time Estimate:** 45-60 minutes\n**Difficulty:** Intermediate\n**Dependencies:** None (this is the foundation layer)\n\n### Objective\nSet up a fully functional Express.js backend with SQLite database, implement CRUD operations for manga projects and panels, configure file upload handling with multer, and provide a solid API foundation for other agents to build upon.\n\n### Target Files to Create/Modify\n\n```\nbackend/\n src/\n    database/\n       connection.ts          [NEW] SQLite connection & initialization\n       schema.ts              [NEW] Table schema definitions\n    index.ts                   [MODIFY] Add DB initialization\n    app.ts                     [COMPLETE] Already done - verify middleware\n    routes/\n       manga.ts               [IMPLEMENT] Route handlers with DB calls\n    middleware/\n        errorHandler.ts        [VERIFY] Already complete\n uploads/                        [CREATE] Directory for image storage\n data/                           [CREATE] Directory for SQLite DB\n```\n\n### TypeScript Interfaces (from `/mnt/Projects/koma-fill/backend/src/models/types.ts`)\n\nKey types you'll use:\n```typescript\n// Core entities\nMangaProject {\n  id: string;                    // UUID\n  name: string;\n  description?: string;\n  status: ProjectStatus;         // 'draft' | 'analyzing' | 'generating' | 'complete' | 'exported'\n  layoutConfig: LayoutConfig;\n  generationSettings: GenerationSettings;\n  panels: Panel[];\n  keyImages: KeyImage[];\n  totalCost: number;\n  createdAt: string;             // ISO datetime\n  updatedAt: string;\n}\n\nPanel {\n  id: string;                    // UUID\n  projectId: string;\n  panelIndex: number;            // 0-based\n  imageUrl?: string;\n  imageFilePath?: string;\n  prompt?: string;\n  storyBeat?: string;\n  speechBubbleText?: string;\n  status: PanelStatus;           // 'pending' | 'generated' | 'failed' | 'placeholder'\n  retryCount: number;\n  generatedAt?: string;\n  createdAt: string;\n}\n\nKeyImage {\n  id: string;                    // UUID\n  projectId: string;\n  imageFilePath: string;\n  position: ImagePosition;       // 'start' | 'end' | number\n  analysis?: ImageAnalysis;\n  createdAt: string;\n}\n\nLayoutConfig {\n  totalPanels: number;           // 4, 6, 8, etc.\n  format: LayoutFormat;          // 'vertical' | 'horizontal' | 'square'\n  readingOrder: ReadingOrder;    // 'japanese' | 'western'\n  gutterSize: number;            // px\n  borderWidth: number;           // px\n  borderColor: string;           // hex #RRGGBB\n  backgroundColor: string;       // hex\n  pageWidth: number;             // px\n  pageHeight: number;            // px\n}\n\nGenerationSettings {\n  imageStyle: string;            // e.g., \"manga style, black and white ink\"\n  aspectRatio: 'square' | 'wide' | 'tall';\n  qualityLevel: 'standard' | 'hd';\n  negativePrompt?: string;\n  seed?: number;\n}\n```\n\n### Implementation Checklist\n\n#### 1. Create Database Connection Module (`backend/src/database/connection.ts`)\n```typescript\n// Requirements:\n- Initialize better-sqlite3 connection\n- Create/open database at DATABASE_PATH from .env\n- Export initDatabase() async function\n- Enable foreign keys constraint\n- Handle database file creation if needed\n- Connection should be cached/singleton\n```\n\n#### 2. Create Database Schema Module (`backend/src/database/schema.ts`)\n```typescript\n// SQL Schema Requirements:\nCREATE TABLE projects (\n  id TEXT PRIMARY KEY,\n  name TEXT NOT NULL,\n  description TEXT,\n  status TEXT NOT NULL,\n  layoutConfig JSON NOT NULL,\n  generationSettings JSON NOT NULL,\n  totalCost REAL DEFAULT 0,\n  createdAt TEXT NOT NULL,\n  updatedAt TEXT NOT NULL\n);\n\nCREATE TABLE panels (\n  id TEXT PRIMARY KEY,\n  projectId TEXT NOT NULL,\n  panelIndex INTEGER NOT NULL,\n  imageUrl TEXT,\n  imageFilePath TEXT,\n  prompt TEXT,\n  storyBeat TEXT,\n  speechBubbleText TEXT,\n  status TEXT NOT NULL,\n  retryCount INTEGER DEFAULT 0,\n  generatedAt TEXT,\n  createdAt TEXT NOT NULL,\n  FOREIGN KEY (projectId) REFERENCES projects(id)\n);\n\nCREATE TABLE keyImages (\n  id TEXT PRIMARY KEY,\n  projectId TEXT NOT NULL,\n  imageFilePath TEXT NOT NULL,\n  position TEXT NOT NULL,\n  analysis JSON,\n  createdAt TEXT NOT NULL,\n  FOREIGN KEY (projectId) REFERENCES projects(id)\n);\n\nCREATE INDEX idx_project_status ON projects(status);\nCREATE INDEX idx_panel_project ON panels(projectId);\nCREATE INDEX idx_panel_status ON panels(status);\n```\n\n#### 3. Modify `backend/src/index.ts`\n```typescript\n// Add:\n- Import { initDatabase } from './database/connection'\n- Call await initDatabase() before app.listen()\n- Log database initialization success\n```\n\n#### 4. Create Repository Layer (`backend/src/repositories/`)\n```typescript\n// Create:\n- ProjectRepository with methods:\n  - createProject(data: CreateMangaRequest): Promise<MangaProject>\n  - getProject(id: string): Promise<MangaProject | null>\n  - listProjects(limit: number, offset: number): Promise<MangaProject[]>\n  - updateProject(id: string, updates: Partial<MangaProject>): Promise<MangaProject>\n  - deleteProject(id: string): Promise<void>\n\n- PanelRepository with methods:\n  - createPanel(projectId: string, data: Panel): Promise<Panel>\n  - getPanelsByProject(projectId: string): Promise<Panel[]>\n  - getPanel(panelId: string): Promise<Panel | null>\n  - updatePanel(panelId: string, updates: Partial<Panel>): Promise<Panel>\n  - updatePanelStatus(panelId: string, status: PanelStatus): Promise<void>\n\n- KeyImageRepository with methods:\n  - createKeyImage(projectId: string, data: KeyImage): Promise<KeyImage>\n  - getKeyImages(projectId: string): Promise<KeyImage[]>\n  - updateKeyImageAnalysis(imageId: string, analysis: ImageAnalysis): Promise<void>\n```\n\n#### 5. Implement Routes in `backend/src/routes/manga.ts`\nReplace TODO comments with actual implementations:\n\n- **POST /api/manga/create**\n  - Validate CreateMangaRequest using Joi\n  - Generate unique project ID (uuid)\n  - Create project in database with 'draft' status\n  - Create initial panel records (count = layoutConfig.totalPanels)\n  - Return created MangaProject with 201 status\n\n- **POST /api/manga/:projectId/upload**\n  - Files already handled by multer middleware\n  - Save KeyImage records to database with file paths\n  - Store position information\n  - Return array of KeyImage objects\n\n- **GET /api/manga/:projectId**\n  - Fetch project + panels + key images from database\n  - Return complete MangaProject object\n  - Throw NotFoundError if project doesn't exist\n\n- **GET /api/manga**\n  - Implement pagination (limit/offset query params)\n  - Return array of projects\n  - Include total count header\n\n- **PUT /api/manga/:projectId/reorder**\n  - Parse ReorderPanelsRequest body\n  - Update panelIndex for each panel based on new order\n  - Return updated panels array\n\n### Testing Requirements\n\nAfter implementation, verify:\n\n```bash\n# 1. Database initialization\nnpm run dev\n# Check console: \" configured\" for database\n\n# 2. Create project\ncurl -X POST http://localhost:5000/api/manga/create \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\n    \"projectName\": \"Test Manga\",\n    \"storyPrompt\": \"A hero on a quest\",\n    \"layoutConfig\": { \"totalPanels\": 4 }\n  }'\n\n# 3. Get project\ncurl http://localhost:5000/api/manga/{projectId}\n\n# 4. Upload images\ncurl -X POST http://localhost:5000/api/manga/{projectId}/upload \\\n  -F \"images=@test1.jpg\" \\\n  -F \"images=@test2.jpg\"\n\n# 5. Check database\nsqlite3 data/koma-fill.db \"SELECT * FROM projects; SELECT * FROM panels;\"\n```\n\n### Files This Task Provides to Other Agents\n\n- **Database schema** - Tasks 2, 3, 4, 5 will read/write to these tables\n- **API contracts** - manga.ts route signatures that Tasks 2-4 will call\n- **File storage structure** - uploads/ directory path that Task 3 will use\n- **Type definitions** - already in backend/src/models/types.ts (reference only)\n\n### Output Validation Checklist\n\n- [ ] Database file created at `data/koma-fill.db`\n- [ ] All 3 tables created with correct schema\n- [ ] Repositories implement CRUD operations\n- [ ] All route handlers work without TODO comments\n- [ ] multer uploads save files to `uploads/` directory\n- [ ] POST /create returns 201 with MangaProject object\n- [ ] GET /:projectId returns full project with panels\n- [ ] Error handler catches and responds appropriately\n- [ ] No TypeScript compilation errors\n- [ ] npm run dev starts without errors\n\n---\n\n## Task 2: + (Agent B)\n### Vision API Integration & DALL-E Prompt Generation\n\n**Time Estimate:** 50-60 minutes\n**Difficulty:** Intermediate\n**Dependencies:** Task 1 (needs database & API routes available)\n\n### Objective\nImplement OpenAI Vision API integration to analyze uploaded key images and extract character/style information. Then implement story-to-panel prompt generation using GPT-4o to create DALL-E 3 compatible prompts that maintain consistency across panels.\n\n### Target Files to Create/Modify\n\n```\nbackend/\n src/\n     services/\n         imageAnalysisService.ts      [IMPLEMENT] Vision API analysis\n         promptGenerationService.ts   [CREATE] Story  panel prompts\n```\n\n### System Prompts (Already Provided)\n\nBoth vision analysis prompts are defined in `imageAnalysisService.ts`:\n- `QUICK_ANALYSIS_PROMPT` - fast, ~500 tokens\n- `DETAILED_ANALYSIS_PROMPT` - thorough, ~2000 tokens\n\nThese guide the Vision API to return structured JSON matching the `ImageAnalysis` interface.\n\n### TypeScript Interfaces\n\n```typescript\n// Input: Key image file path (from Task 1)\n// Output: ImageAnalysis object\n\nImageAnalysis {\n  description: string;\n  characters: CharacterInfo[];\n  objects: string[];\n  colors: string[];\n  composition: string;\n  mood: string;\n  artStyle: string;\n  suggestedTransitions: string[];\n}\n\nCharacterInfo {\n  name?: string;\n  appearance: string;        // detailed physical description\n  emotion: string;\n  position: string;          // screen position (e.g., \"center-left\")\n}\n\n// Panel prompt generation\nPanelPrompt {\n  panelIndex: number;\n  dallePrompt: string;       // Full DALL-E 3 prompt (100-300 words)\n  storyBeat: string;         // What happens in this panel\n  visualFocus: string;       // Main visual element\n  transitionType: TransitionType;  // 'cut' | 'pan' | 'zoom_in' | 'zoom_out' | 'fade' | 'action'\n  suggestedDialogue?: string;\n}\n```\n\n### Implementation Details\n\n#### ImageAnalysisService (`backend/src/services/imageAnalysisService.ts`)\n\n**Constructor:**\n```typescript\nconstructor() {\n  this.openai = new OpenAI({\n    apiKey: CONFIG.OPENAI_API_KEY,\n    organization: CONFIG.OPENAI_ORG_ID\n  });\n}\n```\n\n**Method: analyzeImage(imageBase64: string, depth: 'quick' | 'detailed')**\n- Input: Base64-encoded image data from KeyImage file\n- Implementation:\n  1. Read image file and convert to Base64 (if not already)\n  2. Call `this.openai.chat.completions.create()`:\n     - model: CONFIG.VISION_MODEL ('gpt-4o')\n     - messages: [\n       { role: 'system', content: QUICK_ANALYSIS_PROMPT or DETAILED_ANALYSIS_PROMPT }\n       { role: 'user', content: [\n         { type: 'image_url', image_url: { url: `data:image/png;base64,${imageBase64}` } }\n       ]}\n     ]\n     - response_format: { type: 'json_object' }\n     - max_tokens: depth === 'quick' ? 500 : 2000\n  3. Parse response.choices[0].message.content as JSON\n  4. Validate against ImageAnalysis schema\n  5. Return ImageAnalysis object\n\n**Method: analyzeMultiple(images, depth)**\n- Input: Array of { base64, position } objects\n- Use Promise.all with rate limiting (max CONFIG.VISION_RATE_LIMIT_PER_MINUTE calls/min)\n- Implement backoff if rate limited\n- Return array of ImageAnalysis objects\n\n**Method: extractCharacters(analysis)**\n- Optional: Deep-dive character extraction\n- Can call another Vision API pass if needed for more detail\n\n#### PromptGenerationService (NEW FILE - `backend/src/services/promptGenerationService.ts`)\n\n**Constructor:**\n```typescript\nconstructor() {\n  this.openai = new OpenAI({ apiKey: CONFIG.OPENAI_API_KEY });\n}\n```\n\n**Method: generatePanelPrompts(request: GeneratePromptsRequest)**\n\nInput:\n```typescript\nGeneratePromptsRequest {\n  storyPrompt: string;           // User's story\n  panelCount: number;            // Total panels to generate\n  characterConsistency: boolean; // Whether to maintain character consistency\n}\n```\n\nImplementation:\n1. **Story Breakdown Phase:**\n   - Call GPT-4o to split story into N panel beats\n   - System prompt should guide structure like:\n   ```\n   \"You are a manga story expert. Break the provided story into exactly {panelCount}\n    distinct visual beats. Each beat should be 1-2 sentences describing what happens\n    visually in that panel. Format as JSON array of objects with 'panelIndex' and 'beat' fields.\"\n   ```\n\n2. **Character Consistency Analysis:**\n   - If characterConsistency=true and keyImages were analyzed:\n     - Retrieve stored ImageAnalysis for key images\n     - Create character consistency profile (appearance, emotion arcs, etc.)\n     - Include in subsequent prompts\n\n3. **DALL-E 3 Prompt Generation:**\n   - For each story beat, create detailed DALL-E 3 prompt\n   - System prompt pattern:\n   ```\n   \"You are a DALL-E 3 prompt expert specializing in manga panels.\n    Given a story beat, generate a detailed visual prompt (100-300 words) that:\n    - Specifies art style: {generationSettings.imageStyle}\n    - Maintains character consistency: {characterProfile}\n    - Follows manga composition principles\n    - Uses specific visual terms (angle, lighting, pose, emotion)\n    - Avoids abstract concepts; be concrete and visual\n    - Follows DALL-E 3 content policy\n\n    Return JSON with: { dallePrompt, visualFocus, transitionType, suggestedDialogue }\"\n   ```\n\n4. **Transition Logic:**\n   - Analyze flow between consecutive beats\n   - Suggest transition type ('cut', 'pan', 'zoom_in', etc.)\n   - Update imageUrl in previous panel to support transitions\n\n5. **Return Value:**\n   - Array of PanelPrompt objects, one per panel\n   - Each with populated dallePrompt, storyBeat, visualFocus, transitionType\n\n### Database Integration\n\nAfter generating prompts, save to Panel table:\n- Update each panel's `prompt` field with `dallePrompt`\n- Update `storyBeat` field\n- Update `status` to 'pending' (ready for image generation)\n\n### API Integration\n\nImplement route handlers in `backend/src/routes/manga.ts`:\n\n**POST /api/manga/:projectId/analyze**\n```typescript\n// 1. Fetch project and keyImages from DB\n// 2. Read image files and convert to Base64\n// 3. Call imageAnalysisService.analyzeMultiple()\n// 4. Store analysis results in DB (keyImages.analysis)\n// 5. Update project status to 'analyzing'  'complete'\n// 6. Return analysis results\n```\n\n**POST /api/manga/:projectId/generate-prompts**\n```typescript\n// 1. Validate GeneratePromptsRequest\n// 2. Fetch project and keyImages analyses from DB\n// 3. Call promptGenerationService.generatePanelPrompts()\n// 4. Update panel records with generated prompts\n// 5. Update project status to 'generating'\n// 6. Return array of PanelPrompt objects\n```\n\n### Testing Requirements\n\n```bash\n# 1. Prepare test image\n# (Use any PNG/JPG with a character or scene)\n\n# 2. Create project and upload image (Task 1)\nPROJECT_ID=$(curl -s -X POST http://localhost:5000/api/manga/create \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"projectName\":\"Test\",\"storyPrompt\":\"A hero finds treasure\"}' | jq -r '.id')\n\n# 3. Upload test image\ncurl -X POST http://localhost:5000/api/manga/$PROJECT_ID/upload \\\n  -F \"images=@test_image.jpg\"\n\n# 4. Analyze images\ncurl -X POST http://localhost:5000/api/manga/$PROJECT_ID/analyze \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"analysisDepth\":\"quick\"}'\n\n# 5. Generate prompts\ncurl -X POST http://localhost:5000/api/manga/$PROJECT_ID/generate-prompts \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\n    \"storyPrompt\": \"A hero finds treasure in a dark cave\",\n    \"panelCount\": 4,\n    \"characterConsistency\": true\n  }'\n\n# 6. Verify output\ncurl http://localhost:5000/api/manga/$PROJECT_ID | jq '.panels[].prompt'\n```\n\n### Files This Task Provides to Other Agents\n\n- **Panel prompt data** - Stored in DB panels table, used by Task 3 for image generation\n- **Character analysis** - Used by Task 5 frontend for display\n- **Art style consistency** - Guides Task 3's image generation\n\n### Output Validation Checklist\n\n- [ ] ImageAnalysisService.analyzeImage() calls Vision API successfully\n- [ ] Vision API responses parse correctly to ImageAnalysis\n- [ ] PromptGenerationService generates DALL-E-compatible prompts\n- [ ] Panel prompts maintain character consistency (if enabled)\n- [ ] Transition types are correctly assigned\n- [ ] All panel records updated in database with prompts\n- [ ] /analyze endpoint returns ImageAnalysis array\n- [ ] /generate-prompts endpoint returns PanelPrompt array\n- [ ] Error handling for API failures (rate limits, auth, etc.)\n- [ ] No TypeScript compilation errors\n\n---\n\n## Task 3: DALL-E 3 (Agent C)\n### Image Generation with Retry Logic & Progress Streaming\n\n**Time Estimate:** 50-70 minutes\n**Difficulty:** Intermediate-Advanced\n**Dependencies:** Task 1 (DB & API), Task 2 (panel prompts)\n\n### Objective\nImplement DALL-E 3 image generation with robust error handling, exponential backoff retry logic, local image storage, Server-Sent Events (SSE) streaming for real-time progress updates, and cost tracking per API call.\n\n### Target Files to Create/Modify\n\n```\nbackend/\n src/\n     services/\n         imageGenerationService.ts    [IMPLEMENT] DALL-E 3 API integration\n         (imageProcessor.ts)          [REFERENCE] Utility for image processing\n```\n\n### TypeScript Interfaces\n\n```typescript\nGeneratedPanel {\n  panelIndex: number;\n  imageUrl: string;              // DALL-E public URL (temporary)\n  localFilePath: string;         // /uploads/{projectId}/panel_{index}.png\n  prompt: string;                // Original prompt sent\n  revisedPrompt?: string;        // DALL-E 3's revised prompt (if modified)\n  costUsd: number;               // API call cost\n}\n\n// Request type\nGenerateImagesRequest {\n  panelIndices?: number[];       // undefined = all panels\n  batchMode: 'sequential' | 'parallel';\n}\n\n// Progress event (sent via SSE)\nProgressEvent {\n  type: 'progress' | 'complete' | 'error';\n  stage: string;                 // 'generating_images'\n  currentStep: number;           // Current panel index\n  totalSteps: number;            // Total panels\n  percentage: number;            // 0-100\n  message: string;               // Human-readable status\n  panelId?: string;\n  panelIndex?: number;\n  error?: string;                // Error message if type='error'\n}\n```\n\n### Implementation Details\n\n#### ImageGenerationService (`backend/src/services/imageGenerationService.ts`)\n\n**Constructor & Initialization:**\n```typescript\nconstructor() {\n  this.openai = new OpenAI({ apiKey: CONFIG.OPENAI_API_KEY });\n  this.uploadDir = path.resolve(CONFIG.STORAGE_PATH);\n}\n```\n\n**Method: generatePanel() - Single Panel Generation**\n\n```typescript\nasync generatePanel(\n  prompt: string,\n  panelIndex: number,\n  projectId: string,\n  settings?: GenerationSettings\n): Promise<GeneratedPanel>\n```\n\nImplementation:\n1. **Image Size Calculation:**\n   - Map aspectRatio to DALL-E 3 size:\n     - 'square'  '1024x1024'\n     - 'wide'  '1792x1024'\n     - 'tall'  '1024x1792'\n\n2. **API Call (with retry logic in wrapper):**\n   ```typescript\n   const response = await this.openai.images.generate({\n     model: CONFIG.DALLE_MODEL,           // 'dall-e-3'\n     prompt: prompt,\n     n: 1,\n     size: size,\n     quality: settings?.qualityLevel === 'hd' ? 'hd' : 'standard',\n     style: 'natural',                    // or 'vivid' for more dramatic\n   });\n   ```\n\n3. **Extract Response Data:**\n   - imageUrl = response.data[0].url\n   - revisedPrompt = response.data[0].revised_prompt\n   - Calculate cost based on settings.qualityLevel:\n     - standard: $0.040 per image\n     - hd: $0.080 per image\n\n4. **Download & Save Image:**\n   - Call this.downloadAndSave(imageUrl, projectId, panelIndex)\n   - Saves as PNG: `{STORAGE_PATH}/{projectId}/panel_{panelIndex}.png`\n   - Returns localFilePath\n\n5. **Return GeneratedPanel object**\n\n**Method: generateBatch() - Batch Generation with Mode Selection**\n\n```typescript\nasync generateBatch(\n  panelPrompts: PanelPrompt[],\n  projectId: string,\n  batchMode: 'sequential' | 'parallel',\n  settings?: GenerationSettings,\n  onProgress?: (event: ProgressEvent) => void\n): Promise<GeneratedPanel[]>\n```\n\nImplementation:\n1. Validate inputs\n2. Route to sequential or parallel handler\n3. Call onProgress callback with progress events\n4. Return array of GeneratedPanel\n\n**Method: generateSequential() - Rate-Limit Friendly**\n\n```typescript\nprivate async generateSequential(\n  panelPrompts: PanelPrompt[],\n  projectId: string,\n  settings?: GenerationSettings,\n  onProgress?: (event: ProgressEvent) => void\n): Promise<GeneratedPanel[]>\n```\n\nImplementation:\n1. Initialize results array\n2. For each panelPrompt (with index):\n   a. Call generatePanelWithRetry(panelPrompt, projectId, settings)\n   b. On success:\n      - Add to results array\n      - Call onProgress with percentage = (index + 1) / total * 100\n   c. On failure (after max retries):\n      - Update panel status to 'failed' in DB\n      - Log error\n      - Continue to next panel\n\n3. Return results array (may include failed panels with status='failed')\n\n**Method: generateParallel() - High Speed (Rate Limit Aware)**\n\n```typescript\nprivate async generateParallel(\n  panelPrompts: PanelPrompt[],\n  projectId: string,\n  settings?: GenerationSettings,\n  onProgress?: (event: ProgressEvent) => void\n): Promise<GeneratedPanel[]>\n```\n\nImplementation:\n1. **Batch Control:**\n   - Max concurrent = Math.floor(CONFIG.DALLE_RATE_LIMIT_PER_MINUTE / 2)\n   - Split panelPrompts into batches of max concurrent\n\n2. **For each batch:**\n   - Create Promise.allSettled() for batch\n   - Wait for all to settle\n   - Process results\n   - Send progress update to onProgress\n   - Delay before next batch (respect rate limits)\n\n3. **Failure Handling:**\n   - Collect failed panels\n   - Retry failed panels sequentially (exponential backoff)\n   - Update onProgress for retries\n\n4. **Return results array**\n\n**Method: generatePanelWithRetry() - Core Retry Logic**\n\n```typescript\nprivate async generatePanelWithRetry(\n  panelPrompt: PanelPrompt,\n  projectId: string,\n  settings?: GenerationSettings,\n  retryCount: number = 0\n): Promise<GeneratedPanel>\n```\n\nImplementation:\n1. Try to generate panel via generatePanel()\n2. On success: Return GeneratedPanel\n3. On failure:\n   - If retryCount < CONFIG.MAX_RETRIES_PER_PANEL:\n     - Calculate backoff delay: 2^retryCount * 1000ms (exponential)\n     - Wait for delay\n     - Recursively call with retryCount++\n   - If max retries exceeded:\n     - Throw error with panel index info\n\n**Exponential Backoff Formula:**\n```\ndelay(attempt) = base_delay * (2 ^ attempt) + random jitter\ndelay(0) = 1000ms (1 second)\ndelay(1) = 2000ms (2 seconds)\ndelay(2) = 4000ms (4 seconds)\n+ add random(0, 500ms) jitter to avoid thundering herd\n```\n\n**Method: downloadAndSave() - Store Images Locally**\n\n```typescript\nprivate async downloadAndSave(\n  imageUrl: string,\n  projectId: string,\n  panelIndex: number\n): Promise<string>\n```\n\nImplementation:\n1. Create project uploads directory if not exists: `{STORAGE_PATH}/{projectId}/`\n2. Fetch image from URL using axios or native fetch:\n   ```typescript\n   const response = await fetch(imageUrl);\n   const arrayBuffer = await response.arrayBuffer();\n   const buffer = Buffer.from(arrayBuffer);\n   ```\n3. Save to disk:\n   ```typescript\n   const filePath = path.join(this.uploadDir, projectId, `panel_${panelIndex}.png`);\n   await fs.writeFile(filePath, buffer);\n   ```\n4. Return relative or absolute path\n\n**Method: getImageSize() - Aspect Ratio to DALL-E Size**\n\n```typescript\nprivate getImageSize(\n  aspectRatio: string\n): '1024x1024' | '1792x1024' | '1024x1792'\n```\n\nSelf-explanatory mapping function.\n\n### Route Handler Integration\n\nImplement in `backend/src/routes/manga.ts`:\n\n**POST /api/manga/:projectId/generate-images - SSE Streaming**\n\n```typescript\nrouter.post('/:projectId/generate-images', async (req, res, next) => {\n  try {\n    const { projectId } = req.params;\n    const { panelIndices, batchMode } = req.body as GenerateImagesRequest;\n\n    // Set up SSE response\n    res.setHeader('Content-Type', 'text/event-stream');\n    res.setHeader('Cache-Control', 'no-cache');\n    res.setHeader('Connection', 'keep-alive');\n\n    // Fetch project and panels from DB\n    const project = await getProject(projectId);\n    if (!project) throw new NotFoundError('Project');\n\n    // Filter panels (all or specific indices)\n    const panelsToGenerate = project.panels.filter(\n      p => !panelIndices || panelIndices.includes(p.panelIndex)\n    );\n\n    // Generate prompts array\n    const panelPrompts: PanelPrompt[] = panelsToGenerate.map(p => ({\n      panelIndex: p.panelIndex,\n      dallePrompt: p.prompt!,\n      storyBeat: p.storyBeat!,\n      visualFocus: 'main subject',  // Extract from context if available\n      transitionType: 'cut',        // Default, could be from DB\n    }));\n\n    // Call imageGenerationService\n    imageGenService.generateBatch(\n      panelPrompts,\n      projectId,\n      batchMode,\n      project.generationSettings,\n      (progressEvent) => {\n        // Send progress as SSE\n        res.write(`data: ${JSON.stringify(progressEvent)}\\n\\n`);\n      }\n    ).then(generatedPanels => {\n      // Update database with generated images\n      for (const panel of generatedPanels) {\n        updatePanelImage(panel.panelIndex, {\n          imageUrl: panel.imageUrl,\n          imageFilePath: panel.localFilePath,\n          revisedPrompt: panel.revisedPrompt,\n          status: panel.revisedPrompt ? 'generated' : 'generated',\n        });\n      }\n\n      // Send completion event\n      res.write(`data: ${JSON.stringify({\n        type: 'complete',\n        message: 'Image generation complete',\n        totalCost: generatedPanels.reduce((sum, p) => sum + p.costUsd, 0),\n      })}\\n\\n`);\n\n      res.end();\n    }).catch(err => {\n      res.write(`data: ${JSON.stringify({\n        type: 'error',\n        message: err.message,\n      })}\\n\\n`);\n      res.end();\n    });\n  } catch (err) {\n    next(err);\n  }\n});\n```\n\n### Cost Tracking\n\n**Implementation:**\n- Track cost per API call in GeneratedPanel.costUsd\n- Sum across all panels: `totalCost = sum(generatedPanels.map(p => p.costUsd))`\n- Update project.totalCost in DB: `project.totalCost += generatedPanels totalCost`\n- Log costs for each call (useful for budget monitoring)\n\n**Cost Constants (from types.ts):**\n```typescript\nAPI_COSTS = {\n  VISION_PER_CALL: 0.025,    // GPT-4V\n  DALLE3_STANDARD: 0.040,    // per image\n  DALLE3_HD: 0.080,          // per image\n}\n```\n\n### Testing Requirements\n\n```bash\n# 1. Set up test project (with prompts from Task 2)\nPROJECT_ID=\"test-project-id\"\n# Or use output from Task 2 test\n\n# 2. Generate images (sequential mode)\ncurl -X POST http://localhost:5000/api/manga/$PROJECT_ID/generate-images \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"batchMode\": \"sequential\"}' \\\n  -H \"Accept: text/event-stream\"\n\n# 3. Verify local image files created\nls -la uploads/$PROJECT_ID/\n\n# 4. Check database for updated image URLs\nsqlite3 data/koma-fill.db \"SELECT panelIndex, imageFilePath, status FROM panels WHERE projectId='$PROJECT_ID';\"\n\n# 5. Verify cost tracking\ncurl http://localhost:5000/api/manga/$PROJECT_ID | jq '.totalCost'\n```\n\n### Files This Task Provides to Other Agents\n\n- **Generated panel images** - Stored in uploads/{projectId}/, used by Task 4\n- **Image file paths** - Updated in DB, used by Task 4 for layout composition\n- **Cost tracking** - Used by frontend for budget display\n\n### Output Validation Checklist\n\n- [ ] DALL-E 3 API calls succeed with valid prompts\n- [ ] Retry logic works with exponential backoff\n- [ ] Images download and save to {STORAGE_PATH}/{projectId}/\n- [ ] SSE streaming sends progress events correctly\n- [ ] onProgress callback fires with accurate percentage\n- [ ] Cost calculation correct (0.04 standard, 0.08 HD)\n- [ ] Panel records updated with imageUrl and imageFilePath\n- [ ] Sequential and parallel modes both work\n- [ ] Rate limiting respected (max 5 calls/min by default)\n- [ ] Error handling for network issues, API failures\n- [ ] No TypeScript compilation errors\n\n---\n\n## Task 4: + (Agent D)\n### Manga Layout Composition & Multi-Format Export\n\n**Time Estimate:** 45-60 minutes\n**Difficulty:** Intermediate (Sharp library learning curve)\n**Dependencies:** Task 1 (DB), Task 3 (generated images)\n\n### Objective\nImplement Sharp-based manga layout composition with grid calculation, panel resizing and positioning, border/gutter rendering, speech bubble overlay, and PNG/JPG/PDF export functionality.\n\n### Target Files to Create/Modify\n\n```\nbackend/\n src/\n     services/\n        layoutEngine.ts          [IMPLEMENT] Panel composition & layout\n        exportService.ts         [CREATE] PNG/JPG/PDF export\n     utils/\n         imageProcessor.ts        [HELPER] Image processing utilities\n```\n\n### TypeScript Interfaces\n\n```typescript\n// Layout composition result\nComposedLayout {\n  buffer: Buffer;                    // PNG image buffer\n  width: number;                     // Page width (px)\n  height: number;                    // Page height (px)\n  format: 'png';\n  panelPositions: PanelPosition[];   // Position data for each panel\n}\n\nPanelPosition {\n  panelIndex: number;\n  x: number;                         // Offset from top-left (px)\n  y: number;\n  width: number;                     // Panel width (px)\n  height: number;                    // Panel height (px)\n}\n\n// Input to layout engine\nLayoutConfig {\n  totalPanels: number;               // 4, 6, 8, etc.\n  format: LayoutFormat;              // 'vertical' | 'horizontal' | 'square'\n  readingOrder: ReadingOrder;        // 'japanese' | 'western'\n  gutterSize: number;                // Space between panels (px)\n  borderWidth: number;               // Panel border thickness (px)\n  borderColor: string;               // Hex color\n  backgroundColor: string;           // Hex color\n  pageWidth: number;                 // Canvas width (px)\n  pageHeight: number;                // Canvas height (px)\n}\n```\n\n### Implementation Details\n\n#### LayoutEngine (`backend/src/services/layoutEngine.ts`)\n\n**Method: composePanels() - Main Composition Function**\n\n```typescript\nasync composePanels(\n  panelImagePaths: string[],\n  config: LayoutConfig = DEFAULT_LAYOUT_CONFIG\n): Promise<ComposedLayout>\n```\n\nImplementation Steps:\n\n1. **Calculate Grid:**\n   ```typescript\n   const grid = this.calculateGrid(panelImagePaths.length, config);\n   // Returns { cols: number, rows: number }\n   ```\n   Already implemented - use it.\n\n2. **Calculate Panel Positions:**\n   ```typescript\n   const positions = this.calculatePanelPositions(grid, config);\n   // Returns: PanelPosition[] with x, y, width, height for each panel\n   ```\n   Already implemented - use it.\n\n3. **Create Background Canvas:**\n   ```typescript\n   import sharp from 'sharp';\n\n   let canvas = sharp({\n     create: {\n       width: config.pageWidth,\n       height: config.pageHeight,\n       channels: 4,                    // RGBA\n       background: config.backgroundColor,  // Parsed from hex\n     }\n   });\n   ```\n\n4. **Load & Resize Panel Images:**\n   ```typescript\n   const composites = await Promise.all(\n     panelImagePaths.map(async (imgPath, i) => {\n       if (!fs.existsSync(imgPath)) {\n         throw new Error(`Panel image not found: ${imgPath}`);\n       }\n\n       const position = positions[i];\n       const resized = await sharp(imgPath)\n         .resize(position.width, position.height, {\n           fit: 'cover',              // Fill panel, crop if needed\n           withoutEnlargement: false\n         })\n         .toBuffer();\n\n       return {\n         input: resized,\n         left: position.x,\n         top: position.y\n       };\n     })\n   );\n   ```\n\n5. **Composite Panels Onto Canvas:**\n   ```typescript\n   let result = await canvas.composite(composites).png();\n   ```\n\n6. **Add Borders (Optional - if borderWidth > 0):**\n   - Use SVG overlay to draw rectangles around each panel\n   - Create SVG:\n     ```svg\n     <svg width=\"800\" height=\"1200\">\n       <!-- For each panel position -->\n       <rect x=\"10\" y=\"10\" width=\"390\" height=\"590\"\n             fill=\"none\" stroke=\"black\" stroke-width=\"2\" />\n     </svg>\n     ```\n   - Composite SVG overlay:\n     ```typescript\n     const borderSvg = this.generateBorderSvg(positions, config);\n     result = await result.composite([{\n       input: borderSvg,\n       top: 0,\n       left: 0\n     }]);\n     ```\n\n7. **Return ComposedLayout:**\n   ```typescript\n   const buffer = await result.toBuffer();\n   return {\n     buffer,\n     width: config.pageWidth,\n     height: config.pageHeight,\n     format: 'png',\n     panelPositions: positions\n   };\n   ```\n\n**Method: addSpeechBubbles() - Overlay Speech Bubbles**\n\n```typescript\nasync addSpeechBubbles(\n  layout: ComposedLayout,\n  bubbles: SpeechBubble[]\n): Promise<ComposedLayout>\n```\n\nImplementation:\n\n1. **For each speech bubble:**\n   - Get panel position from layout.panelPositions[bubble.panelIndex]\n   - Calculate bubble position within panel:\n     - 'top'  y = panel.y + 30\n     - 'middle'  y = panel.y + panel.height/2 - 30\n     - 'bottom'  y = panel.y + panel.height - 60\n\n2. **Create SVG speech bubble:**\n   ```typescript\n   const svg = this.generateSpeechBubbleSvg(bubble, position, style);\n   // Generates SVG with text, shape varies by style:\n   // 'rounded', 'cloud', 'spiked', 'rectangular'\n   ```\n\n3. **Composite all bubble SVGs:**\n   ```typescript\n   let result = sharp(layout.buffer);\n   const bubbleSvgs = bubbles.map((bubble, idx) =>\n     this.generateSpeechBubbleSvg(bubble, panelPositions[bubble.panelIndex])\n   );\n\n   result = await result.composite(\n     bubbleSvgs.map((svg, i) => ({ input: svg }))\n   );\n   ```\n\n4. **Return updated ComposedLayout**\n\n**Helper: generateBorderSvg()**\n```typescript\nprivate generateBorderSvg(\n  positions: PanelPosition[],\n  config: LayoutConfig\n): Buffer\n```\n\nGenerate SVG with rectangle borders around each panel:\n```svg\n<svg width=\"800\" height=\"1200\">\n  <rect x=\"10\" y=\"10\" width=\"390\" height=\"590\"\n        fill=\"none\" stroke=\"#000000\" stroke-width=\"2\" />\n  <!-- repeated for each panel -->\n</svg>\n```\n\nConvert to Buffer and return.\n\n**Helper: generateSpeechBubbleSvg()**\n```typescript\nprivate generateSpeechBubbleSvg(\n  bubble: SpeechBubble,\n  panelPosition: PanelPosition,\n  targetY: number  // top/middle/bottom\n): Buffer\n```\n\nGenerate SVG with speech bubble shape. Example for 'rounded':\n```svg\n<svg width=\"300\" height=\"100\">\n  <!-- Rounded rectangle -->\n  <path d=\"M 10,10 Q 10,10 20,10 L 270,10 Q 280,10 280,20 L 280,70 Q 280,80 270,80 L 30,80 Q 20,80 20,70 L 20,40 L 0,60 L 20,50 L 20,20 Q 20,10 10,10\"\n        fill=\"white\" stroke=\"black\" stroke-width=\"1\" />\n  <text x=\"20\" y=\"50\" font-family=\"Arial\" font-size=\"14\">Your text here</text>\n</svg>\n```\n\nReturn SVG as Buffer via:\n```typescript\nconst svgBuffer = Buffer.from(svgString, 'utf-8');\n```\n\n### ExportService (`backend/src/services/exportService.ts`) - NEW FILE\n\nImplement export to PNG, JPG, PDF formats.\n\n```typescript\nexport class ExportService {\n  async exportPNG(\n    layout: ComposedLayout,\n    filepath: string,\n    compression: 'low' | 'medium' | 'high'\n  ): Promise<void>\n\n  async exportJPG(\n    layout: ComposedLayout,\n    filepath: string,\n    quality: number  // 60-95\n  ): Promise<void>\n\n  async exportPDF(\n    layout: ComposedLayout,\n    filepath: string,\n    metadata: { title?: string; author?: string }\n  ): Promise<void>\n}\n```\n\n**exportPNG():**\n```typescript\nasync exportPNG(layout, filepath, compression) {\n  const compressionLevel = compression === 'high' ? 9 : compression === 'medium' ? 6 : 1;\n  await sharp(layout.buffer)\n    .png({ compressionLevel })\n    .toFile(filepath);\n}\n```\n\n**exportJPG():**\n```typescript\nasync exportJPG(layout, filepath, quality = 80) {\n  await sharp(layout.buffer)\n    .jpeg({ quality, mozjpeg: true })\n    .toFile(filepath);\n}\n```\n\n**exportPDF():**\nRequires pdfkit library:\n```typescript\nimport PDFDocument from 'pdfkit';\nimport { createWriteStream } from 'fs';\n\nasync exportPDF(layout, filepath, metadata = {}) {\n  const doc = new PDFDocument({\n    size: [layout.width, layout.height]\n  });\n\n  if (metadata.title) doc.title(metadata.title);\n  if (metadata.author) doc.author(metadata.author);\n\n  // Add image to PDF\n  doc.image(layout.buffer, 0, 0, {\n    width: layout.width,\n    height: layout.height\n  });\n\n  doc.pipe(createWriteStream(filepath));\n  doc.end();\n}\n```\n\n### Route Handler Integration\n\nImplement in `backend/src/routes/manga.ts`:\n\n**POST /api/manga/:projectId/layout**\n```typescript\nrouter.post('/:projectId/layout', async (req: Request, res: Response, next: NextFunction) => {\n  try {\n    const { projectId } = req.params;\n    const { speechBubbles } = req.body as GenerateLayoutRequest;\n\n    // Fetch project and panels from DB\n    const project = await getProject(projectId);\n    if (!project) throw new NotFoundError('Project');\n\n    // Get panel image paths\n    const panelPaths = project.panels\n      .sort((a, b) => a.panelIndex - b.panelIndex)\n      .map(p => p.imageFilePath)\n      .filter(path => path !== undefined);\n\n    // Compose layout\n    const layoutEngine = new LayoutEngine();\n    let layout = await layoutEngine.composePanels(panelPaths, project.layoutConfig);\n\n    // Add speech bubbles if provided\n    if (speechBubbles && speechBubbles.length > 0) {\n      layout = await layoutEngine.addSpeechBubbles(layout, speechBubbles);\n    }\n\n    // Save layout buffer to temporary file for preview\n    const layoutPath = path.join(CONFIG.STORAGE_PATH, projectId, 'layout.png');\n    await fs.writeFile(layoutPath, layout.buffer);\n\n    // Update project status\n    await updateProject(projectId, { status: 'complete' });\n\n    // Return layout info\n    res.json({\n      message: 'Layout composed successfully',\n      projectId,\n      layoutPath: `/uploads/${projectId}/layout.png`,\n      panelPositions: layout.panelPositions,\n      dimensions: { width: layout.width, height: layout.height }\n    });\n  } catch (err) {\n    next(err);\n  }\n});\n```\n\n**POST /api/manga/:projectId/export**\n```typescript\nrouter.post('/:projectId/export', async (req: Request, res: Response, next: NextFunction) => {\n  try {\n    const { projectId } = req.params;\n    const { format, compression, resolution, title, author } = req.body as ExportRequest;\n\n    // Fetch project layout\n    const layoutPath = path.join(CONFIG.STORAGE_PATH, projectId, 'layout.png');\n    if (!fs.existsSync(layoutPath)) {\n      throw new Error('Layout not yet generated. Call /layout endpoint first.');\n    }\n\n    const layoutBuffer = await fs.promises.readFile(layoutPath);\n    const layout: ComposedLayout = {\n      buffer: layoutBuffer,\n      width: 800,  // From project.layoutConfig\n      height: 1200,\n      format: 'png',\n      panelPositions: []  // Could fetch from DB if needed\n    };\n\n    // Export to requested format\n    const exportService = new ExportService();\n    const timestamp = Date.now();\n    const exportPath = path.join(CONFIG.STORAGE_PATH, projectId, `manga_${timestamp}.${format}`);\n\n    if (format === 'png') {\n      await exportService.exportPNG(layout, exportPath, compression as 'low' | 'medium' | 'high');\n    } else if (format === 'jpg') {\n      const qualityMap = { low: 60, medium: 80, high: 95 };\n      await exportService.exportJPG(layout, exportPath, qualityMap[compression]);\n    } else if (format === 'pdf') {\n      await exportService.exportPDF(layout, exportPath, { title, author });\n    }\n\n    // Update project status\n    await updateProject(projectId, { status: 'exported' });\n\n    res.json({\n      message: 'Export successful',\n      projectId,\n      format,\n      downloadUrl: `/uploads/${projectId}/manga_${timestamp}.${format}`,\n      filePath: exportPath\n    });\n  } catch (err) {\n    next(err);\n  }\n});\n```\n\n### Testing Requirements\n\n```bash\n# 1. Generate layout from Task 3 images\nPROJECT_ID=\"test-project-id\"\ncurl -X POST http://localhost:5000/api/manga/$PROJECT_ID/layout \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\n    \"speechBubbles\": [\n      {\n        \"panelIndex\": 0,\n        \"text\": \"Wow!\",\n        \"position\": \"top\",\n        \"style\": \"rounded\"\n      }\n    ]\n  }'\n\n# 2. View composed layout\nopen http://localhost:5000/uploads/$PROJECT_ID/layout.png\n\n# 3. Export to PNG\ncurl -X POST http://localhost:5000/api/manga/$PROJECT_ID/export \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\n    \"format\": \"png\",\n    \"compression\": \"medium\",\n    \"resolution\": \"web\",\n    \"title\": \"My Manga\"\n  }'\n\n# 4. Export to PDF\ncurl -X POST http://localhost:5000/api/manga/$PROJECT_ID/export \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\n    \"format\": \"pdf\",\n    \"compression\": \"medium\",\n    \"title\": \"My Manga\",\n    \"author\": \"AI Creator\"\n  }'\n\n# 5. Verify files exist\nls -lh uploads/$PROJECT_ID/\n```\n\n### Files This Task Provides to Other Agents\n\n- **Composed layout image** - Used by frontend for preview\n- **Export files** - PNG/JPG/PDF outputs for download\n- **Layout metadata** - Panel positions for debugging/display\n\n### Output Validation Checklist\n\n- [ ] calculateGrid() and calculatePanelPositions() methods work correctly\n- [ ] composePanels() successfully combines images with sharp\n- [ ] Borders render correctly around panels\n- [ ] Speech bubbles overlay without distortion\n- [ ] Multiple speech bubble styles work ('rounded', 'cloud', 'spiked', 'rectangular')\n- [ ] Layout PNG saved and readable\n- [ ] exportPNG() produces valid PNG files\n- [ ] exportJPG() produces valid JPG files with quality control\n- [ ] exportPDF() produces valid PDF with metadata\n- [ ] /layout endpoint returns correct panel positions\n- [ ] /export endpoint returns download URLs\n- [ ] Compression settings affect file size appropriately\n- [ ] No TypeScript compilation errors\n\n---\n\n## Task 5: React (Agent E)\n### Complete React UI with Component Implementation\n\n**Time Estimate:** 60-80 minutes\n**Difficulty:** Intermediate (React component patterns)\n**Dependencies:** Tasks 1-4 (backend API must be running)\n\n### Objective\nComplete all React components for the koma-fill frontend including image upload with drag-drop, story prompt editor, panel grid with drag-and-drop reordering, complete manga generation workflow orchestration, real-time SSE progress updates, and multi-format export options. Configure Tailwind CSS for styling.\n\n### Target Files to Create/Modify\n\n```\nfrontend/\n src/\n    components/\n       ImageUploader.tsx           [IMPLEMENT] Dropzone with position selector\n       StoryPromptEditor.tsx       [ENHANCE] Add sample prompts\n       PanelGrid.tsx               [IMPLEMENT] Drag-and-drop reordering\n       LayoutSelector.tsx          [VERIFY] Layout config UI\n       ExportOptions.tsx           [VERIFY] Export format selection\n       ProgressBar.tsx             [CREATE] Real-time progress display\n    hooks/\n       useMangaGeneration.ts       [IMPLEMENT] Full workflow orchestration\n    services/\n       apiClient.ts                [IMPLEMENT] API client with SSE support\n    pages/\n       CreateMangaPage.tsx         [IMPLEMENT] Main workflow page\n       PreviewPage.tsx             [IMPLEMENT] Result preview & download\n    App.tsx                         [UPDATE] Routing\n    main.tsx                        [VERIFY] Entry point\n    index.css                       [UPDATE] Tailwind directives\n tailwind.config.js                  [CREATE] Tailwind configuration\n postcss.config.js                   [CREATE] PostCSS configuration\n package.json                        [UPDATE] Add Tailwind dependencies\n tsconfig.json                       [VERIFY] TypeScript config\n```\n\n### TypeScript Interfaces (from `frontend/src/types/index.ts`)\n\nAlready defined - reference for component props.\n\n### Implementation Details\n\n#### 1. Tailwind CSS Setup\n\n**Install Dependencies:**\n```bash\ncd frontend\nnpm install -D tailwindcss postcss autoprefixer\nnpx tailwindcss init -p\n```\n\n**tailwind.config.js:**\n```javascript\nexport default {\n  content: [\n    './index.html',\n    './src/**/*.{js,ts,jsx,tsx}',\n  ],\n  theme: {\n    extend: {\n      colors: {\n        manga: {\n          dark: '#1a1a1a',\n          light: '#f5f5f5',\n        }\n      }\n    },\n  },\n  plugins: [],\n}\n```\n\n**postcss.config.js:**\n```javascript\nexport default {\n  plugins: {\n    tailwindcss: {},\n    autoprefixer: {},\n  },\n}\n```\n\n**frontend/src/index.css:**\n```css\n@tailwind base;\n@tailwind components;\n@tailwind utilities;\n\n@layer components {\n  .btn-primary {\n    @apply px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700 transition;\n  }\n  .btn-secondary {\n    @apply px-4 py-2 bg-gray-300 text-gray-800 rounded-lg hover:bg-gray-400 transition;\n  }\n  .input-field {\n    @apply w-full px-3 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500;\n  }\n}\n```\n\n#### 2. API Client (`frontend/src/services/apiClient.ts`)\n\n```typescript\nimport { MangaProject, Panel, GenerationProgress, ProgressEvent } from '../types';\n\nconst API_BASE = import.meta.env.VITE_API_URL || 'http://localhost:5000/api';\n\nexport class APIClient {\n  /**\n   * Create new manga project\n   */\n  async createProject(name: string, storyPrompt: string, layoutConfig?: any) {\n    const response = await fetch(`${API_BASE}/manga/create`, {\n      method: 'POST',\n      headers: { 'Content-Type': 'application/json' },\n      body: JSON.stringify({\n        projectName: name,\n        storyPrompt,\n        layoutConfig\n      })\n    });\n    if (!response.ok) throw new Error(await response.text());\n    return response.json() as Promise<MangaProject>;\n  }\n\n  /**\n   * Upload key images\n   */\n  async uploadImages(projectId: string, files: File[]) {\n    const formData = new FormData();\n    files.forEach(file => formData.append('images', file));\n\n    const response = await fetch(`${API_BASE}/manga/${projectId}/upload`, {\n      method: 'POST',\n      body: formData\n    });\n    if (!response.ok) throw new Error(await response.text());\n    return response.json();\n  }\n\n  /**\n   * Analyze images using Vision API\n   */\n  async analyzeImages(projectId: string, depth: 'quick' | 'detailed' = 'quick') {\n    const response = await fetch(`${API_BASE}/manga/${projectId}/analyze`, {\n      method: 'POST',\n      headers: { 'Content-Type': 'application/json' },\n      body: JSON.stringify({ analysisDepth: depth })\n    });\n    if (!response.ok) throw new Error(await response.text());\n    return response.json();\n  }\n\n  /**\n   * Generate panel prompts\n   */\n  async generatePrompts(projectId: string, storyPrompt: string, panelCount: number) {\n    const response = await fetch(`${API_BASE}/manga/${projectId}/generate-prompts`, {\n      method: 'POST',\n      headers: { 'Content-Type': 'application/json' },\n      body: JSON.stringify({\n        storyPrompt,\n        panelCount,\n        characterConsistency: true\n      })\n    });\n    if (!response.ok) throw new Error(await response.text());\n    return response.json() as Promise<Panel[]>;\n  }\n\n  /**\n   * Generate images via DALL-E 3 (SSE streaming)\n   */\n  streamImageGeneration(\n    projectId: string,\n    batchMode: 'sequential' | 'parallel',\n    onProgress: (event: ProgressEvent) => void,\n    onError: (error: Error) => void\n  ): () => void {\n    const eventSource = new EventSource(\n      `${API_BASE}/manga/${projectId}/generate-images?batchMode=${batchMode}`\n    );\n\n    eventSource.onmessage = (event) => {\n      try {\n        const data = JSON.parse(event.data);\n        onProgress(data);\n      } catch (e) {\n        console.error('Failed to parse SSE message:', e);\n      }\n    };\n\n    eventSource.onerror = () => {\n      onError(new Error('Generation failed or connection lost'));\n      eventSource.close();\n    };\n\n    // Return cleanup function\n    return () => eventSource.close();\n  }\n\n  /**\n   * Compose layout with speech bubbles\n   */\n  async composeLayout(projectId: string, speechBubbles?: any) {\n    const response = await fetch(`${API_BASE}/manga/${projectId}/layout`, {\n      method: 'POST',\n      headers: { 'Content-Type': 'application/json' },\n      body: JSON.stringify({ speechBubbles })\n    });\n    if (!response.ok) throw new Error(await response.text());\n    return response.json();\n  }\n\n  /**\n   * Export to PNG/JPG/PDF\n   */\n  async exportManga(\n    projectId: string,\n    format: 'png' | 'jpg' | 'pdf',\n    compression: 'low' | 'medium' | 'high' = 'medium',\n    title?: string,\n    author?: string\n  ) {\n    const response = await fetch(`${API_BASE}/manga/${projectId}/export`, {\n      method: 'POST',\n      headers: { 'Content-Type': 'application/json' },\n      body: JSON.stringify({\n        format,\n        compression,\n        resolution: 'web',\n        title,\n        author\n      })\n    });\n    if (!response.ok) throw new Error(await response.text());\n    return response.json();\n  }\n\n  /**\n   * Fetch project details\n   */\n  async getProject(projectId: string) {\n    const response = await fetch(`${API_BASE}/manga/${projectId}`);\n    if (!response.ok) throw new Error(await response.text());\n    return response.json() as Promise<MangaProject>;\n  }\n\n  /**\n   * Reorder panels\n   */\n  async reorderPanels(projectId: string, panelOrder: number[]) {\n    const response = await fetch(`${API_BASE}/manga/${projectId}/reorder`, {\n      method: 'PUT',\n      headers: { 'Content-Type': 'application/json' },\n      body: JSON.stringify({ panelOrder })\n    });\n    if (!response.ok) throw new Error(await response.text());\n    return response.json();\n  }\n}\n\nexport const apiClient = new APIClient();\n```\n\n#### 3. useMangaGeneration Hook (`frontend/src/hooks/useMangaGeneration.ts`)\n\n```typescript\nimport { useState, useCallback } from 'react';\nimport { apiClient } from '../services/apiClient';\nimport { MangaProject, GenerationProgress, UploadedImage } from '../types';\n\nexport function useMangaGeneration() {\n  const [project, setProject] = useState<MangaProject | null>(null);\n  const [progress, setProgress] = useState<GenerationProgress>({\n    stage: 'idle',\n    currentStep: 0,\n    totalSteps: 0,\n    percentage: 0,\n    message: ''\n  });\n  const [error, setError] = useState<string | null>(null);\n\n  /**\n   * Complete workflow: Create  Upload  Analyze  Generate Prompts  Generate Images  Layout\n   */\n  const generateManga = useCallback(async (\n    projectName: string,\n    storyPrompt: string,\n    uploadedImages: UploadedImage[],\n    layoutConfig: any,\n    generationSettings: any\n  ) => {\n    try {\n      setError(null);\n\n      // Stage 1: Create project\n      setProgress({\n        stage: 'uploading',\n        currentStep: 0,\n        totalSteps: 5,\n        percentage: 20,\n        message: 'Creating project...'\n      });\n      const newProject = await apiClient.createProject(projectName, storyPrompt, layoutConfig);\n      setProject(newProject);\n\n      // Stage 2: Upload images\n      setProgress({\n        stage: 'uploading',\n        currentStep: 1,\n        totalSteps: 5,\n        percentage: 40,\n        message: 'Uploading reference images...'\n      });\n      const files = uploadedImages.map(img => img.file);\n      await apiClient.uploadImages(newProject.id, files);\n\n      // Stage 3: Analyze images\n      setProgress({\n        stage: 'analyzing',\n        currentStep: 2,\n        totalSteps: 5,\n        percentage: 60,\n        message: 'Analyzing images with Vision API...'\n      });\n      await apiClient.analyzeImages(newProject.id, 'detailed');\n\n      // Stage 4: Generate prompts\n      setProgress({\n        stage: 'generating_prompts',\n        currentStep: 3,\n        totalSteps: 5,\n        percentage: 70,\n        message: 'Generating panel prompts...'\n      });\n      await apiClient.generatePrompts(\n        newProject.id,\n        storyPrompt,\n        layoutConfig.totalPanels\n      );\n\n      // Stage 5: Generate images (with SSE streaming)\n      setProgress({\n        stage: 'generating_images',\n        currentStep: 4,\n        totalSteps: 5,\n        percentage: 75,\n        message: 'Starting image generation...'\n      });\n\n      await new Promise<void>((resolve, reject) => {\n        const cleanup = apiClient.streamImageGeneration(\n          newProject.id,\n          'sequential',  // or 'parallel' based on user preference\n          (progressEvent) => {\n            if (progressEvent.type === 'complete') {\n              setProgress(prev => ({\n                ...prev,\n                percentage: 90,\n                message: 'Image generation complete!'\n              }));\n              resolve();\n            } else if (progressEvent.type === 'error') {\n              reject(new Error(progressEvent.error || 'Generation failed'));\n            } else {\n              setProgress({\n                stage: 'generating_images',\n                currentStep: 4 + (progressEvent.currentStep || 0) * 0.1,\n                totalSteps: 5,\n                percentage: 75 + (progressEvent.percentage || 0) * 0.15,\n                message: progressEvent.message,\n                currentPanelIndex: progressEvent.panelIndex\n              });\n            }\n          },\n          reject\n        );\n      });\n\n      // Stage 6: Compose layout\n      setProgress({\n        stage: 'composing_layout',\n        currentStep: 5,\n        totalSteps: 5,\n        percentage: 95,\n        message: 'Composing final layout...'\n      });\n      await apiClient.composeLayout(newProject.id);\n\n      // Complete\n      const finalProject = await apiClient.getProject(newProject.id);\n      setProject(finalProject);\n      setProgress({\n        stage: 'idle',\n        currentStep: 5,\n        totalSteps: 5,\n        percentage: 100,\n        message: 'Manga generation complete!'\n      });\n\n    } catch (err) {\n      const errorMsg = err instanceof Error ? err.message : 'Unknown error';\n      setError(errorMsg);\n      setProgress({\n        stage: 'idle',\n        currentStep: 0,\n        totalSteps: 0,\n        percentage: 0,\n        message: `Error: ${errorMsg}`\n      });\n    }\n  }, []);\n\n  const exportManga = useCallback(async (\n    projectId: string,\n    format: 'png' | 'jpg' | 'pdf',\n    compression: 'low' | 'medium' | 'high' = 'medium'\n  ) => {\n    try {\n      setError(null);\n      setProgress({\n        stage: 'exporting',\n        currentStep: 0,\n        totalSteps: 1,\n        percentage: 50,\n        message: `Exporting as ${format.toUpperCase()}...`\n      });\n\n      const result = await apiClient.exportManga(projectId, format, compression);\n\n      setProgress({\n        stage: 'idle',\n        currentStep: 1,\n        totalSteps: 1,\n        percentage: 100,\n        message: 'Export complete!'\n      });\n\n      return result;\n    } catch (err) {\n      const errorMsg = err instanceof Error ? err.message : 'Export failed';\n      setError(errorMsg);\n      throw err;\n    }\n  }, []);\n\n  return {\n    project,\n    progress,\n    error,\n    generateManga,\n    exportManga,\n    setError\n  };\n}\n```\n\n#### 4. Components\n\n**ImageUploader.tsx:**\n```typescript\nimport { useCallback, useState } from 'react';\nimport { UploadedImage, ImagePosition } from '../types';\n\ninterface ImageUploaderProps {\n  onImagesSelected: (images: UploadedImage[]) => void;\n}\n\nexport function ImageUploader({ onImagesSelected }: ImageUploaderProps) {\n  const [images, setImages] = useState<UploadedImage[]>([]);\n  const [selectedPosition, setSelectedPosition] = useState<ImagePosition>('start');\n\n  const handleDrop = useCallback((e: React.DragEvent) => {\n    e.preventDefault();\n    const files = Array.from(e.dataTransfer.files).filter(f => f.type.startsWith('image/'));\n    addImages(files);\n  }, []);\n\n  const handleFileInput = (e: React.ChangeEvent<HTMLInputElement>) => {\n    if (e.target.files) {\n      addImages(Array.from(e.target.files));\n    }\n  };\n\n  const addImages = (files: File[]) => {\n    const newImages = files.map(file => ({\n      file,\n      previewUrl: URL.createObjectURL(file),\n      position: selectedPosition\n    }));\n    setImages(prev => [...prev, ...newImages]);\n    onImagesSelected([...images, ...newImages]);\n  };\n\n  const removeImage = (index: number) => {\n    const updated = images.filter((_, i) => i !== index);\n    setImages(updated);\n    onImagesSelected(updated);\n  };\n\n  return (\n    <div className=\"w-full max-w-2xl\">\n      <div\n        onDrop={handleDrop}\n        onDragOver={e => e.preventDefault()}\n        className=\"border-2 border-dashed border-gray-300 rounded-lg p-8 text-center cursor-pointer hover:border-blue-500 transition\"\n      >\n        <p className=\"text-gray-600 mb-4\">Drag and drop images here or click to select</p>\n        <input\n          type=\"file\"\n          multiple\n          accept=\"image/*\"\n          onChange={handleFileInput}\n          className=\"hidden\"\n          id=\"image-input\"\n        />\n        <label htmlFor=\"image-input\" className=\"btn-primary cursor-pointer\">\n          Select Images\n        </label>\n      </div>\n\n      <div className=\"mt-4\">\n        <label className=\"block mb-2\">Position in Story:</label>\n        <select\n          value={selectedPosition}\n          onChange={e => setSelectedPosition(e.target.value as ImagePosition)}\n          className=\"input-field\"\n        >\n          <option value=\"start\">Start (Reference)</option>\n          <option value=\"end\">End (Reference)</option>\n          <option value={1}>Panel 1</option>\n          <option value={2}>Panel 2</option>\n        </select>\n      </div>\n\n      {images.length > 0 && (\n        <div className=\"mt-6 grid grid-cols-2 gap-4\">\n          {images.map((img, idx) => (\n            <div key={idx} className=\"relative\">\n              <img src={img.previewUrl} alt={`Preview ${idx}`} className=\"rounded-lg w-full h-48 object-cover\" />\n              <button\n                onClick={() => removeImage(idx)}\n                className=\"absolute top-2 right-2 bg-red-500 text-white rounded-full w-6 h-6 flex items-center justify-center hover:bg-red-600\"\n              >\n                \n              </button>\n            </div>\n          ))}\n        </div>\n      )}\n    </div>\n  );\n}\n```\n\n**StoryPromptEditor.tsx (Enhanced):**\n```typescript\nimport { useState } from 'react';\n\ninterface StoryPromptEditorProps {\n  value: string;\n  onChange: (value: string) => void;\n}\n\nconst SAMPLE_PROMPTS = [\n  'A young ninja discovers their hidden powers and must save their village from a mysterious threat.',\n  'Two rival chefs compete in a cooking tournament, discovering they have more in common than they thought.',\n  'A time traveler must prevent a catastrophic event by gathering clues from different eras.',\n];\n\nexport function StoryPromptEditor({ value, onChange }: StoryPromptEditorProps) {\n  const [isExpanded, setIsExpanded] = useState(false);\n\n  return (\n    <div className=\"w-full max-w-2xl\">\n      <label className=\"block text-lg font-semibold mb-2\">Your Story Prompt</label>\n\n      <textarea\n        value={value}\n        onChange={e => onChange(e.target.value)}\n        placeholder=\"Write your manga story here. Be descriptive about characters, setting, and plot...\"\n        className=\"input-field h-32 resize-none\"\n      />\n\n      <div className=\"mt-4\">\n        <button\n          onClick={() => setIsExpanded(!isExpanded)}\n          className=\"text-blue-600 hover:underline text-sm\"\n        >\n          {isExpanded ? 'Hide' : 'Show'} Sample Prompts\n        </button>\n\n        {isExpanded && (\n          <div className=\"mt-3 space-y-2\">\n            {SAMPLE_PROMPTS.map((prompt, idx) => (\n              <button\n                key={idx}\n                onClick={() => onChange(prompt)}\n                className=\"block w-full text-left p-3 bg-gray-100 hover:bg-gray-200 rounded-lg text-sm transition\"\n              >\n                {prompt}\n              </button>\n            ))}\n          </div>\n        )}\n      </div>\n    </div>\n  );\n}\n```\n\n**PanelGrid.tsx (with Drag-and-Drop):**\n```typescript\nimport { useState } from 'react';\nimport { Panel } from '../types';\nimport { DndContext, closestCenter, KeyboardSensor, PointerSensor, useSensor, useSensors } from '@dnd-kit/core';\nimport { SortableContext, sortableKeyboardCoordinates, verticalListSortingStrategy, useSortable } from '@dnd-kit/sortable';\nimport { CSS } from '@dnd-kit/utilities';\n\nfunction SortablePanel({ panel }: { panel: Panel }) {\n  const { attributes, listeners, setNodeRef, transform, transition } = useSortable({ id: panel.id });\n  const style = { transform: CSS.Transform.toString(transform), transition };\n\n  return (\n    <div ref={setNodeRef} style={style} {...attributes} {...listeners} className=\"p-4\">\n      <div className=\"bg-white rounded-lg shadow p-4 cursor-grab active:cursor-grabbing\">\n        <img\n          src={panel.imageUrl}\n          alt={`Panel ${panel.panelIndex}`}\n          className=\"w-full h-auto rounded mb-2\"\n        />\n        <p className=\"text-sm text-gray-600\">{panel.storyBeat}</p>\n        <span className={`inline-block mt-2 px-2 py-1 rounded text-xs text-white ${\n          panel.status === 'generated' ? 'bg-green-500' :\n          panel.status === 'pending' ? 'bg-blue-500' :\n          'bg-red-500'\n        }`}>\n          {panel.status}\n        </span>\n      </div>\n    </div>\n  );\n}\n\ninterface PanelGridProps {\n  panels: Panel[];\n  onReorder: (newOrder: Panel[]) => void;\n}\n\nexport function PanelGrid({ panels, onReorder }: PanelGridProps) {\n  const sensors = useSensors(\n    useSensor(PointerSensor),\n    useSensor(KeyboardSensor, { coordinateGetter: sortableKeyboardCoordinates })\n  );\n\n  const handleDragEnd = (event: any) => {\n    const { active, over } = event;\n    if (over && active.id !== over.id) {\n      const oldIndex = panels.findIndex(p => p.id === active.id);\n      const newIndex = panels.findIndex(p => p.id === over.id);\n      const newPanels = [...panels];\n      [newPanels[oldIndex], newPanels[newIndex]] = [newPanels[newIndex], newPanels[oldIndex]];\n      onReorder(newPanels);\n    }\n  };\n\n  return (\n    <DndContext sensors={sensors} collisionDetection={closestCenter} onDragEnd={handleDragEnd}>\n      <SortableContext items={panels.map(p => p.id)} strategy={verticalListSortingStrategy}>\n        <div className=\"grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-4\">\n          {panels.map(panel => (\n            <SortablePanel key={panel.id} panel={panel} />\n          ))}\n        </div>\n      </SortableContext>\n    </DndContext>\n  );\n}\n```\n\n**ProgressBar.tsx:**\n```typescript\nimport { GenerationProgress } from '../types';\n\nexport function ProgressBar({ progress }: { progress: GenerationProgress }) {\n  return (\n    <div className=\"w-full max-w-2xl\">\n      <div className=\"mb-2 flex justify-between\">\n        <span className=\"text-sm font-semibold\">{progress.message}</span>\n        <span className=\"text-sm text-gray-600\">{Math.round(progress.percentage)}%</span>\n      </div>\n      <div className=\"w-full h-3 bg-gray-200 rounded-full overflow-hidden\">\n        <div\n          className=\"h-full bg-blue-600 transition-all duration-300\"\n          style={{ width: `${progress.percentage}%` }}\n        />\n      </div>\n    </div>\n  );\n}\n```\n\n#### 5. Pages\n\n**CreateMangaPage.tsx:**\n```typescript\nimport { useState } from 'react';\nimport { ImageUploader } from '../components/ImageUploader';\nimport { StoryPromptEditor } from '../components/StoryPromptEditor';\nimport { LayoutSelector } from '../components/LayoutSelector';\nimport { ProgressBar } from '../components/ProgressBar';\nimport { useMangaGeneration } from '../hooks/useMangaGeneration';\nimport { UploadedImage, LayoutConfig } from '../types';\n\nexport function CreateMangaPage() {\n  const [projectName, setProjectName] = useState('');\n  const [storyPrompt, setStoryPrompt] = useState('');\n  const [uploadedImages, setUploadedImages] = useState<UploadedImage[]>([]);\n  const [layoutConfig, setLayoutConfig] = useState<LayoutConfig>({\n    totalPanels: 4,\n    format: 'vertical',\n    readingOrder: 'japanese',\n    gutterSize: 10,\n    borderWidth: 2,\n    borderColor: '#000000',\n    backgroundColor: '#FFFFFF',\n    pageWidth: 800,\n    pageHeight: 1200\n  });\n\n  const { progress, error, generateManga } = useMangaGeneration();\n\n  const handleStart = async () => {\n    if (!projectName || !storyPrompt) {\n      alert('Please enter project name and story prompt');\n      return;\n    }\n\n    await generateManga(projectName, storyPrompt, uploadedImages, layoutConfig, {\n      imageStyle: 'manga style',\n      aspectRatio: 'square',\n      qualityLevel: 'standard'\n    });\n  };\n\n  return (\n    <div className=\"min-h-screen bg-gray-50 py-12 px-4\">\n      <div className=\"max-w-4xl mx-auto space-y-8\">\n        <h1 className=\"text-4xl font-bold text-center mb-2\">koma-fill</h1>\n        <p className=\"text-center text-gray-600\">AI-Powered Manga Panel Generator</p>\n\n        {error && <div className=\"bg-red-100 border border-red-400 text-red-700 px-4 py-3 rounded\">{error}</div>}\n\n        {progress.stage === 'idle' ? (\n          <div className=\"space-y-8\">\n            <div className=\"bg-white p-6 rounded-lg shadow\">\n              <label className=\"block text-lg font-semibold mb-2\">Project Name</label>\n              <input\n                type=\"text\"\n                value={projectName}\n                onChange={e => setProjectName(e.target.value)}\n                className=\"input-field\"\n                placeholder=\"My Awesome Manga\"\n              />\n            </div>\n\n            <div className=\"bg-white p-6 rounded-lg shadow\">\n              <StoryPromptEditor value={storyPrompt} onChange={setStoryPrompt} />\n            </div>\n\n            <div className=\"bg-white p-6 rounded-lg shadow\">\n              <ImageUploader onImagesSelected={setUploadedImages} />\n            </div>\n\n            <div className=\"bg-white p-6 rounded-lg shadow\">\n              <LayoutSelector config={layoutConfig} onChange={setLayoutConfig} />\n            </div>\n\n            <button onClick={handleStart} className=\"btn-primary w-full text-lg py-3\">\n              Generate Manga\n            </button>\n          </div>\n        ) : (\n          <div className=\"bg-white p-6 rounded-lg shadow\">\n            <ProgressBar progress={progress} />\n          </div>\n        )}\n      </div>\n    </div>\n  );\n}\n```\n\n**PreviewPage.tsx:**\n```typescript\nimport { useParams, useNavigate } from 'react-router-dom';\nimport { useEffect, useState } from 'react';\nimport { apiClient } from '../services/apiClient';\nimport { PanelGrid } from '../components/PanelGrid';\nimport { ExportOptions } from '../components/ExportOptions';\nimport { MangaProject } from '../types';\n\nexport function PreviewPage() {\n  const { projectId } = useParams<{ projectId: string }>();\n  const navigate = useNavigate();\n  const [project, setProject] = useState<MangaProject | null>(null);\n  const [loading, setLoading] = useState(true);\n\n  useEffect(() => {\n    if (projectId) {\n      apiClient.getProject(projectId).then(setProject).finally(() => setLoading(false));\n    }\n  }, [projectId]);\n\n  if (loading) return <div className=\"flex justify-center py-12\">Loading...</div>;\n  if (!project) return <div className=\"text-center py-12\">Project not found</div>;\n\n  return (\n    <div className=\"min-h-screen bg-gray-50 py-12 px-4\">\n      <div className=\"max-w-6xl mx-auto\">\n        <button onClick={() => navigate('/')} className=\"btn-secondary mb-6\"> Back</button>\n\n        <h1 className=\"text-3xl font-bold mb-2\">{project.name}</h1>\n        <p className=\"text-gray-600 mb-6\">Project Status: {project.status}</p>\n\n        {project.panels.length > 0 && (\n          <div className=\"bg-white p-6 rounded-lg shadow mb-8\">\n            <h2 className=\"text-2xl font-semibold mb-4\">Panels</h2>\n            <PanelGrid panels={project.panels} onReorder={() => {}} />\n          </div>\n        )}\n\n        <div className=\"bg-white p-6 rounded-lg shadow\">\n          <h2 className=\"text-2xl font-semibold mb-4\">Export</h2>\n          <ExportOptions projectId={project.id} />\n        </div>\n      </div>\n    </div>\n  );\n}\n```\n\n#### 6. Update App.tsx\n\n```typescript\nimport { BrowserRouter as Router, Routes, Route, Navigate } from 'react-router-dom';\nimport { CreateMangaPage } from './pages/CreateMangaPage';\nimport { PreviewPage } from './pages/PreviewPage';\nimport './index.css';\n\nexport default function App() {\n  return (\n    <Router>\n      <Routes>\n        <Route path=\"/\" element={<CreateMangaPage />} />\n        <Route path=\"/project/:projectId\" element={<PreviewPage />} />\n        <Route path=\"*\" element={<Navigate to=\"/\" />} />\n      </Routes>\n    </Router>\n  );\n}\n```\n\n### package.json Updates\n\nAdd dependencies:\n```bash\nnpm install -D tailwindcss postcss autoprefixer\nnpm install react-router-dom @dnd-kit/core @dnd-kit/sortable @dnd-kit/utilities\n```\n\n### Testing Requirements\n\n```bash\n# 1. Start backend (from Task 1)\ncd backend && npm run dev\n\n# 2. In another terminal, start frontend\ncd frontend && npm run dev\n\n# 3. Open browser: http://localhost:3000\n\n# 4. Test workflow:\n# - Enter project name and story\n# - Upload reference images\n# - Configure layout\n# - Click \"Generate Manga\"\n# - Watch progress bar\n# - See panel grid with images\n# - Export to PNG/JPG/PDF\n```\n\n### Files This Task Uses from Other Agents\n\n- **API endpoints** from Task 1 (database & routes)\n- **Analysis data** from Task 2 (character consistency)\n- **Generated images** from Task 3 (panel images)\n- **Composed layouts** from Task 4 (final manga)\n\n### Output Validation Checklist\n\n- [ ] Tailwind CSS configured and working\n- [ ] ImageUploader component with drag-drop works\n- [ ] react-dropzone integration functional\n- [ ] StoryPromptEditor displays with sample prompts\n- [ ] Sample prompt insertion works\n- [ ] PanelGrid displays with drag-and-drop reordering\n- [ ] @dnd-kit integration functional\n- [ ] useMangaGeneration hook orchestrates full workflow\n- [ ] SSE progress streaming displays correctly\n- [ ] ProgressBar updates in real-time\n- [ ] apiClient makes correct API calls\n- [ ] All components have TypeScript types\n- [ ] CreateMangaPage workflow complete\n- [ ] PreviewPage shows generated manga\n- [ ] ExportOptions functional (PNG/JPG/PDF)\n- [ ] Routing works (create  preview)\n- [ ] Error handling displays user-friendly messages\n- [ ] npm run dev starts without errors\n- [ ] No TypeScript compilation errors\n\n---\n\n## Integration Testing (After All Tasks Complete)\n\nAfter all 5 agents finish their implementations, run the following integration tests:\n\n```bash\n# 1. Start backend\ncd /mnt/Projects/koma-fill/backend\nnpm install\nnpm run dev\n# Expected: \" koma-fill server running on http://localhost:5000\"\n\n# 2. Start frontend (new terminal)\ncd /mnt/Projects/koma-fill/frontend\nnpm install\nnpm run dev\n# Expected: \"VITE  ready in XXX ms\"\n\n# 3. Complete workflow test\n# Open http://localhost:3000 in browser\n# - Create project\n# - Upload 2 reference images\n# - Enter story prompt\n# - Select layout (4 panels)\n# - Click \"Generate Manga\"\n# - Wait for completion\n# - View generated panels\n# - Export to PNG\n# - Verify PNG file created in uploads/\n\n# 4. Verify database\nsqlite3 /mnt/Projects/koma-fill/data/koma-fill.db\n> SELECT COUNT(*) FROM projects;\n> SELECT COUNT(*) FROM panels;\n> SELECT COUNT(*) FROM keyImages;\n\n# 5. Check file structure\nls -la /mnt/Projects/koma-fill/uploads/\nls -la /mnt/Projects/koma-fill/data/\n\n# 6. API health check\ncurl http://localhost:5000/api/health\n# Expected: {\"status\":\"ok\",\"timestamp\":\"...\"}\n```\n\n### Known Integration Points to Verify\n\n- Task 1  Task 2: Panel prompts saved in DB, readable by frontend\n- Task 2  Task 3: Vision analysis influences character consistency in prompts\n- Task 3  Task 4: Generated images saved to disk, paths in database\n- Task 4  Task 5: Layout images served via `/uploads/` static directory\n- Task 5  All: Frontend calls all backend API endpoints successfully\n\n---\n\n## Success Criteria Summary\n\nAll 5 tasks completed when:\n\n1. **Backend (Task 1)**: Express server with SQLite database, all CRUD routes working\n2. **Vision & Prompts (Task 2)**: OpenAI Vision API analyzes images, GPT-4o generates DALL-E prompts\n3. **Image Generation (Task 3)**: DALL-E 3 generates 4+ images with retry logic, SSE progress works\n4. **Layout & Export (Task 4)**: Sharp composes panels into manga layout, exports PNG/JPG/PDF\n5. **Frontend (Task 5)**: React UI allows workflow from story  generated manga  export\n\n**Total Expected Time**: 4-5 hours per agent (can run in parallel)\n**Minimum Test Time**: 30 minutes for integration testing\n\nGood luck, KAMUI agents! \n\n---\n\n*Last Updated: 2025-02-12*\n*For issues or questions, refer to the specific task prompts above*\n: \nID: task-1770909068262-a5d61b\nBranch: task/task-1770909068262-a5d61b\nWorktree: Users/yuyafujita/Projects/koma-fill/.worktrees/task-1770909068262-a5d61b",
        "branchColor": "#e84f7f",
        "index": 24
      },
      {
        "type": "anchor",
        "label": "[] CodexCLI3: # KAMUI-4D Parallel T",
        "branch": "task/task-1770909068675-7f6691",
        "worktreePath": "/Users/yuyafujita/Projects/koma-fill/.worktrees/task-1770909068675-7f6691",
        "parentCommitHash": "1515fedca072442ad0656037229bce50b2e341f3",
        "lane": 10,
        "isMerged": false,
        "mergeCommitHash": null,
        "statusChildren": [
          {
            "type": "staged",
            "label": " [task/task-1770909068675-7f6691] (1)",
            "files": [
              "ackend/src/routes/manga.ts"
            ],
            "branch": "task/task-1770909068675-7f6691",
            "targetCommitHash": "1515fedca072442ad0656037229bce50b2e341f3",
            "worktreePath": "/Users/yuyafujita/Projects/koma-fill/.worktrees/task-1770909068675-7f6691",
            "timestamp": 1770921960581,
            "sortOrder": 1,
            "lane": 10,
            "branchColor": "#e8a84f",
            "index": 23
          }
        ],
        "isDefaultWorktree": false,
        "renderMode": "node",
        "shouldHide": false,
        "tagLabel": "task/task-1770909068675-7f6691",
        "taskId": "task-1770909068675-7f6691",
        "taskStatus": "working",
        "taskStatusLabel": "",
        "taskName": "CodexCLI3: # KAMUI-4D Parallel Task Prompts for koma-fill\n## Manga Generation AI System - Multi-Agent Implementation Guide\n\n**Version:** 1.0\n**Project:** koma-fill - AI-powered manga panel generation system\n**Target:** KAMUI-4D Editor (Multi-AI CLI parallel execution)\n\n---\n\n## How to Use These Prompts in KAMUI-4D\n\nThis document contains **5 independent task prompts** designed to run in parallel across multiple AI coding agents. Each prompt is self-contained and can be executed independently without blocking other tasks.\n\n### Setup Instructions\n\n1. **Install dependencies** (run once before starting tasks):\n   ```bash\n   cd /mnt/Projects/koma-fill/backend\n   npm install\n\n   cd /mnt/Projects/koma-fill/frontend\n   npm install\n   ```\n\n2. **Environment Configuration**:\n   Create `/mnt/Projects/koma-fill/.env`:\n   ```\n   NODE_ENV=development\n   PORT=5000\n   BASE_URL=http://localhost:5000\n   OPENAI_API_KEY=your_openai_api_key_here\n   OPENAI_ORG_ID=your_org_id_optional\n   DATABASE_PATH=./data/koma-fill.db\n   STORAGE_PATH=./uploads\n   MAX_IMAGE_SIZE_MB=20\n   DALLE_RATE_LIMIT_PER_MINUTE=5\n   VISION_RATE_LIMIT_PER_MINUTE=30\n   MAX_RETRIES_PER_PANEL=3\n   ALLOWED_ORIGINS=http://localhost:3000\n   ```\n\n3. **Execution Strategy**:\n   - Copy each task prompt below into a separate KAMUI-4D session/agent\n   - **Tasks 1-5 can ALL start simultaneously** (no blocking dependencies)\n   - Each task should run independently in its own AI CLI session\n   - Monitor each agent's progress via console output\n   - **Integration testing** should happen after all 5 tasks complete (see bottom of doc)\n\n4. **Task Dependencies**:\n   ```\n   Task 1 (Backend)  provides database & API contracts\n   Task 2 (Vision)  uses Task 1's API, reads backend/src/models/types.ts\n   Task 3 (Images)  uses Task 1's API, reads backend/src/models/types.ts\n   Task 4 (Layout)  uses Task 1's API, reads backend/src/models/types.ts\n   Task 5 (Frontend)  calls Tasks 1-4 via REST API\n   ```\n   **All tasks can start immediately** - they communicate via file system and API contracts.\n\n---\n\n## Task 1: Backend (Agent A)\n### Express Server, SQLite Database & CRUD Routes Foundation\n\n**Time Estimate:** 45-60 minutes\n**Difficulty:** Intermediate\n**Dependencies:** None (this is the foundation layer)\n\n### Objective\nSet up a fully functional Express.js backend with SQLite database, implement CRUD operations for manga projects and panels, configure file upload handling with multer, and provide a solid API foundation for other agents to build upon.\n\n### Target Files to Create/Modify\n\n```\nbackend/\n src/\n    database/\n       connection.ts          [NEW] SQLite connection & initialization\n       schema.ts              [NEW] Table schema definitions\n    index.ts                   [MODIFY] Add DB initialization\n    app.ts                     [COMPLETE] Already done - verify middleware\n    routes/\n       manga.ts               [IMPLEMENT] Route handlers with DB calls\n    middleware/\n        errorHandler.ts        [VERIFY] Already complete\n uploads/                        [CREATE] Directory for image storage\n data/                           [CREATE] Directory for SQLite DB\n```\n\n### TypeScript Interfaces (from `/mnt/Projects/koma-fill/backend/src/models/types.ts`)\n\nKey types you'll use:\n```typescript\n// Core entities\nMangaProject {\n  id: string;                    // UUID\n  name: string;\n  description?: string;\n  status: ProjectStatus;         // 'draft' | 'analyzing' | 'generating' | 'complete' | 'exported'\n  layoutConfig: LayoutConfig;\n  generationSettings: GenerationSettings;\n  panels: Panel[];\n  keyImages: KeyImage[];\n  totalCost: number;\n  createdAt: string;             // ISO datetime\n  updatedAt: string;\n}\n\nPanel {\n  id: string;                    // UUID\n  projectId: string;\n  panelIndex: number;            // 0-based\n  imageUrl?: string;\n  imageFilePath?: string;\n  prompt?: string;\n  storyBeat?: string;\n  speechBubbleText?: string;\n  status: PanelStatus;           // 'pending' | 'generated' | 'failed' | 'placeholder'\n  retryCount: number;\n  generatedAt?: string;\n  createdAt: string;\n}\n\nKeyImage {\n  id: string;                    // UUID\n  projectId: string;\n  imageFilePath: string;\n  position: ImagePosition;       // 'start' | 'end' | number\n  analysis?: ImageAnalysis;\n  createdAt: string;\n}\n\nLayoutConfig {\n  totalPanels: number;           // 4, 6, 8, etc.\n  format: LayoutFormat;          // 'vertical' | 'horizontal' | 'square'\n  readingOrder: ReadingOrder;    // 'japanese' | 'western'\n  gutterSize: number;            // px\n  borderWidth: number;           // px\n  borderColor: string;           // hex #RRGGBB\n  backgroundColor: string;       // hex\n  pageWidth: number;             // px\n  pageHeight: number;            // px\n}\n\nGenerationSettings {\n  imageStyle: string;            // e.g., \"manga style, black and white ink\"\n  aspectRatio: 'square' | 'wide' | 'tall';\n  qualityLevel: 'standard' | 'hd';\n  negativePrompt?: string;\n  seed?: number;\n}\n```\n\n### Implementation Checklist\n\n#### 1. Create Database Connection Module (`backend/src/database/connection.ts`)\n```typescript\n// Requirements:\n- Initialize better-sqlite3 connection\n- Create/open database at DATABASE_PATH from .env\n- Export initDatabase() async function\n- Enable foreign keys constraint\n- Handle database file creation if needed\n- Connection should be cached/singleton\n```\n\n#### 2. Create Database Schema Module (`backend/src/database/schema.ts`)\n```typescript\n// SQL Schema Requirements:\nCREATE TABLE projects (\n  id TEXT PRIMARY KEY,\n  name TEXT NOT NULL,\n  description TEXT,\n  status TEXT NOT NULL,\n  layoutConfig JSON NOT NULL,\n  generationSettings JSON NOT NULL,\n  totalCost REAL DEFAULT 0,\n  createdAt TEXT NOT NULL,\n  updatedAt TEXT NOT NULL\n);\n\nCREATE TABLE panels (\n  id TEXT PRIMARY KEY,\n  projectId TEXT NOT NULL,\n  panelIndex INTEGER NOT NULL,\n  imageUrl TEXT,\n  imageFilePath TEXT,\n  prompt TEXT,\n  storyBeat TEXT,\n  speechBubbleText TEXT,\n  status TEXT NOT NULL,\n  retryCount INTEGER DEFAULT 0,\n  generatedAt TEXT,\n  createdAt TEXT NOT NULL,\n  FOREIGN KEY (projectId) REFERENCES projects(id)\n);\n\nCREATE TABLE keyImages (\n  id TEXT PRIMARY KEY,\n  projectId TEXT NOT NULL,\n  imageFilePath TEXT NOT NULL,\n  position TEXT NOT NULL,\n  analysis JSON,\n  createdAt TEXT NOT NULL,\n  FOREIGN KEY (projectId) REFERENCES projects(id)\n);\n\nCREATE INDEX idx_project_status ON projects(status);\nCREATE INDEX idx_panel_project ON panels(projectId);\nCREATE INDEX idx_panel_status ON panels(status);\n```\n\n#### 3. Modify `backend/src/index.ts`\n```typescript\n// Add:\n- Import { initDatabase } from './database/connection'\n- Call await initDatabase() before app.listen()\n- Log database initialization success\n```\n\n#### 4. Create Repository Layer (`backend/src/repositories/`)\n```typescript\n// Create:\n- ProjectRepository with methods:\n  - createProject(data: CreateMangaRequest): Promise<MangaProject>\n  - getProject(id: string): Promise<MangaProject | null>\n  - listProjects(limit: number, offset: number): Promise<MangaProject[]>\n  - updateProject(id: string, updates: Partial<MangaProject>): Promise<MangaProject>\n  - deleteProject(id: string): Promise<void>\n\n- PanelRepository with methods:\n  - createPanel(projectId: string, data: Panel): Promise<Panel>\n  - getPanelsByProject(projectId: string): Promise<Panel[]>\n  - getPanel(panelId: string): Promise<Panel | null>\n  - updatePanel(panelId: string, updates: Partial<Panel>): Promise<Panel>\n  - updatePanelStatus(panelId: string, status: PanelStatus): Promise<void>\n\n- KeyImageRepository with methods:\n  - createKeyImage(projectId: string, data: KeyImage): Promise<KeyImage>\n  - getKeyImages(projectId: string): Promise<KeyImage[]>\n  - updateKeyImageAnalysis(imageId: string, analysis: ImageAnalysis): Promise<void>\n```\n\n#### 5. Implement Routes in `backend/src/routes/manga.ts`\nReplace TODO comments with actual implementations:\n\n- **POST /api/manga/create**\n  - Validate CreateMangaRequest using Joi\n  - Generate unique project ID (uuid)\n  - Create project in database with 'draft' status\n  - Create initial panel records (count = layoutConfig.totalPanels)\n  - Return created MangaProject with 201 status\n\n- **POST /api/manga/:projectId/upload**\n  - Files already handled by multer middleware\n  - Save KeyImage records to database with file paths\n  - Store position information\n  - Return array of KeyImage objects\n\n- **GET /api/manga/:projectId**\n  - Fetch project + panels + key images from database\n  - Return complete MangaProject object\n  - Throw NotFoundError if project doesn't exist\n\n- **GET /api/manga**\n  - Implement pagination (limit/offset query params)\n  - Return array of projects\n  - Include total count header\n\n- **PUT /api/manga/:projectId/reorder**\n  - Parse ReorderPanelsRequest body\n  - Update panelIndex for each panel based on new order\n  - Return updated panels array\n\n### Testing Requirements\n\nAfter implementation, verify:\n\n```bash\n# 1. Database initialization\nnpm run dev\n# Check console: \" configured\" for database\n\n# 2. Create project\ncurl -X POST http://localhost:5000/api/manga/create \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\n    \"projectName\": \"Test Manga\",\n    \"storyPrompt\": \"A hero on a quest\",\n    \"layoutConfig\": { \"totalPanels\": 4 }\n  }'\n\n# 3. Get project\ncurl http://localhost:5000/api/manga/{projectId}\n\n# 4. Upload images\ncurl -X POST http://localhost:5000/api/manga/{projectId}/upload \\\n  -F \"images=@test1.jpg\" \\\n  -F \"images=@test2.jpg\"\n\n# 5. Check database\nsqlite3 data/koma-fill.db \"SELECT * FROM projects; SELECT * FROM panels;\"\n```\n\n### Files This Task Provides to Other Agents\n\n- **Database schema** - Tasks 2, 3, 4, 5 will read/write to these tables\n- **API contracts** - manga.ts route signatures that Tasks 2-4 will call\n- **File storage structure** - uploads/ directory path that Task 3 will use\n- **Type definitions** - already in backend/src/models/types.ts (reference only)\n\n### Output Validation Checklist\n\n- [ ] Database file created at `data/koma-fill.db`\n- [ ] All 3 tables created with correct schema\n- [ ] Repositories implement CRUD operations\n- [ ] All route handlers work without TODO comments\n- [ ] multer uploads save files to `uploads/` directory\n- [ ] POST /create returns 201 with MangaProject object\n- [ ] GET /:projectId returns full project with panels\n- [ ] Error handler catches and responds appropriately\n- [ ] No TypeScript compilation errors\n- [ ] npm run dev starts without errors\n\n---\n\n## Task 2: + (Agent B)\n### Vision API Integration & DALL-E Prompt Generation\n\n**Time Estimate:** 50-60 minutes\n**Difficulty:** Intermediate\n**Dependencies:** Task 1 (needs database & API routes available)\n\n### Objective\nImplement OpenAI Vision API integration to analyze uploaded key images and extract character/style information. Then implement story-to-panel prompt generation using GPT-4o to create DALL-E 3 compatible prompts that maintain consistency across panels.\n\n### Target Files to Create/Modify\n\n```\nbackend/\n src/\n     services/\n         imageAnalysisService.ts      [IMPLEMENT] Vision API analysis\n         promptGenerationService.ts   [CREATE] Story  panel prompts\n```\n\n### System Prompts (Already Provided)\n\nBoth vision analysis prompts are defined in `imageAnalysisService.ts`:\n- `QUICK_ANALYSIS_PROMPT` - fast, ~500 tokens\n- `DETAILED_ANALYSIS_PROMPT` - thorough, ~2000 tokens\n\nThese guide the Vision API to return structured JSON matching the `ImageAnalysis` interface.\n\n### TypeScript Interfaces\n\n```typescript\n// Input: Key image file path (from Task 1)\n// Output: ImageAnalysis object\n\nImageAnalysis {\n  description: string;\n  characters: CharacterInfo[];\n  objects: string[];\n  colors: string[];\n  composition: string;\n  mood: string;\n  artStyle: string;\n  suggestedTransitions: string[];\n}\n\nCharacterInfo {\n  name?: string;\n  appearance: string;        // detailed physical description\n  emotion: string;\n  position: string;          // screen position (e.g., \"center-left\")\n}\n\n// Panel prompt generation\nPanelPrompt {\n  panelIndex: number;\n  dallePrompt: string;       // Full DALL-E 3 prompt (100-300 words)\n  storyBeat: string;         // What happens in this panel\n  visualFocus: string;       // Main visual element\n  transitionType: TransitionType;  // 'cut' | 'pan' | 'zoom_in' | 'zoom_out' | 'fade' | 'action'\n  suggestedDialogue?: string;\n}\n```\n\n### Implementation Details\n\n#### ImageAnalysisService (`backend/src/services/imageAnalysisService.ts`)\n\n**Constructor:**\n```typescript\nconstructor() {\n  this.openai = new OpenAI({\n    apiKey: CONFIG.OPENAI_API_KEY,\n    organization: CONFIG.OPENAI_ORG_ID\n  });\n}\n```\n\n**Method: analyzeImage(imageBase64: string, depth: 'quick' | 'detailed')**\n- Input: Base64-encoded image data from KeyImage file\n- Implementation:\n  1. Read image file and convert to Base64 (if not already)\n  2. Call `this.openai.chat.completions.create()`:\n     - model: CONFIG.VISION_MODEL ('gpt-4o')\n     - messages: [\n       { role: 'system', content: QUICK_ANALYSIS_PROMPT or DETAILED_ANALYSIS_PROMPT }\n       { role: 'user', content: [\n         { type: 'image_url', image_url: { url: `data:image/png;base64,${imageBase64}` } }\n       ]}\n     ]\n     - response_format: { type: 'json_object' }\n     - max_tokens: depth === 'quick' ? 500 : 2000\n  3. Parse response.choices[0].message.content as JSON\n  4. Validate against ImageAnalysis schema\n  5. Return ImageAnalysis object\n\n**Method: analyzeMultiple(images, depth)**\n- Input: Array of { base64, position } objects\n- Use Promise.all with rate limiting (max CONFIG.VISION_RATE_LIMIT_PER_MINUTE calls/min)\n- Implement backoff if rate limited\n- Return array of ImageAnalysis objects\n\n**Method: extractCharacters(analysis)**\n- Optional: Deep-dive character extraction\n- Can call another Vision API pass if needed for more detail\n\n#### PromptGenerationService (NEW FILE - `backend/src/services/promptGenerationService.ts`)\n\n**Constructor:**\n```typescript\nconstructor() {\n  this.openai = new OpenAI({ apiKey: CONFIG.OPENAI_API_KEY });\n}\n```\n\n**Method: generatePanelPrompts(request: GeneratePromptsRequest)**\n\nInput:\n```typescript\nGeneratePromptsRequest {\n  storyPrompt: string;           // User's story\n  panelCount: number;            // Total panels to generate\n  characterConsistency: boolean; // Whether to maintain character consistency\n}\n```\n\nImplementation:\n1. **Story Breakdown Phase:**\n   - Call GPT-4o to split story into N panel beats\n   - System prompt should guide structure like:\n   ```\n   \"You are a manga story expert. Break the provided story into exactly {panelCount}\n    distinct visual beats. Each beat should be 1-2 sentences describing what happens\n    visually in that panel. Format as JSON array of objects with 'panelIndex' and 'beat' fields.\"\n   ```\n\n2. **Character Consistency Analysis:**\n   - If characterConsistency=true and keyImages were analyzed:\n     - Retrieve stored ImageAnalysis for key images\n     - Create character consistency profile (appearance, emotion arcs, etc.)\n     - Include in subsequent prompts\n\n3. **DALL-E 3 Prompt Generation:**\n   - For each story beat, create detailed DALL-E 3 prompt\n   - System prompt pattern:\n   ```\n   \"You are a DALL-E 3 prompt expert specializing in manga panels.\n    Given a story beat, generate a detailed visual prompt (100-300 words) that:\n    - Specifies art style: {generationSettings.imageStyle}\n    - Maintains character consistency: {characterProfile}\n    - Follows manga composition principles\n    - Uses specific visual terms (angle, lighting, pose, emotion)\n    - Avoids abstract concepts; be concrete and visual\n    - Follows DALL-E 3 content policy\n\n    Return JSON with: { dallePrompt, visualFocus, transitionType, suggestedDialogue }\"\n   ```\n\n4. **Transition Logic:**\n   - Analyze flow between consecutive beats\n   - Suggest transition type ('cut', 'pan', 'zoom_in', etc.)\n   - Update imageUrl in previous panel to support transitions\n\n5. **Return Value:**\n   - Array of PanelPrompt objects, one per panel\n   - Each with populated dallePrompt, storyBeat, visualFocus, transitionType\n\n### Database Integration\n\nAfter generating prompts, save to Panel table:\n- Update each panel's `prompt` field with `dallePrompt`\n- Update `storyBeat` field\n- Update `status` to 'pending' (ready for image generation)\n\n### API Integration\n\nImplement route handlers in `backend/src/routes/manga.ts`:\n\n**POST /api/manga/:projectId/analyze**\n```typescript\n// 1. Fetch project and keyImages from DB\n// 2. Read image files and convert to Base64\n// 3. Call imageAnalysisService.analyzeMultiple()\n// 4. Store analysis results in DB (keyImages.analysis)\n// 5. Update project status to 'analyzing'  'complete'\n// 6. Return analysis results\n```\n\n**POST /api/manga/:projectId/generate-prompts**\n```typescript\n// 1. Validate GeneratePromptsRequest\n// 2. Fetch project and keyImages analyses from DB\n// 3. Call promptGenerationService.generatePanelPrompts()\n// 4. Update panel records with generated prompts\n// 5. Update project status to 'generating'\n// 6. Return array of PanelPrompt objects\n```\n\n### Testing Requirements\n\n```bash\n# 1. Prepare test image\n# (Use any PNG/JPG with a character or scene)\n\n# 2. Create project and upload image (Task 1)\nPROJECT_ID=$(curl -s -X POST http://localhost:5000/api/manga/create \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"projectName\":\"Test\",\"storyPrompt\":\"A hero finds treasure\"}' | jq -r '.id')\n\n# 3. Upload test image\ncurl -X POST http://localhost:5000/api/manga/$PROJECT_ID/upload \\\n  -F \"images=@test_image.jpg\"\n\n# 4. Analyze images\ncurl -X POST http://localhost:5000/api/manga/$PROJECT_ID/analyze \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"analysisDepth\":\"quick\"}'\n\n# 5. Generate prompts\ncurl -X POST http://localhost:5000/api/manga/$PROJECT_ID/generate-prompts \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\n    \"storyPrompt\": \"A hero finds treasure in a dark cave\",\n    \"panelCount\": 4,\n    \"characterConsistency\": true\n  }'\n\n# 6. Verify output\ncurl http://localhost:5000/api/manga/$PROJECT_ID | jq '.panels[].prompt'\n```\n\n### Files This Task Provides to Other Agents\n\n- **Panel prompt data** - Stored in DB panels table, used by Task 3 for image generation\n- **Character analysis** - Used by Task 5 frontend for display\n- **Art style consistency** - Guides Task 3's image generation\n\n### Output Validation Checklist\n\n- [ ] ImageAnalysisService.analyzeImage() calls Vision API successfully\n- [ ] Vision API responses parse correctly to ImageAnalysis\n- [ ] PromptGenerationService generates DALL-E-compatible prompts\n- [ ] Panel prompts maintain character consistency (if enabled)\n- [ ] Transition types are correctly assigned\n- [ ] All panel records updated in database with prompts\n- [ ] /analyze endpoint returns ImageAnalysis array\n- [ ] /generate-prompts endpoint returns PanelPrompt array\n- [ ] Error handling for API failures (rate limits, auth, etc.)\n- [ ] No TypeScript compilation errors\n\n---\n\n## Task 3: DALL-E 3 (Agent C)\n### Image Generation with Retry Logic & Progress Streaming\n\n**Time Estimate:** 50-70 minutes\n**Difficulty:** Intermediate-Advanced\n**Dependencies:** Task 1 (DB & API), Task 2 (panel prompts)\n\n### Objective\nImplement DALL-E 3 image generation with robust error handling, exponential backoff retry logic, local image storage, Server-Sent Events (SSE) streaming for real-time progress updates, and cost tracking per API call.\n\n### Target Files to Create/Modify\n\n```\nbackend/\n src/\n     services/\n         imageGenerationService.ts    [IMPLEMENT] DALL-E 3 API integration\n         (imageProcessor.ts)          [REFERENCE] Utility for image processing\n```\n\n### TypeScript Interfaces\n\n```typescript\nGeneratedPanel {\n  panelIndex: number;\n  imageUrl: string;              // DALL-E public URL (temporary)\n  localFilePath: string;         // /uploads/{projectId}/panel_{index}.png\n  prompt: string;                // Original prompt sent\n  revisedPrompt?: string;        // DALL-E 3's revised prompt (if modified)\n  costUsd: number;               // API call cost\n}\n\n// Request type\nGenerateImagesRequest {\n  panelIndices?: number[];       // undefined = all panels\n  batchMode: 'sequential' | 'parallel';\n}\n\n// Progress event (sent via SSE)\nProgressEvent {\n  type: 'progress' | 'complete' | 'error';\n  stage: string;                 // 'generating_images'\n  currentStep: number;           // Current panel index\n  totalSteps: number;            // Total panels\n  percentage: number;            // 0-100\n  message: string;               // Human-readable status\n  panelId?: string;\n  panelIndex?: number;\n  error?: string;                // Error message if type='error'\n}\n```\n\n### Implementation Details\n\n#### ImageGenerationService (`backend/src/services/imageGenerationService.ts`)\n\n**Constructor & Initialization:**\n```typescript\nconstructor() {\n  this.openai = new OpenAI({ apiKey: CONFIG.OPENAI_API_KEY });\n  this.uploadDir = path.resolve(CONFIG.STORAGE_PATH);\n}\n```\n\n**Method: generatePanel() - Single Panel Generation**\n\n```typescript\nasync generatePanel(\n  prompt: string,\n  panelIndex: number,\n  projectId: string,\n  settings?: GenerationSettings\n): Promise<GeneratedPanel>\n```\n\nImplementation:\n1. **Image Size Calculation:**\n   - Map aspectRatio to DALL-E 3 size:\n     - 'square'  '1024x1024'\n     - 'wide'  '1792x1024'\n     - 'tall'  '1024x1792'\n\n2. **API Call (with retry logic in wrapper):**\n   ```typescript\n   const response = await this.openai.images.generate({\n     model: CONFIG.DALLE_MODEL,           // 'dall-e-3'\n     prompt: prompt,\n     n: 1,\n     size: size,\n     quality: settings?.qualityLevel === 'hd' ? 'hd' : 'standard',\n     style: 'natural',                    // or 'vivid' for more dramatic\n   });\n   ```\n\n3. **Extract Response Data:**\n   - imageUrl = response.data[0].url\n   - revisedPrompt = response.data[0].revised_prompt\n   - Calculate cost based on settings.qualityLevel:\n     - standard: $0.040 per image\n     - hd: $0.080 per image\n\n4. **Download & Save Image:**\n   - Call this.downloadAndSave(imageUrl, projectId, panelIndex)\n   - Saves as PNG: `{STORAGE_PATH}/{projectId}/panel_{panelIndex}.png`\n   - Returns localFilePath\n\n5. **Return GeneratedPanel object**\n\n**Method: generateBatch() - Batch Generation with Mode Selection**\n\n```typescript\nasync generateBatch(\n  panelPrompts: PanelPrompt[],\n  projectId: string,\n  batchMode: 'sequential' | 'parallel',\n  settings?: GenerationSettings,\n  onProgress?: (event: ProgressEvent) => void\n): Promise<GeneratedPanel[]>\n```\n\nImplementation:\n1. Validate inputs\n2. Route to sequential or parallel handler\n3. Call onProgress callback with progress events\n4. Return array of GeneratedPanel\n\n**Method: generateSequential() - Rate-Limit Friendly**\n\n```typescript\nprivate async generateSequential(\n  panelPrompts: PanelPrompt[],\n  projectId: string,\n  settings?: GenerationSettings,\n  onProgress?: (event: ProgressEvent) => void\n): Promise<GeneratedPanel[]>\n```\n\nImplementation:\n1. Initialize results array\n2. For each panelPrompt (with index):\n   a. Call generatePanelWithRetry(panelPrompt, projectId, settings)\n   b. On success:\n      - Add to results array\n      - Call onProgress with percentage = (index + 1) / total * 100\n   c. On failure (after max retries):\n      - Update panel status to 'failed' in DB\n      - Log error\n      - Continue to next panel\n\n3. Return results array (may include failed panels with status='failed')\n\n**Method: generateParallel() - High Speed (Rate Limit Aware)**\n\n```typescript\nprivate async generateParallel(\n  panelPrompts: PanelPrompt[],\n  projectId: string,\n  settings?: GenerationSettings,\n  onProgress?: (event: ProgressEvent) => void\n): Promise<GeneratedPanel[]>\n```\n\nImplementation:\n1. **Batch Control:**\n   - Max concurrent = Math.floor(CONFIG.DALLE_RATE_LIMIT_PER_MINUTE / 2)\n   - Split panelPrompts into batches of max concurrent\n\n2. **For each batch:**\n   - Create Promise.allSettled() for batch\n   - Wait for all to settle\n   - Process results\n   - Send progress update to onProgress\n   - Delay before next batch (respect rate limits)\n\n3. **Failure Handling:**\n   - Collect failed panels\n   - Retry failed panels sequentially (exponential backoff)\n   - Update onProgress for retries\n\n4. **Return results array**\n\n**Method: generatePanelWithRetry() - Core Retry Logic**\n\n```typescript\nprivate async generatePanelWithRetry(\n  panelPrompt: PanelPrompt,\n  projectId: string,\n  settings?: GenerationSettings,\n  retryCount: number = 0\n): Promise<GeneratedPanel>\n```\n\nImplementation:\n1. Try to generate panel via generatePanel()\n2. On success: Return GeneratedPanel\n3. On failure:\n   - If retryCount < CONFIG.MAX_RETRIES_PER_PANEL:\n     - Calculate backoff delay: 2^retryCount * 1000ms (exponential)\n     - Wait for delay\n     - Recursively call with retryCount++\n   - If max retries exceeded:\n     - Throw error with panel index info\n\n**Exponential Backoff Formula:**\n```\ndelay(attempt) = base_delay * (2 ^ attempt) + random jitter\ndelay(0) = 1000ms (1 second)\ndelay(1) = 2000ms (2 seconds)\ndelay(2) = 4000ms (4 seconds)\n+ add random(0, 500ms) jitter to avoid thundering herd\n```\n\n**Method: downloadAndSave() - Store Images Locally**\n\n```typescript\nprivate async downloadAndSave(\n  imageUrl: string,\n  projectId: string,\n  panelIndex: number\n): Promise<string>\n```\n\nImplementation:\n1. Create project uploads directory if not exists: `{STORAGE_PATH}/{projectId}/`\n2. Fetch image from URL using axios or native fetch:\n   ```typescript\n   const response = await fetch(imageUrl);\n   const arrayBuffer = await response.arrayBuffer();\n   const buffer = Buffer.from(arrayBuffer);\n   ```\n3. Save to disk:\n   ```typescript\n   const filePath = path.join(this.uploadDir, projectId, `panel_${panelIndex}.png`);\n   await fs.writeFile(filePath, buffer);\n   ```\n4. Return relative or absolute path\n\n**Method: getImageSize() - Aspect Ratio to DALL-E Size**\n\n```typescript\nprivate getImageSize(\n  aspectRatio: string\n): '1024x1024' | '1792x1024' | '1024x1792'\n```\n\nSelf-explanatory mapping function.\n\n### Route Handler Integration\n\nImplement in `backend/src/routes/manga.ts`:\n\n**POST /api/manga/:projectId/generate-images - SSE Streaming**\n\n```typescript\nrouter.post('/:projectId/generate-images', async (req, res, next) => {\n  try {\n    const { projectId } = req.params;\n    const { panelIndices, batchMode } = req.body as GenerateImagesRequest;\n\n    // Set up SSE response\n    res.setHeader('Content-Type', 'text/event-stream');\n    res.setHeader('Cache-Control', 'no-cache');\n    res.setHeader('Connection', 'keep-alive');\n\n    // Fetch project and panels from DB\n    const project = await getProject(projectId);\n    if (!project) throw new NotFoundError('Project');\n\n    // Filter panels (all or specific indices)\n    const panelsToGenerate = project.panels.filter(\n      p => !panelIndices || panelIndices.includes(p.panelIndex)\n    );\n\n    // Generate prompts array\n    const panelPrompts: PanelPrompt[] = panelsToGenerate.map(p => ({\n      panelIndex: p.panelIndex,\n      dallePrompt: p.prompt!,\n      storyBeat: p.storyBeat!,\n      visualFocus: 'main subject',  // Extract from context if available\n      transitionType: 'cut',        // Default, could be from DB\n    }));\n\n    // Call imageGenerationService\n    imageGenService.generateBatch(\n      panelPrompts,\n      projectId,\n      batchMode,\n      project.generationSettings,\n      (progressEvent) => {\n        // Send progress as SSE\n        res.write(`data: ${JSON.stringify(progressEvent)}\\n\\n`);\n      }\n    ).then(generatedPanels => {\n      // Update database with generated images\n      for (const panel of generatedPanels) {\n        updatePanelImage(panel.panelIndex, {\n          imageUrl: panel.imageUrl,\n          imageFilePath: panel.localFilePath,\n          revisedPrompt: panel.revisedPrompt,\n          status: panel.revisedPrompt ? 'generated' : 'generated',\n        });\n      }\n\n      // Send completion event\n      res.write(`data: ${JSON.stringify({\n        type: 'complete',\n        message: 'Image generation complete',\n        totalCost: generatedPanels.reduce((sum, p) => sum + p.costUsd, 0),\n      })}\\n\\n`);\n\n      res.end();\n    }).catch(err => {\n      res.write(`data: ${JSON.stringify({\n        type: 'error',\n        message: err.message,\n      })}\\n\\n`);\n      res.end();\n    });\n  } catch (err) {\n    next(err);\n  }\n});\n```\n\n### Cost Tracking\n\n**Implementation:**\n- Track cost per API call in GeneratedPanel.costUsd\n- Sum across all panels: `totalCost = sum(generatedPanels.map(p => p.costUsd))`\n- Update project.totalCost in DB: `project.totalCost += generatedPanels totalCost`\n- Log costs for each call (useful for budget monitoring)\n\n**Cost Constants (from types.ts):**\n```typescript\nAPI_COSTS = {\n  VISION_PER_CALL: 0.025,    // GPT-4V\n  DALLE3_STANDARD: 0.040,    // per image\n  DALLE3_HD: 0.080,          // per image\n}\n```\n\n### Testing Requirements\n\n```bash\n# 1. Set up test project (with prompts from Task 2)\nPROJECT_ID=\"test-project-id\"\n# Or use output from Task 2 test\n\n# 2. Generate images (sequential mode)\ncurl -X POST http://localhost:5000/api/manga/$PROJECT_ID/generate-images \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"batchMode\": \"sequential\"}' \\\n  -H \"Accept: text/event-stream\"\n\n# 3. Verify local image files created\nls -la uploads/$PROJECT_ID/\n\n# 4. Check database for updated image URLs\nsqlite3 data/koma-fill.db \"SELECT panelIndex, imageFilePath, status FROM panels WHERE projectId='$PROJECT_ID';\"\n\n# 5. Verify cost tracking\ncurl http://localhost:5000/api/manga/$PROJECT_ID | jq '.totalCost'\n```\n\n### Files This Task Provides to Other Agents\n\n- **Generated panel images** - Stored in uploads/{projectId}/, used by Task 4\n- **Image file paths** - Updated in DB, used by Task 4 for layout composition\n- **Cost tracking** - Used by frontend for budget display\n\n### Output Validation Checklist\n\n- [ ] DALL-E 3 API calls succeed with valid prompts\n- [ ] Retry logic works with exponential backoff\n- [ ] Images download and save to {STORAGE_PATH}/{projectId}/\n- [ ] SSE streaming sends progress events correctly\n- [ ] onProgress callback fires with accurate percentage\n- [ ] Cost calculation correct (0.04 standard, 0.08 HD)\n- [ ] Panel records updated with imageUrl and imageFilePath\n- [ ] Sequential and parallel modes both work\n- [ ] Rate limiting respected (max 5 calls/min by default)\n- [ ] Error handling for network issues, API failures\n- [ ] No TypeScript compilation errors\n\n---\n\n## Task 4: + (Agent D)\n### Manga Layout Composition & Multi-Format Export\n\n**Time Estimate:** 45-60 minutes\n**Difficulty:** Intermediate (Sharp library learning curve)\n**Dependencies:** Task 1 (DB), Task 3 (generated images)\n\n### Objective\nImplement Sharp-based manga layout composition with grid calculation, panel resizing and positioning, border/gutter rendering, speech bubble overlay, and PNG/JPG/PDF export functionality.\n\n### Target Files to Create/Modify\n\n```\nbackend/\n src/\n     services/\n        layoutEngine.ts          [IMPLEMENT] Panel composition & layout\n        exportService.ts         [CREATE] PNG/JPG/PDF export\n     utils/\n         imageProcessor.ts        [HELPER] Image processing utilities\n```\n\n### TypeScript Interfaces\n\n```typescript\n// Layout composition result\nComposedLayout {\n  buffer: Buffer;                    // PNG image buffer\n  width: number;                     // Page width (px)\n  height: number;                    // Page height (px)\n  format: 'png';\n  panelPositions: PanelPosition[];   // Position data for each panel\n}\n\nPanelPosition {\n  panelIndex: number;\n  x: number;                         // Offset from top-left (px)\n  y: number;\n  width: number;                     // Panel width (px)\n  height: number;                    // Panel height (px)\n}\n\n// Input to layout engine\nLayoutConfig {\n  totalPanels: number;               // 4, 6, 8, etc.\n  format: LayoutFormat;              // 'vertical' | 'horizontal' | 'square'\n  readingOrder: ReadingOrder;        // 'japanese' | 'western'\n  gutterSize: number;                // Space between panels (px)\n  borderWidth: number;               // Panel border thickness (px)\n  borderColor: string;               // Hex color\n  backgroundColor: string;           // Hex color\n  pageWidth: number;                 // Canvas width (px)\n  pageHeight: number;                // Canvas height (px)\n}\n```\n\n### Implementation Details\n\n#### LayoutEngine (`backend/src/services/layoutEngine.ts`)\n\n**Method: composePanels() - Main Composition Function**\n\n```typescript\nasync composePanels(\n  panelImagePaths: string[],\n  config: LayoutConfig = DEFAULT_LAYOUT_CONFIG\n): Promise<ComposedLayout>\n```\n\nImplementation Steps:\n\n1. **Calculate Grid:**\n   ```typescript\n   const grid = this.calculateGrid(panelImagePaths.length, config);\n   // Returns { cols: number, rows: number }\n   ```\n   Already implemented - use it.\n\n2. **Calculate Panel Positions:**\n   ```typescript\n   const positions = this.calculatePanelPositions(grid, config);\n   // Returns: PanelPosition[] with x, y, width, height for each panel\n   ```\n   Already implemented - use it.\n\n3. **Create Background Canvas:**\n   ```typescript\n   import sharp from 'sharp';\n\n   let canvas = sharp({\n     create: {\n       width: config.pageWidth,\n       height: config.pageHeight,\n       channels: 4,                    // RGBA\n       background: config.backgroundColor,  // Parsed from hex\n     }\n   });\n   ```\n\n4. **Load & Resize Panel Images:**\n   ```typescript\n   const composites = await Promise.all(\n     panelImagePaths.map(async (imgPath, i) => {\n       if (!fs.existsSync(imgPath)) {\n         throw new Error(`Panel image not found: ${imgPath}`);\n       }\n\n       const position = positions[i];\n       const resized = await sharp(imgPath)\n         .resize(position.width, position.height, {\n           fit: 'cover',              // Fill panel, crop if needed\n           withoutEnlargement: false\n         })\n         .toBuffer();\n\n       return {\n         input: resized,\n         left: position.x,\n         top: position.y\n       };\n     })\n   );\n   ```\n\n5. **Composite Panels Onto Canvas:**\n   ```typescript\n   let result = await canvas.composite(composites).png();\n   ```\n\n6. **Add Borders (Optional - if borderWidth > 0):**\n   - Use SVG overlay to draw rectangles around each panel\n   - Create SVG:\n     ```svg\n     <svg width=\"800\" height=\"1200\">\n       <!-- For each panel position -->\n       <rect x=\"10\" y=\"10\" width=\"390\" height=\"590\"\n             fill=\"none\" stroke=\"black\" stroke-width=\"2\" />\n     </svg>\n     ```\n   - Composite SVG overlay:\n     ```typescript\n     const borderSvg = this.generateBorderSvg(positions, config);\n     result = await result.composite([{\n       input: borderSvg,\n       top: 0,\n       left: 0\n     }]);\n     ```\n\n7. **Return ComposedLayout:**\n   ```typescript\n   const buffer = await result.toBuffer();\n   return {\n     buffer,\n     width: config.pageWidth,\n     height: config.pageHeight,\n     format: 'png',\n     panelPositions: positions\n   };\n   ```\n\n**Method: addSpeechBubbles() - Overlay Speech Bubbles**\n\n```typescript\nasync addSpeechBubbles(\n  layout: ComposedLayout,\n  bubbles: SpeechBubble[]\n): Promise<ComposedLayout>\n```\n\nImplementation:\n\n1. **For each speech bubble:**\n   - Get panel position from layout.panelPositions[bubble.panelIndex]\n   - Calculate bubble position within panel:\n     - 'top'  y = panel.y + 30\n     - 'middle'  y = panel.y + panel.height/2 - 30\n     - 'bottom'  y = panel.y + panel.height - 60\n\n2. **Create SVG speech bubble:**\n   ```typescript\n   const svg = this.generateSpeechBubbleSvg(bubble, position, style);\n   // Generates SVG with text, shape varies by style:\n   // 'rounded', 'cloud', 'spiked', 'rectangular'\n   ```\n\n3. **Composite all bubble SVGs:**\n   ```typescript\n   let result = sharp(layout.buffer);\n   const bubbleSvgs = bubbles.map((bubble, idx) =>\n     this.generateSpeechBubbleSvg(bubble, panelPositions[bubble.panelIndex])\n   );\n\n   result = await result.composite(\n     bubbleSvgs.map((svg, i) => ({ input: svg }))\n   );\n   ```\n\n4. **Return updated ComposedLayout**\n\n**Helper: generateBorderSvg()**\n```typescript\nprivate generateBorderSvg(\n  positions: PanelPosition[],\n  config: LayoutConfig\n): Buffer\n```\n\nGenerate SVG with rectangle borders around each panel:\n```svg\n<svg width=\"800\" height=\"1200\">\n  <rect x=\"10\" y=\"10\" width=\"390\" height=\"590\"\n        fill=\"none\" stroke=\"#000000\" stroke-width=\"2\" />\n  <!-- repeated for each panel -->\n</svg>\n```\n\nConvert to Buffer and return.\n\n**Helper: generateSpeechBubbleSvg()**\n```typescript\nprivate generateSpeechBubbleSvg(\n  bubble: SpeechBubble,\n  panelPosition: PanelPosition,\n  targetY: number  // top/middle/bottom\n): Buffer\n```\n\nGenerate SVG with speech bubble shape. Example for 'rounded':\n```svg\n<svg width=\"300\" height=\"100\">\n  <!-- Rounded rectangle -->\n  <path d=\"M 10,10 Q 10,10 20,10 L 270,10 Q 280,10 280,20 L 280,70 Q 280,80 270,80 L 30,80 Q 20,80 20,70 L 20,40 L 0,60 L 20,50 L 20,20 Q 20,10 10,10\"\n        fill=\"white\" stroke=\"black\" stroke-width=\"1\" />\n  <text x=\"20\" y=\"50\" font-family=\"Arial\" font-size=\"14\">Your text here</text>\n</svg>\n```\n\nReturn SVG as Buffer via:\n```typescript\nconst svgBuffer = Buffer.from(svgString, 'utf-8');\n```\n\n### ExportService (`backend/src/services/exportService.ts`) - NEW FILE\n\nImplement export to PNG, JPG, PDF formats.\n\n```typescript\nexport class ExportService {\n  async exportPNG(\n    layout: ComposedLayout,\n    filepath: string,\n    compression: 'low' | 'medium' | 'high'\n  ): Promise<void>\n\n  async exportJPG(\n    layout: ComposedLayout,\n    filepath: string,\n    quality: number  // 60-95\n  ): Promise<void>\n\n  async exportPDF(\n    layout: ComposedLayout,\n    filepath: string,\n    metadata: { title?: string; author?: string }\n  ): Promise<void>\n}\n```\n\n**exportPNG():**\n```typescript\nasync exportPNG(layout, filepath, compression) {\n  const compressionLevel = compression === 'high' ? 9 : compression === 'medium' ? 6 : 1;\n  await sharp(layout.buffer)\n    .png({ compressionLevel })\n    .toFile(filepath);\n}\n```\n\n**exportJPG():**\n```typescript\nasync exportJPG(layout, filepath, quality = 80) {\n  await sharp(layout.buffer)\n    .jpeg({ quality, mozjpeg: true })\n    .toFile(filepath);\n}\n```\n\n**exportPDF():**\nRequires pdfkit library:\n```typescript\nimport PDFDocument from 'pdfkit';\nimport { createWriteStream } from 'fs';\n\nasync exportPDF(layout, filepath, metadata = {}) {\n  const doc = new PDFDocument({\n    size: [layout.width, layout.height]\n  });\n\n  if (metadata.title) doc.title(metadata.title);\n  if (metadata.author) doc.author(metadata.author);\n\n  // Add image to PDF\n  doc.image(layout.buffer, 0, 0, {\n    width: layout.width,\n    height: layout.height\n  });\n\n  doc.pipe(createWriteStream(filepath));\n  doc.end();\n}\n```\n\n### Route Handler Integration\n\nImplement in `backend/src/routes/manga.ts`:\n\n**POST /api/manga/:projectId/layout**\n```typescript\nrouter.post('/:projectId/layout', async (req: Request, res: Response, next: NextFunction) => {\n  try {\n    const { projectId } = req.params;\n    const { speechBubbles } = req.body as GenerateLayoutRequest;\n\n    // Fetch project and panels from DB\n    const project = await getProject(projectId);\n    if (!project) throw new NotFoundError('Project');\n\n    // Get panel image paths\n    const panelPaths = project.panels\n      .sort((a, b) => a.panelIndex - b.panelIndex)\n      .map(p => p.imageFilePath)\n      .filter(path => path !== undefined);\n\n    // Compose layout\n    const layoutEngine = new LayoutEngine();\n    let layout = await layoutEngine.composePanels(panelPaths, project.layoutConfig);\n\n    // Add speech bubbles if provided\n    if (speechBubbles && speechBubbles.length > 0) {\n      layout = await layoutEngine.addSpeechBubbles(layout, speechBubbles);\n    }\n\n    // Save layout buffer to temporary file for preview\n    const layoutPath = path.join(CONFIG.STORAGE_PATH, projectId, 'layout.png');\n    await fs.writeFile(layoutPath, layout.buffer);\n\n    // Update project status\n    await updateProject(projectId, { status: 'complete' });\n\n    // Return layout info\n    res.json({\n      message: 'Layout composed successfully',\n      projectId,\n      layoutPath: `/uploads/${projectId}/layout.png`,\n      panelPositions: layout.panelPositions,\n      dimensions: { width: layout.width, height: layout.height }\n    });\n  } catch (err) {\n    next(err);\n  }\n});\n```\n\n**POST /api/manga/:projectId/export**\n```typescript\nrouter.post('/:projectId/export', async (req: Request, res: Response, next: NextFunction) => {\n  try {\n    const { projectId } = req.params;\n    const { format, compression, resolution, title, author } = req.body as ExportRequest;\n\n    // Fetch project layout\n    const layoutPath = path.join(CONFIG.STORAGE_PATH, projectId, 'layout.png');\n    if (!fs.existsSync(layoutPath)) {\n      throw new Error('Layout not yet generated. Call /layout endpoint first.');\n    }\n\n    const layoutBuffer = await fs.promises.readFile(layoutPath);\n    const layout: ComposedLayout = {\n      buffer: layoutBuffer,\n      width: 800,  // From project.layoutConfig\n      height: 1200,\n      format: 'png',\n      panelPositions: []  // Could fetch from DB if needed\n    };\n\n    // Export to requested format\n    const exportService = new ExportService();\n    const timestamp = Date.now();\n    const exportPath = path.join(CONFIG.STORAGE_PATH, projectId, `manga_${timestamp}.${format}`);\n\n    if (format === 'png') {\n      await exportService.exportPNG(layout, exportPath, compression as 'low' | 'medium' | 'high');\n    } else if (format === 'jpg') {\n      const qualityMap = { low: 60, medium: 80, high: 95 };\n      await exportService.exportJPG(layout, exportPath, qualityMap[compression]);\n    } else if (format === 'pdf') {\n      await exportService.exportPDF(layout, exportPath, { title, author });\n    }\n\n    // Update project status\n    await updateProject(projectId, { status: 'exported' });\n\n    res.json({\n      message: 'Export successful',\n      projectId,\n      format,\n      downloadUrl: `/uploads/${projectId}/manga_${timestamp}.${format}`,\n      filePath: exportPath\n    });\n  } catch (err) {\n    next(err);\n  }\n});\n```\n\n### Testing Requirements\n\n```bash\n# 1. Generate layout from Task 3 images\nPROJECT_ID=\"test-project-id\"\ncurl -X POST http://localhost:5000/api/manga/$PROJECT_ID/layout \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\n    \"speechBubbles\": [\n      {\n        \"panelIndex\": 0,\n        \"text\": \"Wow!\",\n        \"position\": \"top\",\n        \"style\": \"rounded\"\n      }\n    ]\n  }'\n\n# 2. View composed layout\nopen http://localhost:5000/uploads/$PROJECT_ID/layout.png\n\n# 3. Export to PNG\ncurl -X POST http://localhost:5000/api/manga/$PROJECT_ID/export \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\n    \"format\": \"png\",\n    \"compression\": \"medium\",\n    \"resolution\": \"web\",\n    \"title\": \"My Manga\"\n  }'\n\n# 4. Export to PDF\ncurl -X POST http://localhost:5000/api/manga/$PROJECT_ID/export \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\n    \"format\": \"pdf\",\n    \"compression\": \"medium\",\n    \"title\": \"My Manga\",\n    \"author\": \"AI Creator\"\n  }'\n\n# 5. Verify files exist\nls -lh uploads/$PROJECT_ID/\n```\n\n### Files This Task Provides to Other Agents\n\n- **Composed layout image** - Used by frontend for preview\n- **Export files** - PNG/JPG/PDF outputs for download\n- **Layout metadata** - Panel positions for debugging/display\n\n### Output Validation Checklist\n\n- [ ] calculateGrid() and calculatePanelPositions() methods work correctly\n- [ ] composePanels() successfully combines images with sharp\n- [ ] Borders render correctly around panels\n- [ ] Speech bubbles overlay without distortion\n- [ ] Multiple speech bubble styles work ('rounded', 'cloud', 'spiked', 'rectangular')\n- [ ] Layout PNG saved and readable\n- [ ] exportPNG() produces valid PNG files\n- [ ] exportJPG() produces valid JPG files with quality control\n- [ ] exportPDF() produces valid PDF with metadata\n- [ ] /layout endpoint returns correct panel positions\n- [ ] /export endpoint returns download URLs\n- [ ] Compression settings affect file size appropriately\n- [ ] No TypeScript compilation errors\n\n---\n\n## Task 5: React (Agent E)\n### Complete React UI with Component Implementation\n\n**Time Estimate:** 60-80 minutes\n**Difficulty:** Intermediate (React component patterns)\n**Dependencies:** Tasks 1-4 (backend API must be running)\n\n### Objective\nComplete all React components for the koma-fill frontend including image upload with drag-drop, story prompt editor, panel grid with drag-and-drop reordering, complete manga generation workflow orchestration, real-time SSE progress updates, and multi-format export options. Configure Tailwind CSS for styling.\n\n### Target Files to Create/Modify\n\n```\nfrontend/\n src/\n    components/\n       ImageUploader.tsx           [IMPLEMENT] Dropzone with position selector\n       StoryPromptEditor.tsx       [ENHANCE] Add sample prompts\n       PanelGrid.tsx               [IMPLEMENT] Drag-and-drop reordering\n       LayoutSelector.tsx          [VERIFY] Layout config UI\n       ExportOptions.tsx           [VERIFY] Export format selection\n       ProgressBar.tsx             [CREATE] Real-time progress display\n    hooks/\n       useMangaGeneration.ts       [IMPLEMENT] Full workflow orchestration\n    services/\n       apiClient.ts                [IMPLEMENT] API client with SSE support\n    pages/\n       CreateMangaPage.tsx         [IMPLEMENT] Main workflow page\n       PreviewPage.tsx             [IMPLEMENT] Result preview & download\n    App.tsx                         [UPDATE] Routing\n    main.tsx                        [VERIFY] Entry point\n    index.css                       [UPDATE] Tailwind directives\n tailwind.config.js                  [CREATE] Tailwind configuration\n postcss.config.js                   [CREATE] PostCSS configuration\n package.json                        [UPDATE] Add Tailwind dependencies\n tsconfig.json                       [VERIFY] TypeScript config\n```\n\n### TypeScript Interfaces (from `frontend/src/types/index.ts`)\n\nAlready defined - reference for component props.\n\n### Implementation Details\n\n#### 1. Tailwind CSS Setup\n\n**Install Dependencies:**\n```bash\ncd frontend\nnpm install -D tailwindcss postcss autoprefixer\nnpx tailwindcss init -p\n```\n\n**tailwind.config.js:**\n```javascript\nexport default {\n  content: [\n    './index.html',\n    './src/**/*.{js,ts,jsx,tsx}',\n  ],\n  theme: {\n    extend: {\n      colors: {\n        manga: {\n          dark: '#1a1a1a',\n          light: '#f5f5f5',\n        }\n      }\n    },\n  },\n  plugins: [],\n}\n```\n\n**postcss.config.js:**\n```javascript\nexport default {\n  plugins: {\n    tailwindcss: {},\n    autoprefixer: {},\n  },\n}\n```\n\n**frontend/src/index.css:**\n```css\n@tailwind base;\n@tailwind components;\n@tailwind utilities;\n\n@layer components {\n  .btn-primary {\n    @apply px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700 transition;\n  }\n  .btn-secondary {\n    @apply px-4 py-2 bg-gray-300 text-gray-800 rounded-lg hover:bg-gray-400 transition;\n  }\n  .input-field {\n    @apply w-full px-3 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500;\n  }\n}\n```\n\n#### 2. API Client (`frontend/src/services/apiClient.ts`)\n\n```typescript\nimport { MangaProject, Panel, GenerationProgress, ProgressEvent } from '../types';\n\nconst API_BASE = import.meta.env.VITE_API_URL || 'http://localhost:5000/api';\n\nexport class APIClient {\n  /**\n   * Create new manga project\n   */\n  async createProject(name: string, storyPrompt: string, layoutConfig?: any) {\n    const response = await fetch(`${API_BASE}/manga/create`, {\n      method: 'POST',\n      headers: { 'Content-Type': 'application/json' },\n      body: JSON.stringify({\n        projectName: name,\n        storyPrompt,\n        layoutConfig\n      })\n    });\n    if (!response.ok) throw new Error(await response.text());\n    return response.json() as Promise<MangaProject>;\n  }\n\n  /**\n   * Upload key images\n   */\n  async uploadImages(projectId: string, files: File[]) {\n    const formData = new FormData();\n    files.forEach(file => formData.append('images', file));\n\n    const response = await fetch(`${API_BASE}/manga/${projectId}/upload`, {\n      method: 'POST',\n      body: formData\n    });\n    if (!response.ok) throw new Error(await response.text());\n    return response.json();\n  }\n\n  /**\n   * Analyze images using Vision API\n   */\n  async analyzeImages(projectId: string, depth: 'quick' | 'detailed' = 'quick') {\n    const response = await fetch(`${API_BASE}/manga/${projectId}/analyze`, {\n      method: 'POST',\n      headers: { 'Content-Type': 'application/json' },\n      body: JSON.stringify({ analysisDepth: depth })\n    });\n    if (!response.ok) throw new Error(await response.text());\n    return response.json();\n  }\n\n  /**\n   * Generate panel prompts\n   */\n  async generatePrompts(projectId: string, storyPrompt: string, panelCount: number) {\n    const response = await fetch(`${API_BASE}/manga/${projectId}/generate-prompts`, {\n      method: 'POST',\n      headers: { 'Content-Type': 'application/json' },\n      body: JSON.stringify({\n        storyPrompt,\n        panelCount,\n        characterConsistency: true\n      })\n    });\n    if (!response.ok) throw new Error(await response.text());\n    return response.json() as Promise<Panel[]>;\n  }\n\n  /**\n   * Generate images via DALL-E 3 (SSE streaming)\n   */\n  streamImageGeneration(\n    projectId: string,\n    batchMode: 'sequential' | 'parallel',\n    onProgress: (event: ProgressEvent) => void,\n    onError: (error: Error) => void\n  ): () => void {\n    const eventSource = new EventSource(\n      `${API_BASE}/manga/${projectId}/generate-images?batchMode=${batchMode}`\n    );\n\n    eventSource.onmessage = (event) => {\n      try {\n        const data = JSON.parse(event.data);\n        onProgress(data);\n      } catch (e) {\n        console.error('Failed to parse SSE message:', e);\n      }\n    };\n\n    eventSource.onerror = () => {\n      onError(new Error('Generation failed or connection lost'));\n      eventSource.close();\n    };\n\n    // Return cleanup function\n    return () => eventSource.close();\n  }\n\n  /**\n   * Compose layout with speech bubbles\n   */\n  async composeLayout(projectId: string, speechBubbles?: any) {\n    const response = await fetch(`${API_BASE}/manga/${projectId}/layout`, {\n      method: 'POST',\n      headers: { 'Content-Type': 'application/json' },\n      body: JSON.stringify({ speechBubbles })\n    });\n    if (!response.ok) throw new Error(await response.text());\n    return response.json();\n  }\n\n  /**\n   * Export to PNG/JPG/PDF\n   */\n  async exportManga(\n    projectId: string,\n    format: 'png' | 'jpg' | 'pdf',\n    compression: 'low' | 'medium' | 'high' = 'medium',\n    title?: string,\n    author?: string\n  ) {\n    const response = await fetch(`${API_BASE}/manga/${projectId}/export`, {\n      method: 'POST',\n      headers: { 'Content-Type': 'application/json' },\n      body: JSON.stringify({\n        format,\n        compression,\n        resolution: 'web',\n        title,\n        author\n      })\n    });\n    if (!response.ok) throw new Error(await response.text());\n    return response.json();\n  }\n\n  /**\n   * Fetch project details\n   */\n  async getProject(projectId: string) {\n    const response = await fetch(`${API_BASE}/manga/${projectId}`);\n    if (!response.ok) throw new Error(await response.text());\n    return response.json() as Promise<MangaProject>;\n  }\n\n  /**\n   * Reorder panels\n   */\n  async reorderPanels(projectId: string, panelOrder: number[]) {\n    const response = await fetch(`${API_BASE}/manga/${projectId}/reorder`, {\n      method: 'PUT',\n      headers: { 'Content-Type': 'application/json' },\n      body: JSON.stringify({ panelOrder })\n    });\n    if (!response.ok) throw new Error(await response.text());\n    return response.json();\n  }\n}\n\nexport const apiClient = new APIClient();\n```\n\n#### 3. useMangaGeneration Hook (`frontend/src/hooks/useMangaGeneration.ts`)\n\n```typescript\nimport { useState, useCallback } from 'react';\nimport { apiClient } from '../services/apiClient';\nimport { MangaProject, GenerationProgress, UploadedImage } from '../types';\n\nexport function useMangaGeneration() {\n  const [project, setProject] = useState<MangaProject | null>(null);\n  const [progress, setProgress] = useState<GenerationProgress>({\n    stage: 'idle',\n    currentStep: 0,\n    totalSteps: 0,\n    percentage: 0,\n    message: ''\n  });\n  const [error, setError] = useState<string | null>(null);\n\n  /**\n   * Complete workflow: Create  Upload  Analyze  Generate Prompts  Generate Images  Layout\n   */\n  const generateManga = useCallback(async (\n    projectName: string,\n    storyPrompt: string,\n    uploadedImages: UploadedImage[],\n    layoutConfig: any,\n    generationSettings: any\n  ) => {\n    try {\n      setError(null);\n\n      // Stage 1: Create project\n      setProgress({\n        stage: 'uploading',\n        currentStep: 0,\n        totalSteps: 5,\n        percentage: 20,\n        message: 'Creating project...'\n      });\n      const newProject = await apiClient.createProject(projectName, storyPrompt, layoutConfig);\n      setProject(newProject);\n\n      // Stage 2: Upload images\n      setProgress({\n        stage: 'uploading',\n        currentStep: 1,\n        totalSteps: 5,\n        percentage: 40,\n        message: 'Uploading reference images...'\n      });\n      const files = uploadedImages.map(img => img.file);\n      await apiClient.uploadImages(newProject.id, files);\n\n      // Stage 3: Analyze images\n      setProgress({\n        stage: 'analyzing',\n        currentStep: 2,\n        totalSteps: 5,\n        percentage: 60,\n        message: 'Analyzing images with Vision API...'\n      });\n      await apiClient.analyzeImages(newProject.id, 'detailed');\n\n      // Stage 4: Generate prompts\n      setProgress({\n        stage: 'generating_prompts',\n        currentStep: 3,\n        totalSteps: 5,\n        percentage: 70,\n        message: 'Generating panel prompts...'\n      });\n      await apiClient.generatePrompts(\n        newProject.id,\n        storyPrompt,\n        layoutConfig.totalPanels\n      );\n\n      // Stage 5: Generate images (with SSE streaming)\n      setProgress({\n        stage: 'generating_images',\n        currentStep: 4,\n        totalSteps: 5,\n        percentage: 75,\n        message: 'Starting image generation...'\n      });\n\n      await new Promise<void>((resolve, reject) => {\n        const cleanup = apiClient.streamImageGeneration(\n          newProject.id,\n          'sequential',  // or 'parallel' based on user preference\n          (progressEvent) => {\n            if (progressEvent.type === 'complete') {\n              setProgress(prev => ({\n                ...prev,\n                percentage: 90,\n                message: 'Image generation complete!'\n              }));\n              resolve();\n            } else if (progressEvent.type === 'error') {\n              reject(new Error(progressEvent.error || 'Generation failed'));\n            } else {\n              setProgress({\n                stage: 'generating_images',\n                currentStep: 4 + (progressEvent.currentStep || 0) * 0.1,\n                totalSteps: 5,\n                percentage: 75 + (progressEvent.percentage || 0) * 0.15,\n                message: progressEvent.message,\n                currentPanelIndex: progressEvent.panelIndex\n              });\n            }\n          },\n          reject\n        );\n      });\n\n      // Stage 6: Compose layout\n      setProgress({\n        stage: 'composing_layout',\n        currentStep: 5,\n        totalSteps: 5,\n        percentage: 95,\n        message: 'Composing final layout...'\n      });\n      await apiClient.composeLayout(newProject.id);\n\n      // Complete\n      const finalProject = await apiClient.getProject(newProject.id);\n      setProject(finalProject);\n      setProgress({\n        stage: 'idle',\n        currentStep: 5,\n        totalSteps: 5,\n        percentage: 100,\n        message: 'Manga generation complete!'\n      });\n\n    } catch (err) {\n      const errorMsg = err instanceof Error ? err.message : 'Unknown error';\n      setError(errorMsg);\n      setProgress({\n        stage: 'idle',\n        currentStep: 0,\n        totalSteps: 0,\n        percentage: 0,\n        message: `Error: ${errorMsg}`\n      });\n    }\n  }, []);\n\n  const exportManga = useCallback(async (\n    projectId: string,\n    format: 'png' | 'jpg' | 'pdf',\n    compression: 'low' | 'medium' | 'high' = 'medium'\n  ) => {\n    try {\n      setError(null);\n      setProgress({\n        stage: 'exporting',\n        currentStep: 0,\n        totalSteps: 1,\n        percentage: 50,\n        message: `Exporting as ${format.toUpperCase()}...`\n      });\n\n      const result = await apiClient.exportManga(projectId, format, compression);\n\n      setProgress({\n        stage: 'idle',\n        currentStep: 1,\n        totalSteps: 1,\n        percentage: 100,\n        message: 'Export complete!'\n      });\n\n      return result;\n    } catch (err) {\n      const errorMsg = err instanceof Error ? err.message : 'Export failed';\n      setError(errorMsg);\n      throw err;\n    }\n  }, []);\n\n  return {\n    project,\n    progress,\n    error,\n    generateManga,\n    exportManga,\n    setError\n  };\n}\n```\n\n#### 4. Components\n\n**ImageUploader.tsx:**\n```typescript\nimport { useCallback, useState } from 'react';\nimport { UploadedImage, ImagePosition } from '../types';\n\ninterface ImageUploaderProps {\n  onImagesSelected: (images: UploadedImage[]) => void;\n}\n\nexport function ImageUploader({ onImagesSelected }: ImageUploaderProps) {\n  const [images, setImages] = useState<UploadedImage[]>([]);\n  const [selectedPosition, setSelectedPosition] = useState<ImagePosition>('start');\n\n  const handleDrop = useCallback((e: React.DragEvent) => {\n    e.preventDefault();\n    const files = Array.from(e.dataTransfer.files).filter(f => f.type.startsWith('image/'));\n    addImages(files);\n  }, []);\n\n  const handleFileInput = (e: React.ChangeEvent<HTMLInputElement>) => {\n    if (e.target.files) {\n      addImages(Array.from(e.target.files));\n    }\n  };\n\n  const addImages = (files: File[]) => {\n    const newImages = files.map(file => ({\n      file,\n      previewUrl: URL.createObjectURL(file),\n      position: selectedPosition\n    }));\n    setImages(prev => [...prev, ...newImages]);\n    onImagesSelected([...images, ...newImages]);\n  };\n\n  const removeImage = (index: number) => {\n    const updated = images.filter((_, i) => i !== index);\n    setImages(updated);\n    onImagesSelected(updated);\n  };\n\n  return (\n    <div className=\"w-full max-w-2xl\">\n      <div\n        onDrop={handleDrop}\n        onDragOver={e => e.preventDefault()}\n        className=\"border-2 border-dashed border-gray-300 rounded-lg p-8 text-center cursor-pointer hover:border-blue-500 transition\"\n      >\n        <p className=\"text-gray-600 mb-4\">Drag and drop images here or click to select</p>\n        <input\n          type=\"file\"\n          multiple\n          accept=\"image/*\"\n          onChange={handleFileInput}\n          className=\"hidden\"\n          id=\"image-input\"\n        />\n        <label htmlFor=\"image-input\" className=\"btn-primary cursor-pointer\">\n          Select Images\n        </label>\n      </div>\n\n      <div className=\"mt-4\">\n        <label className=\"block mb-2\">Position in Story:</label>\n        <select\n          value={selectedPosition}\n          onChange={e => setSelectedPosition(e.target.value as ImagePosition)}\n          className=\"input-field\"\n        >\n          <option value=\"start\">Start (Reference)</option>\n          <option value=\"end\">End (Reference)</option>\n          <option value={1}>Panel 1</option>\n          <option value={2}>Panel 2</option>\n        </select>\n      </div>\n\n      {images.length > 0 && (\n        <div className=\"mt-6 grid grid-cols-2 gap-4\">\n          {images.map((img, idx) => (\n            <div key={idx} className=\"relative\">\n              <img src={img.previewUrl} alt={`Preview ${idx}`} className=\"rounded-lg w-full h-48 object-cover\" />\n              <button\n                onClick={() => removeImage(idx)}\n                className=\"absolute top-2 right-2 bg-red-500 text-white rounded-full w-6 h-6 flex items-center justify-center hover:bg-red-600\"\n              >\n                \n              </button>\n            </div>\n          ))}\n        </div>\n      )}\n    </div>\n  );\n}\n```\n\n**StoryPromptEditor.tsx (Enhanced):**\n```typescript\nimport { useState } from 'react';\n\ninterface StoryPromptEditorProps {\n  value: string;\n  onChange: (value: string) => void;\n}\n\nconst SAMPLE_PROMPTS = [\n  'A young ninja discovers their hidden powers and must save their village from a mysterious threat.',\n  'Two rival chefs compete in a cooking tournament, discovering they have more in common than they thought.',\n  'A time traveler must prevent a catastrophic event by gathering clues from different eras.',\n];\n\nexport function StoryPromptEditor({ value, onChange }: StoryPromptEditorProps) {\n  const [isExpanded, setIsExpanded] = useState(false);\n\n  return (\n    <div className=\"w-full max-w-2xl\">\n      <label className=\"block text-lg font-semibold mb-2\">Your Story Prompt</label>\n\n      <textarea\n        value={value}\n        onChange={e => onChange(e.target.value)}\n        placeholder=\"Write your manga story here. Be descriptive about characters, setting, and plot...\"\n        className=\"input-field h-32 resize-none\"\n      />\n\n      <div className=\"mt-4\">\n        <button\n          onClick={() => setIsExpanded(!isExpanded)}\n          className=\"text-blue-600 hover:underline text-sm\"\n        >\n          {isExpanded ? 'Hide' : 'Show'} Sample Prompts\n        </button>\n\n        {isExpanded && (\n          <div className=\"mt-3 space-y-2\">\n            {SAMPLE_PROMPTS.map((prompt, idx) => (\n              <button\n                key={idx}\n                onClick={() => onChange(prompt)}\n                className=\"block w-full text-left p-3 bg-gray-100 hover:bg-gray-200 rounded-lg text-sm transition\"\n              >\n                {prompt}\n              </button>\n            ))}\n          </div>\n        )}\n      </div>\n    </div>\n  );\n}\n```\n\n**PanelGrid.tsx (with Drag-and-Drop):**\n```typescript\nimport { useState } from 'react';\nimport { Panel } from '../types';\nimport { DndContext, closestCenter, KeyboardSensor, PointerSensor, useSensor, useSensors } from '@dnd-kit/core';\nimport { SortableContext, sortableKeyboardCoordinates, verticalListSortingStrategy, useSortable } from '@dnd-kit/sortable';\nimport { CSS } from '@dnd-kit/utilities';\n\nfunction SortablePanel({ panel }: { panel: Panel }) {\n  const { attributes, listeners, setNodeRef, transform, transition } = useSortable({ id: panel.id });\n  const style = { transform: CSS.Transform.toString(transform), transition };\n\n  return (\n    <div ref={setNodeRef} style={style} {...attributes} {...listeners} className=\"p-4\">\n      <div className=\"bg-white rounded-lg shadow p-4 cursor-grab active:cursor-grabbing\">\n        <img\n          src={panel.imageUrl}\n          alt={`Panel ${panel.panelIndex}`}\n          className=\"w-full h-auto rounded mb-2\"\n        />\n        <p className=\"text-sm text-gray-600\">{panel.storyBeat}</p>\n        <span className={`inline-block mt-2 px-2 py-1 rounded text-xs text-white ${\n          panel.status === 'generated' ? 'bg-green-500' :\n          panel.status === 'pending' ? 'bg-blue-500' :\n          'bg-red-500'\n        }`}>\n          {panel.status}\n        </span>\n      </div>\n    </div>\n  );\n}\n\ninterface PanelGridProps {\n  panels: Panel[];\n  onReorder: (newOrder: Panel[]) => void;\n}\n\nexport function PanelGrid({ panels, onReorder }: PanelGridProps) {\n  const sensors = useSensors(\n    useSensor(PointerSensor),\n    useSensor(KeyboardSensor, { coordinateGetter: sortableKeyboardCoordinates })\n  );\n\n  const handleDragEnd = (event: any) => {\n    const { active, over } = event;\n    if (over && active.id !== over.id) {\n      const oldIndex = panels.findIndex(p => p.id === active.id);\n      const newIndex = panels.findIndex(p => p.id === over.id);\n      const newPanels = [...panels];\n      [newPanels[oldIndex], newPanels[newIndex]] = [newPanels[newIndex], newPanels[oldIndex]];\n      onReorder(newPanels);\n    }\n  };\n\n  return (\n    <DndContext sensors={sensors} collisionDetection={closestCenter} onDragEnd={handleDragEnd}>\n      <SortableContext items={panels.map(p => p.id)} strategy={verticalListSortingStrategy}>\n        <div className=\"grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-4\">\n          {panels.map(panel => (\n            <SortablePanel key={panel.id} panel={panel} />\n          ))}\n        </div>\n      </SortableContext>\n    </DndContext>\n  );\n}\n```\n\n**ProgressBar.tsx:**\n```typescript\nimport { GenerationProgress } from '../types';\n\nexport function ProgressBar({ progress }: { progress: GenerationProgress }) {\n  return (\n    <div className=\"w-full max-w-2xl\">\n      <div className=\"mb-2 flex justify-between\">\n        <span className=\"text-sm font-semibold\">{progress.message}</span>\n        <span className=\"text-sm text-gray-600\">{Math.round(progress.percentage)}%</span>\n      </div>\n      <div className=\"w-full h-3 bg-gray-200 rounded-full overflow-hidden\">\n        <div\n          className=\"h-full bg-blue-600 transition-all duration-300\"\n          style={{ width: `${progress.percentage}%` }}\n        />\n      </div>\n    </div>\n  );\n}\n```\n\n#### 5. Pages\n\n**CreateMangaPage.tsx:**\n```typescript\nimport { useState } from 'react';\nimport { ImageUploader } from '../components/ImageUploader';\nimport { StoryPromptEditor } from '../components/StoryPromptEditor';\nimport { LayoutSelector } from '../components/LayoutSelector';\nimport { ProgressBar } from '../components/ProgressBar';\nimport { useMangaGeneration } from '../hooks/useMangaGeneration';\nimport { UploadedImage, LayoutConfig } from '../types';\n\nexport function CreateMangaPage() {\n  const [projectName, setProjectName] = useState('');\n  const [storyPrompt, setStoryPrompt] = useState('');\n  const [uploadedImages, setUploadedImages] = useState<UploadedImage[]>([]);\n  const [layoutConfig, setLayoutConfig] = useState<LayoutConfig>({\n    totalPanels: 4,\n    format: 'vertical',\n    readingOrder: 'japanese',\n    gutterSize: 10,\n    borderWidth: 2,\n    borderColor: '#000000',\n    backgroundColor: '#FFFFFF',\n    pageWidth: 800,\n    pageHeight: 1200\n  });\n\n  const { progress, error, generateManga } = useMangaGeneration();\n\n  const handleStart = async () => {\n    if (!projectName || !storyPrompt) {\n      alert('Please enter project name and story prompt');\n      return;\n    }\n\n    await generateManga(projectName, storyPrompt, uploadedImages, layoutConfig, {\n      imageStyle: 'manga style',\n      aspectRatio: 'square',\n      qualityLevel: 'standard'\n    });\n  };\n\n  return (\n    <div className=\"min-h-screen bg-gray-50 py-12 px-4\">\n      <div className=\"max-w-4xl mx-auto space-y-8\">\n        <h1 className=\"text-4xl font-bold text-center mb-2\">koma-fill</h1>\n        <p className=\"text-center text-gray-600\">AI-Powered Manga Panel Generator</p>\n\n        {error && <div className=\"bg-red-100 border border-red-400 text-red-700 px-4 py-3 rounded\">{error}</div>}\n\n        {progress.stage === 'idle' ? (\n          <div className=\"space-y-8\">\n            <div className=\"bg-white p-6 rounded-lg shadow\">\n              <label className=\"block text-lg font-semibold mb-2\">Project Name</label>\n              <input\n                type=\"text\"\n                value={projectName}\n                onChange={e => setProjectName(e.target.value)}\n                className=\"input-field\"\n                placeholder=\"My Awesome Manga\"\n              />\n            </div>\n\n            <div className=\"bg-white p-6 rounded-lg shadow\">\n              <StoryPromptEditor value={storyPrompt} onChange={setStoryPrompt} />\n            </div>\n\n            <div className=\"bg-white p-6 rounded-lg shadow\">\n              <ImageUploader onImagesSelected={setUploadedImages} />\n            </div>\n\n            <div className=\"bg-white p-6 rounded-lg shadow\">\n              <LayoutSelector config={layoutConfig} onChange={setLayoutConfig} />\n            </div>\n\n            <button onClick={handleStart} className=\"btn-primary w-full text-lg py-3\">\n              Generate Manga\n            </button>\n          </div>\n        ) : (\n          <div className=\"bg-white p-6 rounded-lg shadow\">\n            <ProgressBar progress={progress} />\n          </div>\n        )}\n      </div>\n    </div>\n  );\n}\n```\n\n**PreviewPage.tsx:**\n```typescript\nimport { useParams, useNavigate } from 'react-router-dom';\nimport { useEffect, useState } from 'react';\nimport { apiClient } from '../services/apiClient';\nimport { PanelGrid } from '../components/PanelGrid';\nimport { ExportOptions } from '../components/ExportOptions';\nimport { MangaProject } from '../types';\n\nexport function PreviewPage() {\n  const { projectId } = useParams<{ projectId: string }>();\n  const navigate = useNavigate();\n  const [project, setProject] = useState<MangaProject | null>(null);\n  const [loading, setLoading] = useState(true);\n\n  useEffect(() => {\n    if (projectId) {\n      apiClient.getProject(projectId).then(setProject).finally(() => setLoading(false));\n    }\n  }, [projectId]);\n\n  if (loading) return <div className=\"flex justify-center py-12\">Loading...</div>;\n  if (!project) return <div className=\"text-center py-12\">Project not found</div>;\n\n  return (\n    <div className=\"min-h-screen bg-gray-50 py-12 px-4\">\n      <div className=\"max-w-6xl mx-auto\">\n        <button onClick={() => navigate('/')} className=\"btn-secondary mb-6\"> Back</button>\n\n        <h1 className=\"text-3xl font-bold mb-2\">{project.name}</h1>\n        <p className=\"text-gray-600 mb-6\">Project Status: {project.status}</p>\n\n        {project.panels.length > 0 && (\n          <div className=\"bg-white p-6 rounded-lg shadow mb-8\">\n            <h2 className=\"text-2xl font-semibold mb-4\">Panels</h2>\n            <PanelGrid panels={project.panels} onReorder={() => {}} />\n          </div>\n        )}\n\n        <div className=\"bg-white p-6 rounded-lg shadow\">\n          <h2 className=\"text-2xl font-semibold mb-4\">Export</h2>\n          <ExportOptions projectId={project.id} />\n        </div>\n      </div>\n    </div>\n  );\n}\n```\n\n#### 6. Update App.tsx\n\n```typescript\nimport { BrowserRouter as Router, Routes, Route, Navigate } from 'react-router-dom';\nimport { CreateMangaPage } from './pages/CreateMangaPage';\nimport { PreviewPage } from './pages/PreviewPage';\nimport './index.css';\n\nexport default function App() {\n  return (\n    <Router>\n      <Routes>\n        <Route path=\"/\" element={<CreateMangaPage />} />\n        <Route path=\"/project/:projectId\" element={<PreviewPage />} />\n        <Route path=\"*\" element={<Navigate to=\"/\" />} />\n      </Routes>\n    </Router>\n  );\n}\n```\n\n### package.json Updates\n\nAdd dependencies:\n```bash\nnpm install -D tailwindcss postcss autoprefixer\nnpm install react-router-dom @dnd-kit/core @dnd-kit/sortable @dnd-kit/utilities\n```\n\n### Testing Requirements\n\n```bash\n# 1. Start backend (from Task 1)\ncd backend && npm run dev\n\n# 2. In another terminal, start frontend\ncd frontend && npm run dev\n\n# 3. Open browser: http://localhost:3000\n\n# 4. Test workflow:\n# - Enter project name and story\n# - Upload reference images\n# - Configure layout\n# - Click \"Generate Manga\"\n# - Watch progress bar\n# - See panel grid with images\n# - Export to PNG/JPG/PDF\n```\n\n### Files This Task Uses from Other Agents\n\n- **API endpoints** from Task 1 (database & routes)\n- **Analysis data** from Task 2 (character consistency)\n- **Generated images** from Task 3 (panel images)\n- **Composed layouts** from Task 4 (final manga)\n\n### Output Validation Checklist\n\n- [ ] Tailwind CSS configured and working\n- [ ] ImageUploader component with drag-drop works\n- [ ] react-dropzone integration functional\n- [ ] StoryPromptEditor displays with sample prompts\n- [ ] Sample prompt insertion works\n- [ ] PanelGrid displays with drag-and-drop reordering\n- [ ] @dnd-kit integration functional\n- [ ] useMangaGeneration hook orchestrates full workflow\n- [ ] SSE progress streaming displays correctly\n- [ ] ProgressBar updates in real-time\n- [ ] apiClient makes correct API calls\n- [ ] All components have TypeScript types\n- [ ] CreateMangaPage workflow complete\n- [ ] PreviewPage shows generated manga\n- [ ] ExportOptions functional (PNG/JPG/PDF)\n- [ ] Routing works (create  preview)\n- [ ] Error handling displays user-friendly messages\n- [ ] npm run dev starts without errors\n- [ ] No TypeScript compilation errors\n\n---\n\n## Integration Testing (After All Tasks Complete)\n\nAfter all 5 agents finish their implementations, run the following integration tests:\n\n```bash\n# 1. Start backend\ncd /mnt/Projects/koma-fill/backend\nnpm install\nnpm run dev\n# Expected: \" koma-fill server running on http://localhost:5000\"\n\n# 2. Start frontend (new terminal)\ncd /mnt/Projects/koma-fill/frontend\nnpm install\nnpm run dev\n# Expected: \"VITE  ready in XXX ms\"\n\n# 3. Complete workflow test\n# Open http://localhost:3000 in browser\n# - Create project\n# - Upload 2 reference images\n# - Enter story prompt\n# - Select layout (4 panels)\n# - Click \"Generate Manga\"\n# - Wait for completion\n# - View generated panels\n# - Export to PNG\n# - Verify PNG file created in uploads/\n\n# 4. Verify database\nsqlite3 /mnt/Projects/koma-fill/data/koma-fill.db\n> SELECT COUNT(*) FROM projects;\n> SELECT COUNT(*) FROM panels;\n> SELECT COUNT(*) FROM keyImages;\n\n# 5. Check file structure\nls -la /mnt/Projects/koma-fill/uploads/\nls -la /mnt/Projects/koma-fill/data/\n\n# 6. API health check\ncurl http://localhost:5000/api/health\n# Expected: {\"status\":\"ok\",\"timestamp\":\"...\"}\n```\n\n### Known Integration Points to Verify\n\n- Task 1  Task 2: Panel prompts saved in DB, readable by frontend\n- Task 2  Task 3: Vision analysis influences character consistency in prompts\n- Task 3  Task 4: Generated images saved to disk, paths in database\n- Task 4  Task 5: Layout images served via `/uploads/` static directory\n- Task 5  All: Frontend calls all backend API endpoints successfully\n\n---\n\n## Success Criteria Summary\n\nAll 5 tasks completed when:\n\n1. **Backend (Task 1)**: Express server with SQLite database, all CRUD routes working\n2. **Vision & Prompts (Task 2)**: OpenAI Vision API analyzes images, GPT-4o generates DALL-E prompts\n3. **Image Generation (Task 3)**: DALL-E 3 generates 4+ images with retry logic, SSE progress works\n4. **Layout & Export (Task 4)**: Sharp composes panels into manga layout, exports PNG/JPG/PDF\n5. **Frontend (Task 5)**: React UI allows workflow from story  generated manga  export\n\n**Total Expected Time**: 4-5 hours per agent (can run in parallel)\n**Minimum Test Time**: 30 minutes for integration testing\n\nGood luck, KAMUI agents! \n\n---\n\n*Last Updated: 2025-02-12*\n*For issues or questions, refer to the specific task prompts above*",
        "tooltip": ": CodexCLI3: # KAMUI-4D Parallel Task Prompts for koma-fill\n## Manga Generation AI System - Multi-Agent Implementation Guide\n\n**Version:** 1.0\n**Project:** koma-fill - AI-powered manga panel generation system\n**Target:** KAMUI-4D Editor (Multi-AI CLI parallel execution)\n\n---\n\n## How to Use These Prompts in KAMUI-4D\n\nThis document contains **5 independent task prompts** designed to run in parallel across multiple AI coding agents. Each prompt is self-contained and can be executed independently without blocking other tasks.\n\n### Setup Instructions\n\n1. **Install dependencies** (run once before starting tasks):\n   ```bash\n   cd /mnt/Projects/koma-fill/backend\n   npm install\n\n   cd /mnt/Projects/koma-fill/frontend\n   npm install\n   ```\n\n2. **Environment Configuration**:\n   Create `/mnt/Projects/koma-fill/.env`:\n   ```\n   NODE_ENV=development\n   PORT=5000\n   BASE_URL=http://localhost:5000\n   OPENAI_API_KEY=your_openai_api_key_here\n   OPENAI_ORG_ID=your_org_id_optional\n   DATABASE_PATH=./data/koma-fill.db\n   STORAGE_PATH=./uploads\n   MAX_IMAGE_SIZE_MB=20\n   DALLE_RATE_LIMIT_PER_MINUTE=5\n   VISION_RATE_LIMIT_PER_MINUTE=30\n   MAX_RETRIES_PER_PANEL=3\n   ALLOWED_ORIGINS=http://localhost:3000\n   ```\n\n3. **Execution Strategy**:\n   - Copy each task prompt below into a separate KAMUI-4D session/agent\n   - **Tasks 1-5 can ALL start simultaneously** (no blocking dependencies)\n   - Each task should run independently in its own AI CLI session\n   - Monitor each agent's progress via console output\n   - **Integration testing** should happen after all 5 tasks complete (see bottom of doc)\n\n4. **Task Dependencies**:\n   ```\n   Task 1 (Backend)  provides database & API contracts\n   Task 2 (Vision)  uses Task 1's API, reads backend/src/models/types.ts\n   Task 3 (Images)  uses Task 1's API, reads backend/src/models/types.ts\n   Task 4 (Layout)  uses Task 1's API, reads backend/src/models/types.ts\n   Task 5 (Frontend)  calls Tasks 1-4 via REST API\n   ```\n   **All tasks can start immediately** - they communicate via file system and API contracts.\n\n---\n\n## Task 1: Backend (Agent A)\n### Express Server, SQLite Database & CRUD Routes Foundation\n\n**Time Estimate:** 45-60 minutes\n**Difficulty:** Intermediate\n**Dependencies:** None (this is the foundation layer)\n\n### Objective\nSet up a fully functional Express.js backend with SQLite database, implement CRUD operations for manga projects and panels, configure file upload handling with multer, and provide a solid API foundation for other agents to build upon.\n\n### Target Files to Create/Modify\n\n```\nbackend/\n src/\n    database/\n       connection.ts          [NEW] SQLite connection & initialization\n       schema.ts              [NEW] Table schema definitions\n    index.ts                   [MODIFY] Add DB initialization\n    app.ts                     [COMPLETE] Already done - verify middleware\n    routes/\n       manga.ts               [IMPLEMENT] Route handlers with DB calls\n    middleware/\n        errorHandler.ts        [VERIFY] Already complete\n uploads/                        [CREATE] Directory for image storage\n data/                           [CREATE] Directory for SQLite DB\n```\n\n### TypeScript Interfaces (from `/mnt/Projects/koma-fill/backend/src/models/types.ts`)\n\nKey types you'll use:\n```typescript\n// Core entities\nMangaProject {\n  id: string;                    // UUID\n  name: string;\n  description?: string;\n  status: ProjectStatus;         // 'draft' | 'analyzing' | 'generating' | 'complete' | 'exported'\n  layoutConfig: LayoutConfig;\n  generationSettings: GenerationSettings;\n  panels: Panel[];\n  keyImages: KeyImage[];\n  totalCost: number;\n  createdAt: string;             // ISO datetime\n  updatedAt: string;\n}\n\nPanel {\n  id: string;                    // UUID\n  projectId: string;\n  panelIndex: number;            // 0-based\n  imageUrl?: string;\n  imageFilePath?: string;\n  prompt?: string;\n  storyBeat?: string;\n  speechBubbleText?: string;\n  status: PanelStatus;           // 'pending' | 'generated' | 'failed' | 'placeholder'\n  retryCount: number;\n  generatedAt?: string;\n  createdAt: string;\n}\n\nKeyImage {\n  id: string;                    // UUID\n  projectId: string;\n  imageFilePath: string;\n  position: ImagePosition;       // 'start' | 'end' | number\n  analysis?: ImageAnalysis;\n  createdAt: string;\n}\n\nLayoutConfig {\n  totalPanels: number;           // 4, 6, 8, etc.\n  format: LayoutFormat;          // 'vertical' | 'horizontal' | 'square'\n  readingOrder: ReadingOrder;    // 'japanese' | 'western'\n  gutterSize: number;            // px\n  borderWidth: number;           // px\n  borderColor: string;           // hex #RRGGBB\n  backgroundColor: string;       // hex\n  pageWidth: number;             // px\n  pageHeight: number;            // px\n}\n\nGenerationSettings {\n  imageStyle: string;            // e.g., \"manga style, black and white ink\"\n  aspectRatio: 'square' | 'wide' | 'tall';\n  qualityLevel: 'standard' | 'hd';\n  negativePrompt?: string;\n  seed?: number;\n}\n```\n\n### Implementation Checklist\n\n#### 1. Create Database Connection Module (`backend/src/database/connection.ts`)\n```typescript\n// Requirements:\n- Initialize better-sqlite3 connection\n- Create/open database at DATABASE_PATH from .env\n- Export initDatabase() async function\n- Enable foreign keys constraint\n- Handle database file creation if needed\n- Connection should be cached/singleton\n```\n\n#### 2. Create Database Schema Module (`backend/src/database/schema.ts`)\n```typescript\n// SQL Schema Requirements:\nCREATE TABLE projects (\n  id TEXT PRIMARY KEY,\n  name TEXT NOT NULL,\n  description TEXT,\n  status TEXT NOT NULL,\n  layoutConfig JSON NOT NULL,\n  generationSettings JSON NOT NULL,\n  totalCost REAL DEFAULT 0,\n  createdAt TEXT NOT NULL,\n  updatedAt TEXT NOT NULL\n);\n\nCREATE TABLE panels (\n  id TEXT PRIMARY KEY,\n  projectId TEXT NOT NULL,\n  panelIndex INTEGER NOT NULL,\n  imageUrl TEXT,\n  imageFilePath TEXT,\n  prompt TEXT,\n  storyBeat TEXT,\n  speechBubbleText TEXT,\n  status TEXT NOT NULL,\n  retryCount INTEGER DEFAULT 0,\n  generatedAt TEXT,\n  createdAt TEXT NOT NULL,\n  FOREIGN KEY (projectId) REFERENCES projects(id)\n);\n\nCREATE TABLE keyImages (\n  id TEXT PRIMARY KEY,\n  projectId TEXT NOT NULL,\n  imageFilePath TEXT NOT NULL,\n  position TEXT NOT NULL,\n  analysis JSON,\n  createdAt TEXT NOT NULL,\n  FOREIGN KEY (projectId) REFERENCES projects(id)\n);\n\nCREATE INDEX idx_project_status ON projects(status);\nCREATE INDEX idx_panel_project ON panels(projectId);\nCREATE INDEX idx_panel_status ON panels(status);\n```\n\n#### 3. Modify `backend/src/index.ts`\n```typescript\n// Add:\n- Import { initDatabase } from './database/connection'\n- Call await initDatabase() before app.listen()\n- Log database initialization success\n```\n\n#### 4. Create Repository Layer (`backend/src/repositories/`)\n```typescript\n// Create:\n- ProjectRepository with methods:\n  - createProject(data: CreateMangaRequest): Promise<MangaProject>\n  - getProject(id: string): Promise<MangaProject | null>\n  - listProjects(limit: number, offset: number): Promise<MangaProject[]>\n  - updateProject(id: string, updates: Partial<MangaProject>): Promise<MangaProject>\n  - deleteProject(id: string): Promise<void>\n\n- PanelRepository with methods:\n  - createPanel(projectId: string, data: Panel): Promise<Panel>\n  - getPanelsByProject(projectId: string): Promise<Panel[]>\n  - getPanel(panelId: string): Promise<Panel | null>\n  - updatePanel(panelId: string, updates: Partial<Panel>): Promise<Panel>\n  - updatePanelStatus(panelId: string, status: PanelStatus): Promise<void>\n\n- KeyImageRepository with methods:\n  - createKeyImage(projectId: string, data: KeyImage): Promise<KeyImage>\n  - getKeyImages(projectId: string): Promise<KeyImage[]>\n  - updateKeyImageAnalysis(imageId: string, analysis: ImageAnalysis): Promise<void>\n```\n\n#### 5. Implement Routes in `backend/src/routes/manga.ts`\nReplace TODO comments with actual implementations:\n\n- **POST /api/manga/create**\n  - Validate CreateMangaRequest using Joi\n  - Generate unique project ID (uuid)\n  - Create project in database with 'draft' status\n  - Create initial panel records (count = layoutConfig.totalPanels)\n  - Return created MangaProject with 201 status\n\n- **POST /api/manga/:projectId/upload**\n  - Files already handled by multer middleware\n  - Save KeyImage records to database with file paths\n  - Store position information\n  - Return array of KeyImage objects\n\n- **GET /api/manga/:projectId**\n  - Fetch project + panels + key images from database\n  - Return complete MangaProject object\n  - Throw NotFoundError if project doesn't exist\n\n- **GET /api/manga**\n  - Implement pagination (limit/offset query params)\n  - Return array of projects\n  - Include total count header\n\n- **PUT /api/manga/:projectId/reorder**\n  - Parse ReorderPanelsRequest body\n  - Update panelIndex for each panel based on new order\n  - Return updated panels array\n\n### Testing Requirements\n\nAfter implementation, verify:\n\n```bash\n# 1. Database initialization\nnpm run dev\n# Check console: \" configured\" for database\n\n# 2. Create project\ncurl -X POST http://localhost:5000/api/manga/create \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\n    \"projectName\": \"Test Manga\",\n    \"storyPrompt\": \"A hero on a quest\",\n    \"layoutConfig\": { \"totalPanels\": 4 }\n  }'\n\n# 3. Get project\ncurl http://localhost:5000/api/manga/{projectId}\n\n# 4. Upload images\ncurl -X POST http://localhost:5000/api/manga/{projectId}/upload \\\n  -F \"images=@test1.jpg\" \\\n  -F \"images=@test2.jpg\"\n\n# 5. Check database\nsqlite3 data/koma-fill.db \"SELECT * FROM projects; SELECT * FROM panels;\"\n```\n\n### Files This Task Provides to Other Agents\n\n- **Database schema** - Tasks 2, 3, 4, 5 will read/write to these tables\n- **API contracts** - manga.ts route signatures that Tasks 2-4 will call\n- **File storage structure** - uploads/ directory path that Task 3 will use\n- **Type definitions** - already in backend/src/models/types.ts (reference only)\n\n### Output Validation Checklist\n\n- [ ] Database file created at `data/koma-fill.db`\n- [ ] All 3 tables created with correct schema\n- [ ] Repositories implement CRUD operations\n- [ ] All route handlers work without TODO comments\n- [ ] multer uploads save files to `uploads/` directory\n- [ ] POST /create returns 201 with MangaProject object\n- [ ] GET /:projectId returns full project with panels\n- [ ] Error handler catches and responds appropriately\n- [ ] No TypeScript compilation errors\n- [ ] npm run dev starts without errors\n\n---\n\n## Task 2: + (Agent B)\n### Vision API Integration & DALL-E Prompt Generation\n\n**Time Estimate:** 50-60 minutes\n**Difficulty:** Intermediate\n**Dependencies:** Task 1 (needs database & API routes available)\n\n### Objective\nImplement OpenAI Vision API integration to analyze uploaded key images and extract character/style information. Then implement story-to-panel prompt generation using GPT-4o to create DALL-E 3 compatible prompts that maintain consistency across panels.\n\n### Target Files to Create/Modify\n\n```\nbackend/\n src/\n     services/\n         imageAnalysisService.ts      [IMPLEMENT] Vision API analysis\n         promptGenerationService.ts   [CREATE] Story  panel prompts\n```\n\n### System Prompts (Already Provided)\n\nBoth vision analysis prompts are defined in `imageAnalysisService.ts`:\n- `QUICK_ANALYSIS_PROMPT` - fast, ~500 tokens\n- `DETAILED_ANALYSIS_PROMPT` - thorough, ~2000 tokens\n\nThese guide the Vision API to return structured JSON matching the `ImageAnalysis` interface.\n\n### TypeScript Interfaces\n\n```typescript\n// Input: Key image file path (from Task 1)\n// Output: ImageAnalysis object\n\nImageAnalysis {\n  description: string;\n  characters: CharacterInfo[];\n  objects: string[];\n  colors: string[];\n  composition: string;\n  mood: string;\n  artStyle: string;\n  suggestedTransitions: string[];\n}\n\nCharacterInfo {\n  name?: string;\n  appearance: string;        // detailed physical description\n  emotion: string;\n  position: string;          // screen position (e.g., \"center-left\")\n}\n\n// Panel prompt generation\nPanelPrompt {\n  panelIndex: number;\n  dallePrompt: string;       // Full DALL-E 3 prompt (100-300 words)\n  storyBeat: string;         // What happens in this panel\n  visualFocus: string;       // Main visual element\n  transitionType: TransitionType;  // 'cut' | 'pan' | 'zoom_in' | 'zoom_out' | 'fade' | 'action'\n  suggestedDialogue?: string;\n}\n```\n\n### Implementation Details\n\n#### ImageAnalysisService (`backend/src/services/imageAnalysisService.ts`)\n\n**Constructor:**\n```typescript\nconstructor() {\n  this.openai = new OpenAI({\n    apiKey: CONFIG.OPENAI_API_KEY,\n    organization: CONFIG.OPENAI_ORG_ID\n  });\n}\n```\n\n**Method: analyzeImage(imageBase64: string, depth: 'quick' | 'detailed')**\n- Input: Base64-encoded image data from KeyImage file\n- Implementation:\n  1. Read image file and convert to Base64 (if not already)\n  2. Call `this.openai.chat.completions.create()`:\n     - model: CONFIG.VISION_MODEL ('gpt-4o')\n     - messages: [\n       { role: 'system', content: QUICK_ANALYSIS_PROMPT or DETAILED_ANALYSIS_PROMPT }\n       { role: 'user', content: [\n         { type: 'image_url', image_url: { url: `data:image/png;base64,${imageBase64}` } }\n       ]}\n     ]\n     - response_format: { type: 'json_object' }\n     - max_tokens: depth === 'quick' ? 500 : 2000\n  3. Parse response.choices[0].message.content as JSON\n  4. Validate against ImageAnalysis schema\n  5. Return ImageAnalysis object\n\n**Method: analyzeMultiple(images, depth)**\n- Input: Array of { base64, position } objects\n- Use Promise.all with rate limiting (max CONFIG.VISION_RATE_LIMIT_PER_MINUTE calls/min)\n- Implement backoff if rate limited\n- Return array of ImageAnalysis objects\n\n**Method: extractCharacters(analysis)**\n- Optional: Deep-dive character extraction\n- Can call another Vision API pass if needed for more detail\n\n#### PromptGenerationService (NEW FILE - `backend/src/services/promptGenerationService.ts`)\n\n**Constructor:**\n```typescript\nconstructor() {\n  this.openai = new OpenAI({ apiKey: CONFIG.OPENAI_API_KEY });\n}\n```\n\n**Method: generatePanelPrompts(request: GeneratePromptsRequest)**\n\nInput:\n```typescript\nGeneratePromptsRequest {\n  storyPrompt: string;           // User's story\n  panelCount: number;            // Total panels to generate\n  characterConsistency: boolean; // Whether to maintain character consistency\n}\n```\n\nImplementation:\n1. **Story Breakdown Phase:**\n   - Call GPT-4o to split story into N panel beats\n   - System prompt should guide structure like:\n   ```\n   \"You are a manga story expert. Break the provided story into exactly {panelCount}\n    distinct visual beats. Each beat should be 1-2 sentences describing what happens\n    visually in that panel. Format as JSON array of objects with 'panelIndex' and 'beat' fields.\"\n   ```\n\n2. **Character Consistency Analysis:**\n   - If characterConsistency=true and keyImages were analyzed:\n     - Retrieve stored ImageAnalysis for key images\n     - Create character consistency profile (appearance, emotion arcs, etc.)\n     - Include in subsequent prompts\n\n3. **DALL-E 3 Prompt Generation:**\n   - For each story beat, create detailed DALL-E 3 prompt\n   - System prompt pattern:\n   ```\n   \"You are a DALL-E 3 prompt expert specializing in manga panels.\n    Given a story beat, generate a detailed visual prompt (100-300 words) that:\n    - Specifies art style: {generationSettings.imageStyle}\n    - Maintains character consistency: {characterProfile}\n    - Follows manga composition principles\n    - Uses specific visual terms (angle, lighting, pose, emotion)\n    - Avoids abstract concepts; be concrete and visual\n    - Follows DALL-E 3 content policy\n\n    Return JSON with: { dallePrompt, visualFocus, transitionType, suggestedDialogue }\"\n   ```\n\n4. **Transition Logic:**\n   - Analyze flow between consecutive beats\n   - Suggest transition type ('cut', 'pan', 'zoom_in', etc.)\n   - Update imageUrl in previous panel to support transitions\n\n5. **Return Value:**\n   - Array of PanelPrompt objects, one per panel\n   - Each with populated dallePrompt, storyBeat, visualFocus, transitionType\n\n### Database Integration\n\nAfter generating prompts, save to Panel table:\n- Update each panel's `prompt` field with `dallePrompt`\n- Update `storyBeat` field\n- Update `status` to 'pending' (ready for image generation)\n\n### API Integration\n\nImplement route handlers in `backend/src/routes/manga.ts`:\n\n**POST /api/manga/:projectId/analyze**\n```typescript\n// 1. Fetch project and keyImages from DB\n// 2. Read image files and convert to Base64\n// 3. Call imageAnalysisService.analyzeMultiple()\n// 4. Store analysis results in DB (keyImages.analysis)\n// 5. Update project status to 'analyzing'  'complete'\n// 6. Return analysis results\n```\n\n**POST /api/manga/:projectId/generate-prompts**\n```typescript\n// 1. Validate GeneratePromptsRequest\n// 2. Fetch project and keyImages analyses from DB\n// 3. Call promptGenerationService.generatePanelPrompts()\n// 4. Update panel records with generated prompts\n// 5. Update project status to 'generating'\n// 6. Return array of PanelPrompt objects\n```\n\n### Testing Requirements\n\n```bash\n# 1. Prepare test image\n# (Use any PNG/JPG with a character or scene)\n\n# 2. Create project and upload image (Task 1)\nPROJECT_ID=$(curl -s -X POST http://localhost:5000/api/manga/create \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"projectName\":\"Test\",\"storyPrompt\":\"A hero finds treasure\"}' | jq -r '.id')\n\n# 3. Upload test image\ncurl -X POST http://localhost:5000/api/manga/$PROJECT_ID/upload \\\n  -F \"images=@test_image.jpg\"\n\n# 4. Analyze images\ncurl -X POST http://localhost:5000/api/manga/$PROJECT_ID/analyze \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"analysisDepth\":\"quick\"}'\n\n# 5. Generate prompts\ncurl -X POST http://localhost:5000/api/manga/$PROJECT_ID/generate-prompts \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\n    \"storyPrompt\": \"A hero finds treasure in a dark cave\",\n    \"panelCount\": 4,\n    \"characterConsistency\": true\n  }'\n\n# 6. Verify output\ncurl http://localhost:5000/api/manga/$PROJECT_ID | jq '.panels[].prompt'\n```\n\n### Files This Task Provides to Other Agents\n\n- **Panel prompt data** - Stored in DB panels table, used by Task 3 for image generation\n- **Character analysis** - Used by Task 5 frontend for display\n- **Art style consistency** - Guides Task 3's image generation\n\n### Output Validation Checklist\n\n- [ ] ImageAnalysisService.analyzeImage() calls Vision API successfully\n- [ ] Vision API responses parse correctly to ImageAnalysis\n- [ ] PromptGenerationService generates DALL-E-compatible prompts\n- [ ] Panel prompts maintain character consistency (if enabled)\n- [ ] Transition types are correctly assigned\n- [ ] All panel records updated in database with prompts\n- [ ] /analyze endpoint returns ImageAnalysis array\n- [ ] /generate-prompts endpoint returns PanelPrompt array\n- [ ] Error handling for API failures (rate limits, auth, etc.)\n- [ ] No TypeScript compilation errors\n\n---\n\n## Task 3: DALL-E 3 (Agent C)\n### Image Generation with Retry Logic & Progress Streaming\n\n**Time Estimate:** 50-70 minutes\n**Difficulty:** Intermediate-Advanced\n**Dependencies:** Task 1 (DB & API), Task 2 (panel prompts)\n\n### Objective\nImplement DALL-E 3 image generation with robust error handling, exponential backoff retry logic, local image storage, Server-Sent Events (SSE) streaming for real-time progress updates, and cost tracking per API call.\n\n### Target Files to Create/Modify\n\n```\nbackend/\n src/\n     services/\n         imageGenerationService.ts    [IMPLEMENT] DALL-E 3 API integration\n         (imageProcessor.ts)          [REFERENCE] Utility for image processing\n```\n\n### TypeScript Interfaces\n\n```typescript\nGeneratedPanel {\n  panelIndex: number;\n  imageUrl: string;              // DALL-E public URL (temporary)\n  localFilePath: string;         // /uploads/{projectId}/panel_{index}.png\n  prompt: string;                // Original prompt sent\n  revisedPrompt?: string;        // DALL-E 3's revised prompt (if modified)\n  costUsd: number;               // API call cost\n}\n\n// Request type\nGenerateImagesRequest {\n  panelIndices?: number[];       // undefined = all panels\n  batchMode: 'sequential' | 'parallel';\n}\n\n// Progress event (sent via SSE)\nProgressEvent {\n  type: 'progress' | 'complete' | 'error';\n  stage: string;                 // 'generating_images'\n  currentStep: number;           // Current panel index\n  totalSteps: number;            // Total panels\n  percentage: number;            // 0-100\n  message: string;               // Human-readable status\n  panelId?: string;\n  panelIndex?: number;\n  error?: string;                // Error message if type='error'\n}\n```\n\n### Implementation Details\n\n#### ImageGenerationService (`backend/src/services/imageGenerationService.ts`)\n\n**Constructor & Initialization:**\n```typescript\nconstructor() {\n  this.openai = new OpenAI({ apiKey: CONFIG.OPENAI_API_KEY });\n  this.uploadDir = path.resolve(CONFIG.STORAGE_PATH);\n}\n```\n\n**Method: generatePanel() - Single Panel Generation**\n\n```typescript\nasync generatePanel(\n  prompt: string,\n  panelIndex: number,\n  projectId: string,\n  settings?: GenerationSettings\n): Promise<GeneratedPanel>\n```\n\nImplementation:\n1. **Image Size Calculation:**\n   - Map aspectRatio to DALL-E 3 size:\n     - 'square'  '1024x1024'\n     - 'wide'  '1792x1024'\n     - 'tall'  '1024x1792'\n\n2. **API Call (with retry logic in wrapper):**\n   ```typescript\n   const response = await this.openai.images.generate({\n     model: CONFIG.DALLE_MODEL,           // 'dall-e-3'\n     prompt: prompt,\n     n: 1,\n     size: size,\n     quality: settings?.qualityLevel === 'hd' ? 'hd' : 'standard',\n     style: 'natural',                    // or 'vivid' for more dramatic\n   });\n   ```\n\n3. **Extract Response Data:**\n   - imageUrl = response.data[0].url\n   - revisedPrompt = response.data[0].revised_prompt\n   - Calculate cost based on settings.qualityLevel:\n     - standard: $0.040 per image\n     - hd: $0.080 per image\n\n4. **Download & Save Image:**\n   - Call this.downloadAndSave(imageUrl, projectId, panelIndex)\n   - Saves as PNG: `{STORAGE_PATH}/{projectId}/panel_{panelIndex}.png`\n   - Returns localFilePath\n\n5. **Return GeneratedPanel object**\n\n**Method: generateBatch() - Batch Generation with Mode Selection**\n\n```typescript\nasync generateBatch(\n  panelPrompts: PanelPrompt[],\n  projectId: string,\n  batchMode: 'sequential' | 'parallel',\n  settings?: GenerationSettings,\n  onProgress?: (event: ProgressEvent) => void\n): Promise<GeneratedPanel[]>\n```\n\nImplementation:\n1. Validate inputs\n2. Route to sequential or parallel handler\n3. Call onProgress callback with progress events\n4. Return array of GeneratedPanel\n\n**Method: generateSequential() - Rate-Limit Friendly**\n\n```typescript\nprivate async generateSequential(\n  panelPrompts: PanelPrompt[],\n  projectId: string,\n  settings?: GenerationSettings,\n  onProgress?: (event: ProgressEvent) => void\n): Promise<GeneratedPanel[]>\n```\n\nImplementation:\n1. Initialize results array\n2. For each panelPrompt (with index):\n   a. Call generatePanelWithRetry(panelPrompt, projectId, settings)\n   b. On success:\n      - Add to results array\n      - Call onProgress with percentage = (index + 1) / total * 100\n   c. On failure (after max retries):\n      - Update panel status to 'failed' in DB\n      - Log error\n      - Continue to next panel\n\n3. Return results array (may include failed panels with status='failed')\n\n**Method: generateParallel() - High Speed (Rate Limit Aware)**\n\n```typescript\nprivate async generateParallel(\n  panelPrompts: PanelPrompt[],\n  projectId: string,\n  settings?: GenerationSettings,\n  onProgress?: (event: ProgressEvent) => void\n): Promise<GeneratedPanel[]>\n```\n\nImplementation:\n1. **Batch Control:**\n   - Max concurrent = Math.floor(CONFIG.DALLE_RATE_LIMIT_PER_MINUTE / 2)\n   - Split panelPrompts into batches of max concurrent\n\n2. **For each batch:**\n   - Create Promise.allSettled() for batch\n   - Wait for all to settle\n   - Process results\n   - Send progress update to onProgress\n   - Delay before next batch (respect rate limits)\n\n3. **Failure Handling:**\n   - Collect failed panels\n   - Retry failed panels sequentially (exponential backoff)\n   - Update onProgress for retries\n\n4. **Return results array**\n\n**Method: generatePanelWithRetry() - Core Retry Logic**\n\n```typescript\nprivate async generatePanelWithRetry(\n  panelPrompt: PanelPrompt,\n  projectId: string,\n  settings?: GenerationSettings,\n  retryCount: number = 0\n): Promise<GeneratedPanel>\n```\n\nImplementation:\n1. Try to generate panel via generatePanel()\n2. On success: Return GeneratedPanel\n3. On failure:\n   - If retryCount < CONFIG.MAX_RETRIES_PER_PANEL:\n     - Calculate backoff delay: 2^retryCount * 1000ms (exponential)\n     - Wait for delay\n     - Recursively call with retryCount++\n   - If max retries exceeded:\n     - Throw error with panel index info\n\n**Exponential Backoff Formula:**\n```\ndelay(attempt) = base_delay * (2 ^ attempt) + random jitter\ndelay(0) = 1000ms (1 second)\ndelay(1) = 2000ms (2 seconds)\ndelay(2) = 4000ms (4 seconds)\n+ add random(0, 500ms) jitter to avoid thundering herd\n```\n\n**Method: downloadAndSave() - Store Images Locally**\n\n```typescript\nprivate async downloadAndSave(\n  imageUrl: string,\n  projectId: string,\n  panelIndex: number\n): Promise<string>\n```\n\nImplementation:\n1. Create project uploads directory if not exists: `{STORAGE_PATH}/{projectId}/`\n2. Fetch image from URL using axios or native fetch:\n   ```typescript\n   const response = await fetch(imageUrl);\n   const arrayBuffer = await response.arrayBuffer();\n   const buffer = Buffer.from(arrayBuffer);\n   ```\n3. Save to disk:\n   ```typescript\n   const filePath = path.join(this.uploadDir, projectId, `panel_${panelIndex}.png`);\n   await fs.writeFile(filePath, buffer);\n   ```\n4. Return relative or absolute path\n\n**Method: getImageSize() - Aspect Ratio to DALL-E Size**\n\n```typescript\nprivate getImageSize(\n  aspectRatio: string\n): '1024x1024' | '1792x1024' | '1024x1792'\n```\n\nSelf-explanatory mapping function.\n\n### Route Handler Integration\n\nImplement in `backend/src/routes/manga.ts`:\n\n**POST /api/manga/:projectId/generate-images - SSE Streaming**\n\n```typescript\nrouter.post('/:projectId/generate-images', async (req, res, next) => {\n  try {\n    const { projectId } = req.params;\n    const { panelIndices, batchMode } = req.body as GenerateImagesRequest;\n\n    // Set up SSE response\n    res.setHeader('Content-Type', 'text/event-stream');\n    res.setHeader('Cache-Control', 'no-cache');\n    res.setHeader('Connection', 'keep-alive');\n\n    // Fetch project and panels from DB\n    const project = await getProject(projectId);\n    if (!project) throw new NotFoundError('Project');\n\n    // Filter panels (all or specific indices)\n    const panelsToGenerate = project.panels.filter(\n      p => !panelIndices || panelIndices.includes(p.panelIndex)\n    );\n\n    // Generate prompts array\n    const panelPrompts: PanelPrompt[] = panelsToGenerate.map(p => ({\n      panelIndex: p.panelIndex,\n      dallePrompt: p.prompt!,\n      storyBeat: p.storyBeat!,\n      visualFocus: 'main subject',  // Extract from context if available\n      transitionType: 'cut',        // Default, could be from DB\n    }));\n\n    // Call imageGenerationService\n    imageGenService.generateBatch(\n      panelPrompts,\n      projectId,\n      batchMode,\n      project.generationSettings,\n      (progressEvent) => {\n        // Send progress as SSE\n        res.write(`data: ${JSON.stringify(progressEvent)}\\n\\n`);\n      }\n    ).then(generatedPanels => {\n      // Update database with generated images\n      for (const panel of generatedPanels) {\n        updatePanelImage(panel.panelIndex, {\n          imageUrl: panel.imageUrl,\n          imageFilePath: panel.localFilePath,\n          revisedPrompt: panel.revisedPrompt,\n          status: panel.revisedPrompt ? 'generated' : 'generated',\n        });\n      }\n\n      // Send completion event\n      res.write(`data: ${JSON.stringify({\n        type: 'complete',\n        message: 'Image generation complete',\n        totalCost: generatedPanels.reduce((sum, p) => sum + p.costUsd, 0),\n      })}\\n\\n`);\n\n      res.end();\n    }).catch(err => {\n      res.write(`data: ${JSON.stringify({\n        type: 'error',\n        message: err.message,\n      })}\\n\\n`);\n      res.end();\n    });\n  } catch (err) {\n    next(err);\n  }\n});\n```\n\n### Cost Tracking\n\n**Implementation:**\n- Track cost per API call in GeneratedPanel.costUsd\n- Sum across all panels: `totalCost = sum(generatedPanels.map(p => p.costUsd))`\n- Update project.totalCost in DB: `project.totalCost += generatedPanels totalCost`\n- Log costs for each call (useful for budget monitoring)\n\n**Cost Constants (from types.ts):**\n```typescript\nAPI_COSTS = {\n  VISION_PER_CALL: 0.025,    // GPT-4V\n  DALLE3_STANDARD: 0.040,    // per image\n  DALLE3_HD: 0.080,          // per image\n}\n```\n\n### Testing Requirements\n\n```bash\n# 1. Set up test project (with prompts from Task 2)\nPROJECT_ID=\"test-project-id\"\n# Or use output from Task 2 test\n\n# 2. Generate images (sequential mode)\ncurl -X POST http://localhost:5000/api/manga/$PROJECT_ID/generate-images \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"batchMode\": \"sequential\"}' \\\n  -H \"Accept: text/event-stream\"\n\n# 3. Verify local image files created\nls -la uploads/$PROJECT_ID/\n\n# 4. Check database for updated image URLs\nsqlite3 data/koma-fill.db \"SELECT panelIndex, imageFilePath, status FROM panels WHERE projectId='$PROJECT_ID';\"\n\n# 5. Verify cost tracking\ncurl http://localhost:5000/api/manga/$PROJECT_ID | jq '.totalCost'\n```\n\n### Files This Task Provides to Other Agents\n\n- **Generated panel images** - Stored in uploads/{projectId}/, used by Task 4\n- **Image file paths** - Updated in DB, used by Task 4 for layout composition\n- **Cost tracking** - Used by frontend for budget display\n\n### Output Validation Checklist\n\n- [ ] DALL-E 3 API calls succeed with valid prompts\n- [ ] Retry logic works with exponential backoff\n- [ ] Images download and save to {STORAGE_PATH}/{projectId}/\n- [ ] SSE streaming sends progress events correctly\n- [ ] onProgress callback fires with accurate percentage\n- [ ] Cost calculation correct (0.04 standard, 0.08 HD)\n- [ ] Panel records updated with imageUrl and imageFilePath\n- [ ] Sequential and parallel modes both work\n- [ ] Rate limiting respected (max 5 calls/min by default)\n- [ ] Error handling for network issues, API failures\n- [ ] No TypeScript compilation errors\n\n---\n\n## Task 4: + (Agent D)\n### Manga Layout Composition & Multi-Format Export\n\n**Time Estimate:** 45-60 minutes\n**Difficulty:** Intermediate (Sharp library learning curve)\n**Dependencies:** Task 1 (DB), Task 3 (generated images)\n\n### Objective\nImplement Sharp-based manga layout composition with grid calculation, panel resizing and positioning, border/gutter rendering, speech bubble overlay, and PNG/JPG/PDF export functionality.\n\n### Target Files to Create/Modify\n\n```\nbackend/\n src/\n     services/\n        layoutEngine.ts          [IMPLEMENT] Panel composition & layout\n        exportService.ts         [CREATE] PNG/JPG/PDF export\n     utils/\n         imageProcessor.ts        [HELPER] Image processing utilities\n```\n\n### TypeScript Interfaces\n\n```typescript\n// Layout composition result\nComposedLayout {\n  buffer: Buffer;                    // PNG image buffer\n  width: number;                     // Page width (px)\n  height: number;                    // Page height (px)\n  format: 'png';\n  panelPositions: PanelPosition[];   // Position data for each panel\n}\n\nPanelPosition {\n  panelIndex: number;\n  x: number;                         // Offset from top-left (px)\n  y: number;\n  width: number;                     // Panel width (px)\n  height: number;                    // Panel height (px)\n}\n\n// Input to layout engine\nLayoutConfig {\n  totalPanels: number;               // 4, 6, 8, etc.\n  format: LayoutFormat;              // 'vertical' | 'horizontal' | 'square'\n  readingOrder: ReadingOrder;        // 'japanese' | 'western'\n  gutterSize: number;                // Space between panels (px)\n  borderWidth: number;               // Panel border thickness (px)\n  borderColor: string;               // Hex color\n  backgroundColor: string;           // Hex color\n  pageWidth: number;                 // Canvas width (px)\n  pageHeight: number;                // Canvas height (px)\n}\n```\n\n### Implementation Details\n\n#### LayoutEngine (`backend/src/services/layoutEngine.ts`)\n\n**Method: composePanels() - Main Composition Function**\n\n```typescript\nasync composePanels(\n  panelImagePaths: string[],\n  config: LayoutConfig = DEFAULT_LAYOUT_CONFIG\n): Promise<ComposedLayout>\n```\n\nImplementation Steps:\n\n1. **Calculate Grid:**\n   ```typescript\n   const grid = this.calculateGrid(panelImagePaths.length, config);\n   // Returns { cols: number, rows: number }\n   ```\n   Already implemented - use it.\n\n2. **Calculate Panel Positions:**\n   ```typescript\n   const positions = this.calculatePanelPositions(grid, config);\n   // Returns: PanelPosition[] with x, y, width, height for each panel\n   ```\n   Already implemented - use it.\n\n3. **Create Background Canvas:**\n   ```typescript\n   import sharp from 'sharp';\n\n   let canvas = sharp({\n     create: {\n       width: config.pageWidth,\n       height: config.pageHeight,\n       channels: 4,                    // RGBA\n       background: config.backgroundColor,  // Parsed from hex\n     }\n   });\n   ```\n\n4. **Load & Resize Panel Images:**\n   ```typescript\n   const composites = await Promise.all(\n     panelImagePaths.map(async (imgPath, i) => {\n       if (!fs.existsSync(imgPath)) {\n         throw new Error(`Panel image not found: ${imgPath}`);\n       }\n\n       const position = positions[i];\n       const resized = await sharp(imgPath)\n         .resize(position.width, position.height, {\n           fit: 'cover',              // Fill panel, crop if needed\n           withoutEnlargement: false\n         })\n         .toBuffer();\n\n       return {\n         input: resized,\n         left: position.x,\n         top: position.y\n       };\n     })\n   );\n   ```\n\n5. **Composite Panels Onto Canvas:**\n   ```typescript\n   let result = await canvas.composite(composites).png();\n   ```\n\n6. **Add Borders (Optional - if borderWidth > 0):**\n   - Use SVG overlay to draw rectangles around each panel\n   - Create SVG:\n     ```svg\n     <svg width=\"800\" height=\"1200\">\n       <!-- For each panel position -->\n       <rect x=\"10\" y=\"10\" width=\"390\" height=\"590\"\n             fill=\"none\" stroke=\"black\" stroke-width=\"2\" />\n     </svg>\n     ```\n   - Composite SVG overlay:\n     ```typescript\n     const borderSvg = this.generateBorderSvg(positions, config);\n     result = await result.composite([{\n       input: borderSvg,\n       top: 0,\n       left: 0\n     }]);\n     ```\n\n7. **Return ComposedLayout:**\n   ```typescript\n   const buffer = await result.toBuffer();\n   return {\n     buffer,\n     width: config.pageWidth,\n     height: config.pageHeight,\n     format: 'png',\n     panelPositions: positions\n   };\n   ```\n\n**Method: addSpeechBubbles() - Overlay Speech Bubbles**\n\n```typescript\nasync addSpeechBubbles(\n  layout: ComposedLayout,\n  bubbles: SpeechBubble[]\n): Promise<ComposedLayout>\n```\n\nImplementation:\n\n1. **For each speech bubble:**\n   - Get panel position from layout.panelPositions[bubble.panelIndex]\n   - Calculate bubble position within panel:\n     - 'top'  y = panel.y + 30\n     - 'middle'  y = panel.y + panel.height/2 - 30\n     - 'bottom'  y = panel.y + panel.height - 60\n\n2. **Create SVG speech bubble:**\n   ```typescript\n   const svg = this.generateSpeechBubbleSvg(bubble, position, style);\n   // Generates SVG with text, shape varies by style:\n   // 'rounded', 'cloud', 'spiked', 'rectangular'\n   ```\n\n3. **Composite all bubble SVGs:**\n   ```typescript\n   let result = sharp(layout.buffer);\n   const bubbleSvgs = bubbles.map((bubble, idx) =>\n     this.generateSpeechBubbleSvg(bubble, panelPositions[bubble.panelIndex])\n   );\n\n   result = await result.composite(\n     bubbleSvgs.map((svg, i) => ({ input: svg }))\n   );\n   ```\n\n4. **Return updated ComposedLayout**\n\n**Helper: generateBorderSvg()**\n```typescript\nprivate generateBorderSvg(\n  positions: PanelPosition[],\n  config: LayoutConfig\n): Buffer\n```\n\nGenerate SVG with rectangle borders around each panel:\n```svg\n<svg width=\"800\" height=\"1200\">\n  <rect x=\"10\" y=\"10\" width=\"390\" height=\"590\"\n        fill=\"none\" stroke=\"#000000\" stroke-width=\"2\" />\n  <!-- repeated for each panel -->\n</svg>\n```\n\nConvert to Buffer and return.\n\n**Helper: generateSpeechBubbleSvg()**\n```typescript\nprivate generateSpeechBubbleSvg(\n  bubble: SpeechBubble,\n  panelPosition: PanelPosition,\n  targetY: number  // top/middle/bottom\n): Buffer\n```\n\nGenerate SVG with speech bubble shape. Example for 'rounded':\n```svg\n<svg width=\"300\" height=\"100\">\n  <!-- Rounded rectangle -->\n  <path d=\"M 10,10 Q 10,10 20,10 L 270,10 Q 280,10 280,20 L 280,70 Q 280,80 270,80 L 30,80 Q 20,80 20,70 L 20,40 L 0,60 L 20,50 L 20,20 Q 20,10 10,10\"\n        fill=\"white\" stroke=\"black\" stroke-width=\"1\" />\n  <text x=\"20\" y=\"50\" font-family=\"Arial\" font-size=\"14\">Your text here</text>\n</svg>\n```\n\nReturn SVG as Buffer via:\n```typescript\nconst svgBuffer = Buffer.from(svgString, 'utf-8');\n```\n\n### ExportService (`backend/src/services/exportService.ts`) - NEW FILE\n\nImplement export to PNG, JPG, PDF formats.\n\n```typescript\nexport class ExportService {\n  async exportPNG(\n    layout: ComposedLayout,\n    filepath: string,\n    compression: 'low' | 'medium' | 'high'\n  ): Promise<void>\n\n  async exportJPG(\n    layout: ComposedLayout,\n    filepath: string,\n    quality: number  // 60-95\n  ): Promise<void>\n\n  async exportPDF(\n    layout: ComposedLayout,\n    filepath: string,\n    metadata: { title?: string; author?: string }\n  ): Promise<void>\n}\n```\n\n**exportPNG():**\n```typescript\nasync exportPNG(layout, filepath, compression) {\n  const compressionLevel = compression === 'high' ? 9 : compression === 'medium' ? 6 : 1;\n  await sharp(layout.buffer)\n    .png({ compressionLevel })\n    .toFile(filepath);\n}\n```\n\n**exportJPG():**\n```typescript\nasync exportJPG(layout, filepath, quality = 80) {\n  await sharp(layout.buffer)\n    .jpeg({ quality, mozjpeg: true })\n    .toFile(filepath);\n}\n```\n\n**exportPDF():**\nRequires pdfkit library:\n```typescript\nimport PDFDocument from 'pdfkit';\nimport { createWriteStream } from 'fs';\n\nasync exportPDF(layout, filepath, metadata = {}) {\n  const doc = new PDFDocument({\n    size: [layout.width, layout.height]\n  });\n\n  if (metadata.title) doc.title(metadata.title);\n  if (metadata.author) doc.author(metadata.author);\n\n  // Add image to PDF\n  doc.image(layout.buffer, 0, 0, {\n    width: layout.width,\n    height: layout.height\n  });\n\n  doc.pipe(createWriteStream(filepath));\n  doc.end();\n}\n```\n\n### Route Handler Integration\n\nImplement in `backend/src/routes/manga.ts`:\n\n**POST /api/manga/:projectId/layout**\n```typescript\nrouter.post('/:projectId/layout', async (req: Request, res: Response, next: NextFunction) => {\n  try {\n    const { projectId } = req.params;\n    const { speechBubbles } = req.body as GenerateLayoutRequest;\n\n    // Fetch project and panels from DB\n    const project = await getProject(projectId);\n    if (!project) throw new NotFoundError('Project');\n\n    // Get panel image paths\n    const panelPaths = project.panels\n      .sort((a, b) => a.panelIndex - b.panelIndex)\n      .map(p => p.imageFilePath)\n      .filter(path => path !== undefined);\n\n    // Compose layout\n    const layoutEngine = new LayoutEngine();\n    let layout = await layoutEngine.composePanels(panelPaths, project.layoutConfig);\n\n    // Add speech bubbles if provided\n    if (speechBubbles && speechBubbles.length > 0) {\n      layout = await layoutEngine.addSpeechBubbles(layout, speechBubbles);\n    }\n\n    // Save layout buffer to temporary file for preview\n    const layoutPath = path.join(CONFIG.STORAGE_PATH, projectId, 'layout.png');\n    await fs.writeFile(layoutPath, layout.buffer);\n\n    // Update project status\n    await updateProject(projectId, { status: 'complete' });\n\n    // Return layout info\n    res.json({\n      message: 'Layout composed successfully',\n      projectId,\n      layoutPath: `/uploads/${projectId}/layout.png`,\n      panelPositions: layout.panelPositions,\n      dimensions: { width: layout.width, height: layout.height }\n    });\n  } catch (err) {\n    next(err);\n  }\n});\n```\n\n**POST /api/manga/:projectId/export**\n```typescript\nrouter.post('/:projectId/export', async (req: Request, res: Response, next: NextFunction) => {\n  try {\n    const { projectId } = req.params;\n    const { format, compression, resolution, title, author } = req.body as ExportRequest;\n\n    // Fetch project layout\n    const layoutPath = path.join(CONFIG.STORAGE_PATH, projectId, 'layout.png');\n    if (!fs.existsSync(layoutPath)) {\n      throw new Error('Layout not yet generated. Call /layout endpoint first.');\n    }\n\n    const layoutBuffer = await fs.promises.readFile(layoutPath);\n    const layout: ComposedLayout = {\n      buffer: layoutBuffer,\n      width: 800,  // From project.layoutConfig\n      height: 1200,\n      format: 'png',\n      panelPositions: []  // Could fetch from DB if needed\n    };\n\n    // Export to requested format\n    const exportService = new ExportService();\n    const timestamp = Date.now();\n    const exportPath = path.join(CONFIG.STORAGE_PATH, projectId, `manga_${timestamp}.${format}`);\n\n    if (format === 'png') {\n      await exportService.exportPNG(layout, exportPath, compression as 'low' | 'medium' | 'high');\n    } else if (format === 'jpg') {\n      const qualityMap = { low: 60, medium: 80, high: 95 };\n      await exportService.exportJPG(layout, exportPath, qualityMap[compression]);\n    } else if (format === 'pdf') {\n      await exportService.exportPDF(layout, exportPath, { title, author });\n    }\n\n    // Update project status\n    await updateProject(projectId, { status: 'exported' });\n\n    res.json({\n      message: 'Export successful',\n      projectId,\n      format,\n      downloadUrl: `/uploads/${projectId}/manga_${timestamp}.${format}`,\n      filePath: exportPath\n    });\n  } catch (err) {\n    next(err);\n  }\n});\n```\n\n### Testing Requirements\n\n```bash\n# 1. Generate layout from Task 3 images\nPROJECT_ID=\"test-project-id\"\ncurl -X POST http://localhost:5000/api/manga/$PROJECT_ID/layout \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\n    \"speechBubbles\": [\n      {\n        \"panelIndex\": 0,\n        \"text\": \"Wow!\",\n        \"position\": \"top\",\n        \"style\": \"rounded\"\n      }\n    ]\n  }'\n\n# 2. View composed layout\nopen http://localhost:5000/uploads/$PROJECT_ID/layout.png\n\n# 3. Export to PNG\ncurl -X POST http://localhost:5000/api/manga/$PROJECT_ID/export \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\n    \"format\": \"png\",\n    \"compression\": \"medium\",\n    \"resolution\": \"web\",\n    \"title\": \"My Manga\"\n  }'\n\n# 4. Export to PDF\ncurl -X POST http://localhost:5000/api/manga/$PROJECT_ID/export \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\n    \"format\": \"pdf\",\n    \"compression\": \"medium\",\n    \"title\": \"My Manga\",\n    \"author\": \"AI Creator\"\n  }'\n\n# 5. Verify files exist\nls -lh uploads/$PROJECT_ID/\n```\n\n### Files This Task Provides to Other Agents\n\n- **Composed layout image** - Used by frontend for preview\n- **Export files** - PNG/JPG/PDF outputs for download\n- **Layout metadata** - Panel positions for debugging/display\n\n### Output Validation Checklist\n\n- [ ] calculateGrid() and calculatePanelPositions() methods work correctly\n- [ ] composePanels() successfully combines images with sharp\n- [ ] Borders render correctly around panels\n- [ ] Speech bubbles overlay without distortion\n- [ ] Multiple speech bubble styles work ('rounded', 'cloud', 'spiked', 'rectangular')\n- [ ] Layout PNG saved and readable\n- [ ] exportPNG() produces valid PNG files\n- [ ] exportJPG() produces valid JPG files with quality control\n- [ ] exportPDF() produces valid PDF with metadata\n- [ ] /layout endpoint returns correct panel positions\n- [ ] /export endpoint returns download URLs\n- [ ] Compression settings affect file size appropriately\n- [ ] No TypeScript compilation errors\n\n---\n\n## Task 5: React (Agent E)\n### Complete React UI with Component Implementation\n\n**Time Estimate:** 60-80 minutes\n**Difficulty:** Intermediate (React component patterns)\n**Dependencies:** Tasks 1-4 (backend API must be running)\n\n### Objective\nComplete all React components for the koma-fill frontend including image upload with drag-drop, story prompt editor, panel grid with drag-and-drop reordering, complete manga generation workflow orchestration, real-time SSE progress updates, and multi-format export options. Configure Tailwind CSS for styling.\n\n### Target Files to Create/Modify\n\n```\nfrontend/\n src/\n    components/\n       ImageUploader.tsx           [IMPLEMENT] Dropzone with position selector\n       StoryPromptEditor.tsx       [ENHANCE] Add sample prompts\n       PanelGrid.tsx               [IMPLEMENT] Drag-and-drop reordering\n       LayoutSelector.tsx          [VERIFY] Layout config UI\n       ExportOptions.tsx           [VERIFY] Export format selection\n       ProgressBar.tsx             [CREATE] Real-time progress display\n    hooks/\n       useMangaGeneration.ts       [IMPLEMENT] Full workflow orchestration\n    services/\n       apiClient.ts                [IMPLEMENT] API client with SSE support\n    pages/\n       CreateMangaPage.tsx         [IMPLEMENT] Main workflow page\n       PreviewPage.tsx             [IMPLEMENT] Result preview & download\n    App.tsx                         [UPDATE] Routing\n    main.tsx                        [VERIFY] Entry point\n    index.css                       [UPDATE] Tailwind directives\n tailwind.config.js                  [CREATE] Tailwind configuration\n postcss.config.js                   [CREATE] PostCSS configuration\n package.json                        [UPDATE] Add Tailwind dependencies\n tsconfig.json                       [VERIFY] TypeScript config\n```\n\n### TypeScript Interfaces (from `frontend/src/types/index.ts`)\n\nAlready defined - reference for component props.\n\n### Implementation Details\n\n#### 1. Tailwind CSS Setup\n\n**Install Dependencies:**\n```bash\ncd frontend\nnpm install -D tailwindcss postcss autoprefixer\nnpx tailwindcss init -p\n```\n\n**tailwind.config.js:**\n```javascript\nexport default {\n  content: [\n    './index.html',\n    './src/**/*.{js,ts,jsx,tsx}',\n  ],\n  theme: {\n    extend: {\n      colors: {\n        manga: {\n          dark: '#1a1a1a',\n          light: '#f5f5f5',\n        }\n      }\n    },\n  },\n  plugins: [],\n}\n```\n\n**postcss.config.js:**\n```javascript\nexport default {\n  plugins: {\n    tailwindcss: {},\n    autoprefixer: {},\n  },\n}\n```\n\n**frontend/src/index.css:**\n```css\n@tailwind base;\n@tailwind components;\n@tailwind utilities;\n\n@layer components {\n  .btn-primary {\n    @apply px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700 transition;\n  }\n  .btn-secondary {\n    @apply px-4 py-2 bg-gray-300 text-gray-800 rounded-lg hover:bg-gray-400 transition;\n  }\n  .input-field {\n    @apply w-full px-3 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500;\n  }\n}\n```\n\n#### 2. API Client (`frontend/src/services/apiClient.ts`)\n\n```typescript\nimport { MangaProject, Panel, GenerationProgress, ProgressEvent } from '../types';\n\nconst API_BASE = import.meta.env.VITE_API_URL || 'http://localhost:5000/api';\n\nexport class APIClient {\n  /**\n   * Create new manga project\n   */\n  async createProject(name: string, storyPrompt: string, layoutConfig?: any) {\n    const response = await fetch(`${API_BASE}/manga/create`, {\n      method: 'POST',\n      headers: { 'Content-Type': 'application/json' },\n      body: JSON.stringify({\n        projectName: name,\n        storyPrompt,\n        layoutConfig\n      })\n    });\n    if (!response.ok) throw new Error(await response.text());\n    return response.json() as Promise<MangaProject>;\n  }\n\n  /**\n   * Upload key images\n   */\n  async uploadImages(projectId: string, files: File[]) {\n    const formData = new FormData();\n    files.forEach(file => formData.append('images', file));\n\n    const response = await fetch(`${API_BASE}/manga/${projectId}/upload`, {\n      method: 'POST',\n      body: formData\n    });\n    if (!response.ok) throw new Error(await response.text());\n    return response.json();\n  }\n\n  /**\n   * Analyze images using Vision API\n   */\n  async analyzeImages(projectId: string, depth: 'quick' | 'detailed' = 'quick') {\n    const response = await fetch(`${API_BASE}/manga/${projectId}/analyze`, {\n      method: 'POST',\n      headers: { 'Content-Type': 'application/json' },\n      body: JSON.stringify({ analysisDepth: depth })\n    });\n    if (!response.ok) throw new Error(await response.text());\n    return response.json();\n  }\n\n  /**\n   * Generate panel prompts\n   */\n  async generatePrompts(projectId: string, storyPrompt: string, panelCount: number) {\n    const response = await fetch(`${API_BASE}/manga/${projectId}/generate-prompts`, {\n      method: 'POST',\n      headers: { 'Content-Type': 'application/json' },\n      body: JSON.stringify({\n        storyPrompt,\n        panelCount,\n        characterConsistency: true\n      })\n    });\n    if (!response.ok) throw new Error(await response.text());\n    return response.json() as Promise<Panel[]>;\n  }\n\n  /**\n   * Generate images via DALL-E 3 (SSE streaming)\n   */\n  streamImageGeneration(\n    projectId: string,\n    batchMode: 'sequential' | 'parallel',\n    onProgress: (event: ProgressEvent) => void,\n    onError: (error: Error) => void\n  ): () => void {\n    const eventSource = new EventSource(\n      `${API_BASE}/manga/${projectId}/generate-images?batchMode=${batchMode}`\n    );\n\n    eventSource.onmessage = (event) => {\n      try {\n        const data = JSON.parse(event.data);\n        onProgress(data);\n      } catch (e) {\n        console.error('Failed to parse SSE message:', e);\n      }\n    };\n\n    eventSource.onerror = () => {\n      onError(new Error('Generation failed or connection lost'));\n      eventSource.close();\n    };\n\n    // Return cleanup function\n    return () => eventSource.close();\n  }\n\n  /**\n   * Compose layout with speech bubbles\n   */\n  async composeLayout(projectId: string, speechBubbles?: any) {\n    const response = await fetch(`${API_BASE}/manga/${projectId}/layout`, {\n      method: 'POST',\n      headers: { 'Content-Type': 'application/json' },\n      body: JSON.stringify({ speechBubbles })\n    });\n    if (!response.ok) throw new Error(await response.text());\n    return response.json();\n  }\n\n  /**\n   * Export to PNG/JPG/PDF\n   */\n  async exportManga(\n    projectId: string,\n    format: 'png' | 'jpg' | 'pdf',\n    compression: 'low' | 'medium' | 'high' = 'medium',\n    title?: string,\n    author?: string\n  ) {\n    const response = await fetch(`${API_BASE}/manga/${projectId}/export`, {\n      method: 'POST',\n      headers: { 'Content-Type': 'application/json' },\n      body: JSON.stringify({\n        format,\n        compression,\n        resolution: 'web',\n        title,\n        author\n      })\n    });\n    if (!response.ok) throw new Error(await response.text());\n    return response.json();\n  }\n\n  /**\n   * Fetch project details\n   */\n  async getProject(projectId: string) {\n    const response = await fetch(`${API_BASE}/manga/${projectId}`);\n    if (!response.ok) throw new Error(await response.text());\n    return response.json() as Promise<MangaProject>;\n  }\n\n  /**\n   * Reorder panels\n   */\n  async reorderPanels(projectId: string, panelOrder: number[]) {\n    const response = await fetch(`${API_BASE}/manga/${projectId}/reorder`, {\n      method: 'PUT',\n      headers: { 'Content-Type': 'application/json' },\n      body: JSON.stringify({ panelOrder })\n    });\n    if (!response.ok) throw new Error(await response.text());\n    return response.json();\n  }\n}\n\nexport const apiClient = new APIClient();\n```\n\n#### 3. useMangaGeneration Hook (`frontend/src/hooks/useMangaGeneration.ts`)\n\n```typescript\nimport { useState, useCallback } from 'react';\nimport { apiClient } from '../services/apiClient';\nimport { MangaProject, GenerationProgress, UploadedImage } from '../types';\n\nexport function useMangaGeneration() {\n  const [project, setProject] = useState<MangaProject | null>(null);\n  const [progress, setProgress] = useState<GenerationProgress>({\n    stage: 'idle',\n    currentStep: 0,\n    totalSteps: 0,\n    percentage: 0,\n    message: ''\n  });\n  const [error, setError] = useState<string | null>(null);\n\n  /**\n   * Complete workflow: Create  Upload  Analyze  Generate Prompts  Generate Images  Layout\n   */\n  const generateManga = useCallback(async (\n    projectName: string,\n    storyPrompt: string,\n    uploadedImages: UploadedImage[],\n    layoutConfig: any,\n    generationSettings: any\n  ) => {\n    try {\n      setError(null);\n\n      // Stage 1: Create project\n      setProgress({\n        stage: 'uploading',\n        currentStep: 0,\n        totalSteps: 5,\n        percentage: 20,\n        message: 'Creating project...'\n      });\n      const newProject = await apiClient.createProject(projectName, storyPrompt, layoutConfig);\n      setProject(newProject);\n\n      // Stage 2: Upload images\n      setProgress({\n        stage: 'uploading',\n        currentStep: 1,\n        totalSteps: 5,\n        percentage: 40,\n        message: 'Uploading reference images...'\n      });\n      const files = uploadedImages.map(img => img.file);\n      await apiClient.uploadImages(newProject.id, files);\n\n      // Stage 3: Analyze images\n      setProgress({\n        stage: 'analyzing',\n        currentStep: 2,\n        totalSteps: 5,\n        percentage: 60,\n        message: 'Analyzing images with Vision API...'\n      });\n      await apiClient.analyzeImages(newProject.id, 'detailed');\n\n      // Stage 4: Generate prompts\n      setProgress({\n        stage: 'generating_prompts',\n        currentStep: 3,\n        totalSteps: 5,\n        percentage: 70,\n        message: 'Generating panel prompts...'\n      });\n      await apiClient.generatePrompts(\n        newProject.id,\n        storyPrompt,\n        layoutConfig.totalPanels\n      );\n\n      // Stage 5: Generate images (with SSE streaming)\n      setProgress({\n        stage: 'generating_images',\n        currentStep: 4,\n        totalSteps: 5,\n        percentage: 75,\n        message: 'Starting image generation...'\n      });\n\n      await new Promise<void>((resolve, reject) => {\n        const cleanup = apiClient.streamImageGeneration(\n          newProject.id,\n          'sequential',  // or 'parallel' based on user preference\n          (progressEvent) => {\n            if (progressEvent.type === 'complete') {\n              setProgress(prev => ({\n                ...prev,\n                percentage: 90,\n                message: 'Image generation complete!'\n              }));\n              resolve();\n            } else if (progressEvent.type === 'error') {\n              reject(new Error(progressEvent.error || 'Generation failed'));\n            } else {\n              setProgress({\n                stage: 'generating_images',\n                currentStep: 4 + (progressEvent.currentStep || 0) * 0.1,\n                totalSteps: 5,\n                percentage: 75 + (progressEvent.percentage || 0) * 0.15,\n                message: progressEvent.message,\n                currentPanelIndex: progressEvent.panelIndex\n              });\n            }\n          },\n          reject\n        );\n      });\n\n      // Stage 6: Compose layout\n      setProgress({\n        stage: 'composing_layout',\n        currentStep: 5,\n        totalSteps: 5,\n        percentage: 95,\n        message: 'Composing final layout...'\n      });\n      await apiClient.composeLayout(newProject.id);\n\n      // Complete\n      const finalProject = await apiClient.getProject(newProject.id);\n      setProject(finalProject);\n      setProgress({\n        stage: 'idle',\n        currentStep: 5,\n        totalSteps: 5,\n        percentage: 100,\n        message: 'Manga generation complete!'\n      });\n\n    } catch (err) {\n      const errorMsg = err instanceof Error ? err.message : 'Unknown error';\n      setError(errorMsg);\n      setProgress({\n        stage: 'idle',\n        currentStep: 0,\n        totalSteps: 0,\n        percentage: 0,\n        message: `Error: ${errorMsg}`\n      });\n    }\n  }, []);\n\n  const exportManga = useCallback(async (\n    projectId: string,\n    format: 'png' | 'jpg' | 'pdf',\n    compression: 'low' | 'medium' | 'high' = 'medium'\n  ) => {\n    try {\n      setError(null);\n      setProgress({\n        stage: 'exporting',\n        currentStep: 0,\n        totalSteps: 1,\n        percentage: 50,\n        message: `Exporting as ${format.toUpperCase()}...`\n      });\n\n      const result = await apiClient.exportManga(projectId, format, compression);\n\n      setProgress({\n        stage: 'idle',\n        currentStep: 1,\n        totalSteps: 1,\n        percentage: 100,\n        message: 'Export complete!'\n      });\n\n      return result;\n    } catch (err) {\n      const errorMsg = err instanceof Error ? err.message : 'Export failed';\n      setError(errorMsg);\n      throw err;\n    }\n  }, []);\n\n  return {\n    project,\n    progress,\n    error,\n    generateManga,\n    exportManga,\n    setError\n  };\n}\n```\n\n#### 4. Components\n\n**ImageUploader.tsx:**\n```typescript\nimport { useCallback, useState } from 'react';\nimport { UploadedImage, ImagePosition } from '../types';\n\ninterface ImageUploaderProps {\n  onImagesSelected: (images: UploadedImage[]) => void;\n}\n\nexport function ImageUploader({ onImagesSelected }: ImageUploaderProps) {\n  const [images, setImages] = useState<UploadedImage[]>([]);\n  const [selectedPosition, setSelectedPosition] = useState<ImagePosition>('start');\n\n  const handleDrop = useCallback((e: React.DragEvent) => {\n    e.preventDefault();\n    const files = Array.from(e.dataTransfer.files).filter(f => f.type.startsWith('image/'));\n    addImages(files);\n  }, []);\n\n  const handleFileInput = (e: React.ChangeEvent<HTMLInputElement>) => {\n    if (e.target.files) {\n      addImages(Array.from(e.target.files));\n    }\n  };\n\n  const addImages = (files: File[]) => {\n    const newImages = files.map(file => ({\n      file,\n      previewUrl: URL.createObjectURL(file),\n      position: selectedPosition\n    }));\n    setImages(prev => [...prev, ...newImages]);\n    onImagesSelected([...images, ...newImages]);\n  };\n\n  const removeImage = (index: number) => {\n    const updated = images.filter((_, i) => i !== index);\n    setImages(updated);\n    onImagesSelected(updated);\n  };\n\n  return (\n    <div className=\"w-full max-w-2xl\">\n      <div\n        onDrop={handleDrop}\n        onDragOver={e => e.preventDefault()}\n        className=\"border-2 border-dashed border-gray-300 rounded-lg p-8 text-center cursor-pointer hover:border-blue-500 transition\"\n      >\n        <p className=\"text-gray-600 mb-4\">Drag and drop images here or click to select</p>\n        <input\n          type=\"file\"\n          multiple\n          accept=\"image/*\"\n          onChange={handleFileInput}\n          className=\"hidden\"\n          id=\"image-input\"\n        />\n        <label htmlFor=\"image-input\" className=\"btn-primary cursor-pointer\">\n          Select Images\n        </label>\n      </div>\n\n      <div className=\"mt-4\">\n        <label className=\"block mb-2\">Position in Story:</label>\n        <select\n          value={selectedPosition}\n          onChange={e => setSelectedPosition(e.target.value as ImagePosition)}\n          className=\"input-field\"\n        >\n          <option value=\"start\">Start (Reference)</option>\n          <option value=\"end\">End (Reference)</option>\n          <option value={1}>Panel 1</option>\n          <option value={2}>Panel 2</option>\n        </select>\n      </div>\n\n      {images.length > 0 && (\n        <div className=\"mt-6 grid grid-cols-2 gap-4\">\n          {images.map((img, idx) => (\n            <div key={idx} className=\"relative\">\n              <img src={img.previewUrl} alt={`Preview ${idx}`} className=\"rounded-lg w-full h-48 object-cover\" />\n              <button\n                onClick={() => removeImage(idx)}\n                className=\"absolute top-2 right-2 bg-red-500 text-white rounded-full w-6 h-6 flex items-center justify-center hover:bg-red-600\"\n              >\n                \n              </button>\n            </div>\n          ))}\n        </div>\n      )}\n    </div>\n  );\n}\n```\n\n**StoryPromptEditor.tsx (Enhanced):**\n```typescript\nimport { useState } from 'react';\n\ninterface StoryPromptEditorProps {\n  value: string;\n  onChange: (value: string) => void;\n}\n\nconst SAMPLE_PROMPTS = [\n  'A young ninja discovers their hidden powers and must save their village from a mysterious threat.',\n  'Two rival chefs compete in a cooking tournament, discovering they have more in common than they thought.',\n  'A time traveler must prevent a catastrophic event by gathering clues from different eras.',\n];\n\nexport function StoryPromptEditor({ value, onChange }: StoryPromptEditorProps) {\n  const [isExpanded, setIsExpanded] = useState(false);\n\n  return (\n    <div className=\"w-full max-w-2xl\">\n      <label className=\"block text-lg font-semibold mb-2\">Your Story Prompt</label>\n\n      <textarea\n        value={value}\n        onChange={e => onChange(e.target.value)}\n        placeholder=\"Write your manga story here. Be descriptive about characters, setting, and plot...\"\n        className=\"input-field h-32 resize-none\"\n      />\n\n      <div className=\"mt-4\">\n        <button\n          onClick={() => setIsExpanded(!isExpanded)}\n          className=\"text-blue-600 hover:underline text-sm\"\n        >\n          {isExpanded ? 'Hide' : 'Show'} Sample Prompts\n        </button>\n\n        {isExpanded && (\n          <div className=\"mt-3 space-y-2\">\n            {SAMPLE_PROMPTS.map((prompt, idx) => (\n              <button\n                key={idx}\n                onClick={() => onChange(prompt)}\n                className=\"block w-full text-left p-3 bg-gray-100 hover:bg-gray-200 rounded-lg text-sm transition\"\n              >\n                {prompt}\n              </button>\n            ))}\n          </div>\n        )}\n      </div>\n    </div>\n  );\n}\n```\n\n**PanelGrid.tsx (with Drag-and-Drop):**\n```typescript\nimport { useState } from 'react';\nimport { Panel } from '../types';\nimport { DndContext, closestCenter, KeyboardSensor, PointerSensor, useSensor, useSensors } from '@dnd-kit/core';\nimport { SortableContext, sortableKeyboardCoordinates, verticalListSortingStrategy, useSortable } from '@dnd-kit/sortable';\nimport { CSS } from '@dnd-kit/utilities';\n\nfunction SortablePanel({ panel }: { panel: Panel }) {\n  const { attributes, listeners, setNodeRef, transform, transition } = useSortable({ id: panel.id });\n  const style = { transform: CSS.Transform.toString(transform), transition };\n\n  return (\n    <div ref={setNodeRef} style={style} {...attributes} {...listeners} className=\"p-4\">\n      <div className=\"bg-white rounded-lg shadow p-4 cursor-grab active:cursor-grabbing\">\n        <img\n          src={panel.imageUrl}\n          alt={`Panel ${panel.panelIndex}`}\n          className=\"w-full h-auto rounded mb-2\"\n        />\n        <p className=\"text-sm text-gray-600\">{panel.storyBeat}</p>\n        <span className={`inline-block mt-2 px-2 py-1 rounded text-xs text-white ${\n          panel.status === 'generated' ? 'bg-green-500' :\n          panel.status === 'pending' ? 'bg-blue-500' :\n          'bg-red-500'\n        }`}>\n          {panel.status}\n        </span>\n      </div>\n    </div>\n  );\n}\n\ninterface PanelGridProps {\n  panels: Panel[];\n  onReorder: (newOrder: Panel[]) => void;\n}\n\nexport function PanelGrid({ panels, onReorder }: PanelGridProps) {\n  const sensors = useSensors(\n    useSensor(PointerSensor),\n    useSensor(KeyboardSensor, { coordinateGetter: sortableKeyboardCoordinates })\n  );\n\n  const handleDragEnd = (event: any) => {\n    const { active, over } = event;\n    if (over && active.id !== over.id) {\n      const oldIndex = panels.findIndex(p => p.id === active.id);\n      const newIndex = panels.findIndex(p => p.id === over.id);\n      const newPanels = [...panels];\n      [newPanels[oldIndex], newPanels[newIndex]] = [newPanels[newIndex], newPanels[oldIndex]];\n      onReorder(newPanels);\n    }\n  };\n\n  return (\n    <DndContext sensors={sensors} collisionDetection={closestCenter} onDragEnd={handleDragEnd}>\n      <SortableContext items={panels.map(p => p.id)} strategy={verticalListSortingStrategy}>\n        <div className=\"grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-4\">\n          {panels.map(panel => (\n            <SortablePanel key={panel.id} panel={panel} />\n          ))}\n        </div>\n      </SortableContext>\n    </DndContext>\n  );\n}\n```\n\n**ProgressBar.tsx:**\n```typescript\nimport { GenerationProgress } from '../types';\n\nexport function ProgressBar({ progress }: { progress: GenerationProgress }) {\n  return (\n    <div className=\"w-full max-w-2xl\">\n      <div className=\"mb-2 flex justify-between\">\n        <span className=\"text-sm font-semibold\">{progress.message}</span>\n        <span className=\"text-sm text-gray-600\">{Math.round(progress.percentage)}%</span>\n      </div>\n      <div className=\"w-full h-3 bg-gray-200 rounded-full overflow-hidden\">\n        <div\n          className=\"h-full bg-blue-600 transition-all duration-300\"\n          style={{ width: `${progress.percentage}%` }}\n        />\n      </div>\n    </div>\n  );\n}\n```\n\n#### 5. Pages\n\n**CreateMangaPage.tsx:**\n```typescript\nimport { useState } from 'react';\nimport { ImageUploader } from '../components/ImageUploader';\nimport { StoryPromptEditor } from '../components/StoryPromptEditor';\nimport { LayoutSelector } from '../components/LayoutSelector';\nimport { ProgressBar } from '../components/ProgressBar';\nimport { useMangaGeneration } from '../hooks/useMangaGeneration';\nimport { UploadedImage, LayoutConfig } from '../types';\n\nexport function CreateMangaPage() {\n  const [projectName, setProjectName] = useState('');\n  const [storyPrompt, setStoryPrompt] = useState('');\n  const [uploadedImages, setUploadedImages] = useState<UploadedImage[]>([]);\n  const [layoutConfig, setLayoutConfig] = useState<LayoutConfig>({\n    totalPanels: 4,\n    format: 'vertical',\n    readingOrder: 'japanese',\n    gutterSize: 10,\n    borderWidth: 2,\n    borderColor: '#000000',\n    backgroundColor: '#FFFFFF',\n    pageWidth: 800,\n    pageHeight: 1200\n  });\n\n  const { progress, error, generateManga } = useMangaGeneration();\n\n  const handleStart = async () => {\n    if (!projectName || !storyPrompt) {\n      alert('Please enter project name and story prompt');\n      return;\n    }\n\n    await generateManga(projectName, storyPrompt, uploadedImages, layoutConfig, {\n      imageStyle: 'manga style',\n      aspectRatio: 'square',\n      qualityLevel: 'standard'\n    });\n  };\n\n  return (\n    <div className=\"min-h-screen bg-gray-50 py-12 px-4\">\n      <div className=\"max-w-4xl mx-auto space-y-8\">\n        <h1 className=\"text-4xl font-bold text-center mb-2\">koma-fill</h1>\n        <p className=\"text-center text-gray-600\">AI-Powered Manga Panel Generator</p>\n\n        {error && <div className=\"bg-red-100 border border-red-400 text-red-700 px-4 py-3 rounded\">{error}</div>}\n\n        {progress.stage === 'idle' ? (\n          <div className=\"space-y-8\">\n            <div className=\"bg-white p-6 rounded-lg shadow\">\n              <label className=\"block text-lg font-semibold mb-2\">Project Name</label>\n              <input\n                type=\"text\"\n                value={projectName}\n                onChange={e => setProjectName(e.target.value)}\n                className=\"input-field\"\n                placeholder=\"My Awesome Manga\"\n              />\n            </div>\n\n            <div className=\"bg-white p-6 rounded-lg shadow\">\n              <StoryPromptEditor value={storyPrompt} onChange={setStoryPrompt} />\n            </div>\n\n            <div className=\"bg-white p-6 rounded-lg shadow\">\n              <ImageUploader onImagesSelected={setUploadedImages} />\n            </div>\n\n            <div className=\"bg-white p-6 rounded-lg shadow\">\n              <LayoutSelector config={layoutConfig} onChange={setLayoutConfig} />\n            </div>\n\n            <button onClick={handleStart} className=\"btn-primary w-full text-lg py-3\">\n              Generate Manga\n            </button>\n          </div>\n        ) : (\n          <div className=\"bg-white p-6 rounded-lg shadow\">\n            <ProgressBar progress={progress} />\n          </div>\n        )}\n      </div>\n    </div>\n  );\n}\n```\n\n**PreviewPage.tsx:**\n```typescript\nimport { useParams, useNavigate } from 'react-router-dom';\nimport { useEffect, useState } from 'react';\nimport { apiClient } from '../services/apiClient';\nimport { PanelGrid } from '../components/PanelGrid';\nimport { ExportOptions } from '../components/ExportOptions';\nimport { MangaProject } from '../types';\n\nexport function PreviewPage() {\n  const { projectId } = useParams<{ projectId: string }>();\n  const navigate = useNavigate();\n  const [project, setProject] = useState<MangaProject | null>(null);\n  const [loading, setLoading] = useState(true);\n\n  useEffect(() => {\n    if (projectId) {\n      apiClient.getProject(projectId).then(setProject).finally(() => setLoading(false));\n    }\n  }, [projectId]);\n\n  if (loading) return <div className=\"flex justify-center py-12\">Loading...</div>;\n  if (!project) return <div className=\"text-center py-12\">Project not found</div>;\n\n  return (\n    <div className=\"min-h-screen bg-gray-50 py-12 px-4\">\n      <div className=\"max-w-6xl mx-auto\">\n        <button onClick={() => navigate('/')} className=\"btn-secondary mb-6\"> Back</button>\n\n        <h1 className=\"text-3xl font-bold mb-2\">{project.name}</h1>\n        <p className=\"text-gray-600 mb-6\">Project Status: {project.status}</p>\n\n        {project.panels.length > 0 && (\n          <div className=\"bg-white p-6 rounded-lg shadow mb-8\">\n            <h2 className=\"text-2xl font-semibold mb-4\">Panels</h2>\n            <PanelGrid panels={project.panels} onReorder={() => {}} />\n          </div>\n        )}\n\n        <div className=\"bg-white p-6 rounded-lg shadow\">\n          <h2 className=\"text-2xl font-semibold mb-4\">Export</h2>\n          <ExportOptions projectId={project.id} />\n        </div>\n      </div>\n    </div>\n  );\n}\n```\n\n#### 6. Update App.tsx\n\n```typescript\nimport { BrowserRouter as Router, Routes, Route, Navigate } from 'react-router-dom';\nimport { CreateMangaPage } from './pages/CreateMangaPage';\nimport { PreviewPage } from './pages/PreviewPage';\nimport './index.css';\n\nexport default function App() {\n  return (\n    <Router>\n      <Routes>\n        <Route path=\"/\" element={<CreateMangaPage />} />\n        <Route path=\"/project/:projectId\" element={<PreviewPage />} />\n        <Route path=\"*\" element={<Navigate to=\"/\" />} />\n      </Routes>\n    </Router>\n  );\n}\n```\n\n### package.json Updates\n\nAdd dependencies:\n```bash\nnpm install -D tailwindcss postcss autoprefixer\nnpm install react-router-dom @dnd-kit/core @dnd-kit/sortable @dnd-kit/utilities\n```\n\n### Testing Requirements\n\n```bash\n# 1. Start backend (from Task 1)\ncd backend && npm run dev\n\n# 2. In another terminal, start frontend\ncd frontend && npm run dev\n\n# 3. Open browser: http://localhost:3000\n\n# 4. Test workflow:\n# - Enter project name and story\n# - Upload reference images\n# - Configure layout\n# - Click \"Generate Manga\"\n# - Watch progress bar\n# - See panel grid with images\n# - Export to PNG/JPG/PDF\n```\n\n### Files This Task Uses from Other Agents\n\n- **API endpoints** from Task 1 (database & routes)\n- **Analysis data** from Task 2 (character consistency)\n- **Generated images** from Task 3 (panel images)\n- **Composed layouts** from Task 4 (final manga)\n\n### Output Validation Checklist\n\n- [ ] Tailwind CSS configured and working\n- [ ] ImageUploader component with drag-drop works\n- [ ] react-dropzone integration functional\n- [ ] StoryPromptEditor displays with sample prompts\n- [ ] Sample prompt insertion works\n- [ ] PanelGrid displays with drag-and-drop reordering\n- [ ] @dnd-kit integration functional\n- [ ] useMangaGeneration hook orchestrates full workflow\n- [ ] SSE progress streaming displays correctly\n- [ ] ProgressBar updates in real-time\n- [ ] apiClient makes correct API calls\n- [ ] All components have TypeScript types\n- [ ] CreateMangaPage workflow complete\n- [ ] PreviewPage shows generated manga\n- [ ] ExportOptions functional (PNG/JPG/PDF)\n- [ ] Routing works (create  preview)\n- [ ] Error handling displays user-friendly messages\n- [ ] npm run dev starts without errors\n- [ ] No TypeScript compilation errors\n\n---\n\n## Integration Testing (After All Tasks Complete)\n\nAfter all 5 agents finish their implementations, run the following integration tests:\n\n```bash\n# 1. Start backend\ncd /mnt/Projects/koma-fill/backend\nnpm install\nnpm run dev\n# Expected: \" koma-fill server running on http://localhost:5000\"\n\n# 2. Start frontend (new terminal)\ncd /mnt/Projects/koma-fill/frontend\nnpm install\nnpm run dev\n# Expected: \"VITE  ready in XXX ms\"\n\n# 3. Complete workflow test\n# Open http://localhost:3000 in browser\n# - Create project\n# - Upload 2 reference images\n# - Enter story prompt\n# - Select layout (4 panels)\n# - Click \"Generate Manga\"\n# - Wait for completion\n# - View generated panels\n# - Export to PNG\n# - Verify PNG file created in uploads/\n\n# 4. Verify database\nsqlite3 /mnt/Projects/koma-fill/data/koma-fill.db\n> SELECT COUNT(*) FROM projects;\n> SELECT COUNT(*) FROM panels;\n> SELECT COUNT(*) FROM keyImages;\n\n# 5. Check file structure\nls -la /mnt/Projects/koma-fill/uploads/\nls -la /mnt/Projects/koma-fill/data/\n\n# 6. API health check\ncurl http://localhost:5000/api/health\n# Expected: {\"status\":\"ok\",\"timestamp\":\"...\"}\n```\n\n### Known Integration Points to Verify\n\n- Task 1  Task 2: Panel prompts saved in DB, readable by frontend\n- Task 2  Task 3: Vision analysis influences character consistency in prompts\n- Task 3  Task 4: Generated images saved to disk, paths in database\n- Task 4  Task 5: Layout images served via `/uploads/` static directory\n- Task 5  All: Frontend calls all backend API endpoints successfully\n\n---\n\n## Success Criteria Summary\n\nAll 5 tasks completed when:\n\n1. **Backend (Task 1)**: Express server with SQLite database, all CRUD routes working\n2. **Vision & Prompts (Task 2)**: OpenAI Vision API analyzes images, GPT-4o generates DALL-E prompts\n3. **Image Generation (Task 3)**: DALL-E 3 generates 4+ images with retry logic, SSE progress works\n4. **Layout & Export (Task 4)**: Sharp composes panels into manga layout, exports PNG/JPG/PDF\n5. **Frontend (Task 5)**: React UI allows workflow from story  generated manga  export\n\n**Total Expected Time**: 4-5 hours per agent (can run in parallel)\n**Minimum Test Time**: 30 minutes for integration testing\n\nGood luck, KAMUI agents! \n\n---\n\n*Last Updated: 2025-02-12*\n*For issues or questions, refer to the specific task prompts above*\n: \nID: task-1770909068675-7f6691\nBranch: task/task-1770909068675-7f6691\nWorktree: Users/yuyafujita/Projects/koma-fill/.worktrees/task-1770909068675-7f6691",
        "branchColor": "#e8a84f",
        "index": 25
      },
      {
        "type": "anchor",
        "label": "[] ClaudeCode1: # KAMUI-4D Parallel",
        "branch": "task/task-1770909068862-42049e",
        "worktreePath": "/Users/yuyafujita/Projects/koma-fill/.worktrees/task-1770909068862-42049e",
        "parentCommitHash": "1515fedca072442ad0656037229bce50b2e341f3",
        "lane": 11,
        "isMerged": false,
        "mergeCommitHash": null,
        "statusChildren": [],
        "isDefaultWorktree": false,
        "renderMode": "node",
        "shouldHide": false,
        "tagLabel": "task/task-1770909068862-42049e",
        "taskId": "task-1770909068862-42049e",
        "taskStatus": "working",
        "taskStatusLabel": "",
        "taskName": "ClaudeCode1: # KAMUI-4D Parallel Task Prompts for koma-fill\n## Manga Generation AI System - Multi-Agent Implementation Guide\n\n**Version:** 1.0\n**Project:** koma-fill - AI-powered manga panel generation system\n**Target:** KAMUI-4D Editor (Multi-AI CLI parallel execution)\n\n---\n\n## How to Use These Prompts in KAMUI-4D\n\nThis document contains **5 independent task prompts** designed to run in parallel across multiple AI coding agents. Each prompt is self-contained and can be executed independently without blocking other tasks.\n\n### Setup Instructions\n\n1. **Install dependencies** (run once before starting tasks):\n   ```bash\n   cd /mnt/Projects/koma-fill/backend\n   npm install\n\n   cd /mnt/Projects/koma-fill/frontend\n   npm install\n   ```\n\n2. **Environment Configuration**:\n   Create `/mnt/Projects/koma-fill/.env`:\n   ```\n   NODE_ENV=development\n   PORT=5000\n   BASE_URL=http://localhost:5000\n   OPENAI_API_KEY=your_openai_api_key_here\n   OPENAI_ORG_ID=your_org_id_optional\n   DATABASE_PATH=./data/koma-fill.db\n   STORAGE_PATH=./uploads\n   MAX_IMAGE_SIZE_MB=20\n   DALLE_RATE_LIMIT_PER_MINUTE=5\n   VISION_RATE_LIMIT_PER_MINUTE=30\n   MAX_RETRIES_PER_PANEL=3\n   ALLOWED_ORIGINS=http://localhost:3000\n   ```\n\n3. **Execution Strategy**:\n   - Copy each task prompt below into a separate KAMUI-4D session/agent\n   - **Tasks 1-5 can ALL start simultaneously** (no blocking dependencies)\n   - Each task should run independently in its own AI CLI session\n   - Monitor each agent's progress via console output\n   - **Integration testing** should happen after all 5 tasks complete (see bottom of doc)\n\n4. **Task Dependencies**:\n   ```\n   Task 1 (Backend)  provides database & API contracts\n   Task 2 (Vision)  uses Task 1's API, reads backend/src/models/types.ts\n   Task 3 (Images)  uses Task 1's API, reads backend/src/models/types.ts\n   Task 4 (Layout)  uses Task 1's API, reads backend/src/models/types.ts\n   Task 5 (Frontend)  calls Tasks 1-4 via REST API\n   ```\n   **All tasks can start immediately** - they communicate via file system and API contracts.\n\n---\n\n## Task 1: Backend (Agent A)\n### Express Server, SQLite Database & CRUD Routes Foundation\n\n**Time Estimate:** 45-60 minutes\n**Difficulty:** Intermediate\n**Dependencies:** None (this is the foundation layer)\n\n### Objective\nSet up a fully functional Express.js backend with SQLite database, implement CRUD operations for manga projects and panels, configure file upload handling with multer, and provide a solid API foundation for other agents to build upon.\n\n### Target Files to Create/Modify\n\n```\nbackend/\n src/\n    database/\n       connection.ts          [NEW] SQLite connection & initialization\n       schema.ts              [NEW] Table schema definitions\n    index.ts                   [MODIFY] Add DB initialization\n    app.ts                     [COMPLETE] Already done - verify middleware\n    routes/\n       manga.ts               [IMPLEMENT] Route handlers with DB calls\n    middleware/\n        errorHandler.ts        [VERIFY] Already complete\n uploads/                        [CREATE] Directory for image storage\n data/                           [CREATE] Directory for SQLite DB\n```\n\n### TypeScript Interfaces (from `/mnt/Projects/koma-fill/backend/src/models/types.ts`)\n\nKey types you'll use:\n```typescript\n// Core entities\nMangaProject {\n  id: string;                    // UUID\n  name: string;\n  description?: string;\n  status: ProjectStatus;         // 'draft' | 'analyzing' | 'generating' | 'complete' | 'exported'\n  layoutConfig: LayoutConfig;\n  generationSettings: GenerationSettings;\n  panels: Panel[];\n  keyImages: KeyImage[];\n  totalCost: number;\n  createdAt: string;             // ISO datetime\n  updatedAt: string;\n}\n\nPanel {\n  id: string;                    // UUID\n  projectId: string;\n  panelIndex: number;            // 0-based\n  imageUrl?: string;\n  imageFilePath?: string;\n  prompt?: string;\n  storyBeat?: string;\n  speechBubbleText?: string;\n  status: PanelStatus;           // 'pending' | 'generated' | 'failed' | 'placeholder'\n  retryCount: number;\n  generatedAt?: string;\n  createdAt: string;\n}\n\nKeyImage {\n  id: string;                    // UUID\n  projectId: string;\n  imageFilePath: string;\n  position: ImagePosition;       // 'start' | 'end' | number\n  analysis?: ImageAnalysis;\n  createdAt: string;\n}\n\nLayoutConfig {\n  totalPanels: number;           // 4, 6, 8, etc.\n  format: LayoutFormat;          // 'vertical' | 'horizontal' | 'square'\n  readingOrder: ReadingOrder;    // 'japanese' | 'western'\n  gutterSize: number;            // px\n  borderWidth: number;           // px\n  borderColor: string;           // hex #RRGGBB\n  backgroundColor: string;       // hex\n  pageWidth: number;             // px\n  pageHeight: number;            // px\n}\n\nGenerationSettings {\n  imageStyle: string;            // e.g., \"manga style, black and white ink\"\n  aspectRatio: 'square' | 'wide' | 'tall';\n  qualityLevel: 'standard' | 'hd';\n  negativePrompt?: string;\n  seed?: number;\n}\n```\n\n### Implementation Checklist\n\n#### 1. Create Database Connection Module (`backend/src/database/connection.ts`)\n```typescript\n// Requirements:\n- Initialize better-sqlite3 connection\n- Create/open database at DATABASE_PATH from .env\n- Export initDatabase() async function\n- Enable foreign keys constraint\n- Handle database file creation if needed\n- Connection should be cached/singleton\n```\n\n#### 2. Create Database Schema Module (`backend/src/database/schema.ts`)\n```typescript\n// SQL Schema Requirements:\nCREATE TABLE projects (\n  id TEXT PRIMARY KEY,\n  name TEXT NOT NULL,\n  description TEXT,\n  status TEXT NOT NULL,\n  layoutConfig JSON NOT NULL,\n  generationSettings JSON NOT NULL,\n  totalCost REAL DEFAULT 0,\n  createdAt TEXT NOT NULL,\n  updatedAt TEXT NOT NULL\n);\n\nCREATE TABLE panels (\n  id TEXT PRIMARY KEY,\n  projectId TEXT NOT NULL,\n  panelIndex INTEGER NOT NULL,\n  imageUrl TEXT,\n  imageFilePath TEXT,\n  prompt TEXT,\n  storyBeat TEXT,\n  speechBubbleText TEXT,\n  status TEXT NOT NULL,\n  retryCount INTEGER DEFAULT 0,\n  generatedAt TEXT,\n  createdAt TEXT NOT NULL,\n  FOREIGN KEY (projectId) REFERENCES projects(id)\n);\n\nCREATE TABLE keyImages (\n  id TEXT PRIMARY KEY,\n  projectId TEXT NOT NULL,\n  imageFilePath TEXT NOT NULL,\n  position TEXT NOT NULL,\n  analysis JSON,\n  createdAt TEXT NOT NULL,\n  FOREIGN KEY (projectId) REFERENCES projects(id)\n);\n\nCREATE INDEX idx_project_status ON projects(status);\nCREATE INDEX idx_panel_project ON panels(projectId);\nCREATE INDEX idx_panel_status ON panels(status);\n```\n\n#### 3. Modify `backend/src/index.ts`\n```typescript\n// Add:\n- Import { initDatabase } from './database/connection'\n- Call await initDatabase() before app.listen()\n- Log database initialization success\n```\n\n#### 4. Create Repository Layer (`backend/src/repositories/`)\n```typescript\n// Create:\n- ProjectRepository with methods:\n  - createProject(data: CreateMangaRequest): Promise<MangaProject>\n  - getProject(id: string): Promise<MangaProject | null>\n  - listProjects(limit: number, offset: number): Promise<MangaProject[]>\n  - updateProject(id: string, updates: Partial<MangaProject>): Promise<MangaProject>\n  - deleteProject(id: string): Promise<void>\n\n- PanelRepository with methods:\n  - createPanel(projectId: string, data: Panel): Promise<Panel>\n  - getPanelsByProject(projectId: string): Promise<Panel[]>\n  - getPanel(panelId: string): Promise<Panel | null>\n  - updatePanel(panelId: string, updates: Partial<Panel>): Promise<Panel>\n  - updatePanelStatus(panelId: string, status: PanelStatus): Promise<void>\n\n- KeyImageRepository with methods:\n  - createKeyImage(projectId: string, data: KeyImage): Promise<KeyImage>\n  - getKeyImages(projectId: string): Promise<KeyImage[]>\n  - updateKeyImageAnalysis(imageId: string, analysis: ImageAnalysis): Promise<void>\n```\n\n#### 5. Implement Routes in `backend/src/routes/manga.ts`\nReplace TODO comments with actual implementations:\n\n- **POST /api/manga/create**\n  - Validate CreateMangaRequest using Joi\n  - Generate unique project ID (uuid)\n  - Create project in database with 'draft' status\n  - Create initial panel records (count = layoutConfig.totalPanels)\n  - Return created MangaProject with 201 status\n\n- **POST /api/manga/:projectId/upload**\n  - Files already handled by multer middleware\n  - Save KeyImage records to database with file paths\n  - Store position information\n  - Return array of KeyImage objects\n\n- **GET /api/manga/:projectId**\n  - Fetch project + panels + key images from database\n  - Return complete MangaProject object\n  - Throw NotFoundError if project doesn't exist\n\n- **GET /api/manga**\n  - Implement pagination (limit/offset query params)\n  - Return array of projects\n  - Include total count header\n\n- **PUT /api/manga/:projectId/reorder**\n  - Parse ReorderPanelsRequest body\n  - Update panelIndex for each panel based on new order\n  - Return updated panels array\n\n### Testing Requirements\n\nAfter implementation, verify:\n\n```bash\n# 1. Database initialization\nnpm run dev\n# Check console: \" configured\" for database\n\n# 2. Create project\ncurl -X POST http://localhost:5000/api/manga/create \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\n    \"projectName\": \"Test Manga\",\n    \"storyPrompt\": \"A hero on a quest\",\n    \"layoutConfig\": { \"totalPanels\": 4 }\n  }'\n\n# 3. Get project\ncurl http://localhost:5000/api/manga/{projectId}\n\n# 4. Upload images\ncurl -X POST http://localhost:5000/api/manga/{projectId}/upload \\\n  -F \"images=@test1.jpg\" \\\n  -F \"images=@test2.jpg\"\n\n# 5. Check database\nsqlite3 data/koma-fill.db \"SELECT * FROM projects; SELECT * FROM panels;\"\n```\n\n### Files This Task Provides to Other Agents\n\n- **Database schema** - Tasks 2, 3, 4, 5 will read/write to these tables\n- **API contracts** - manga.ts route signatures that Tasks 2-4 will call\n- **File storage structure** - uploads/ directory path that Task 3 will use\n- **Type definitions** - already in backend/src/models/types.ts (reference only)\n\n### Output Validation Checklist\n\n- [ ] Database file created at `data/koma-fill.db`\n- [ ] All 3 tables created with correct schema\n- [ ] Repositories implement CRUD operations\n- [ ] All route handlers work without TODO comments\n- [ ] multer uploads save files to `uploads/` directory\n- [ ] POST /create returns 201 with MangaProject object\n- [ ] GET /:projectId returns full project with panels\n- [ ] Error handler catches and responds appropriately\n- [ ] No TypeScript compilation errors\n- [ ] npm run dev starts without errors\n\n---\n\n## Task 2: + (Agent B)\n### Vision API Integration & DALL-E Prompt Generation\n\n**Time Estimate:** 50-60 minutes\n**Difficulty:** Intermediate\n**Dependencies:** Task 1 (needs database & API routes available)\n\n### Objective\nImplement OpenAI Vision API integration to analyze uploaded key images and extract character/style information. Then implement story-to-panel prompt generation using GPT-4o to create DALL-E 3 compatible prompts that maintain consistency across panels.\n\n### Target Files to Create/Modify\n\n```\nbackend/\n src/\n     services/\n         imageAnalysisService.ts      [IMPLEMENT] Vision API analysis\n         promptGenerationService.ts   [CREATE] Story  panel prompts\n```\n\n### System Prompts (Already Provided)\n\nBoth vision analysis prompts are defined in `imageAnalysisService.ts`:\n- `QUICK_ANALYSIS_PROMPT` - fast, ~500 tokens\n- `DETAILED_ANALYSIS_PROMPT` - thorough, ~2000 tokens\n\nThese guide the Vision API to return structured JSON matching the `ImageAnalysis` interface.\n\n### TypeScript Interfaces\n\n```typescript\n// Input: Key image file path (from Task 1)\n// Output: ImageAnalysis object\n\nImageAnalysis {\n  description: string;\n  characters: CharacterInfo[];\n  objects: string[];\n  colors: string[];\n  composition: string;\n  mood: string;\n  artStyle: string;\n  suggestedTransitions: string[];\n}\n\nCharacterInfo {\n  name?: string;\n  appearance: string;        // detailed physical description\n  emotion: string;\n  position: string;          // screen position (e.g., \"center-left\")\n}\n\n// Panel prompt generation\nPanelPrompt {\n  panelIndex: number;\n  dallePrompt: string;       // Full DALL-E 3 prompt (100-300 words)\n  storyBeat: string;         // What happens in this panel\n  visualFocus: string;       // Main visual element\n  transitionType: TransitionType;  // 'cut' | 'pan' | 'zoom_in' | 'zoom_out' | 'fade' | 'action'\n  suggestedDialogue?: string;\n}\n```\n\n### Implementation Details\n\n#### ImageAnalysisService (`backend/src/services/imageAnalysisService.ts`)\n\n**Constructor:**\n```typescript\nconstructor() {\n  this.openai = new OpenAI({\n    apiKey: CONFIG.OPENAI_API_KEY,\n    organization: CONFIG.OPENAI_ORG_ID\n  });\n}\n```\n\n**Method: analyzeImage(imageBase64: string, depth: 'quick' | 'detailed')**\n- Input: Base64-encoded image data from KeyImage file\n- Implementation:\n  1. Read image file and convert to Base64 (if not already)\n  2. Call `this.openai.chat.completions.create()`:\n     - model: CONFIG.VISION_MODEL ('gpt-4o')\n     - messages: [\n       { role: 'system', content: QUICK_ANALYSIS_PROMPT or DETAILED_ANALYSIS_PROMPT }\n       { role: 'user', content: [\n         { type: 'image_url', image_url: { url: `data:image/png;base64,${imageBase64}` } }\n       ]}\n     ]\n     - response_format: { type: 'json_object' }\n     - max_tokens: depth === 'quick' ? 500 : 2000\n  3. Parse response.choices[0].message.content as JSON\n  4. Validate against ImageAnalysis schema\n  5. Return ImageAnalysis object\n\n**Method: analyzeMultiple(images, depth)**\n- Input: Array of { base64, position } objects\n- Use Promise.all with rate limiting (max CONFIG.VISION_RATE_LIMIT_PER_MINUTE calls/min)\n- Implement backoff if rate limited\n- Return array of ImageAnalysis objects\n\n**Method: extractCharacters(analysis)**\n- Optional: Deep-dive character extraction\n- Can call another Vision API pass if needed for more detail\n\n#### PromptGenerationService (NEW FILE - `backend/src/services/promptGenerationService.ts`)\n\n**Constructor:**\n```typescript\nconstructor() {\n  this.openai = new OpenAI({ apiKey: CONFIG.OPENAI_API_KEY });\n}\n```\n\n**Method: generatePanelPrompts(request: GeneratePromptsRequest)**\n\nInput:\n```typescript\nGeneratePromptsRequest {\n  storyPrompt: string;           // User's story\n  panelCount: number;            // Total panels to generate\n  characterConsistency: boolean; // Whether to maintain character consistency\n}\n```\n\nImplementation:\n1. **Story Breakdown Phase:**\n   - Call GPT-4o to split story into N panel beats\n   - System prompt should guide structure like:\n   ```\n   \"You are a manga story expert. Break the provided story into exactly {panelCount}\n    distinct visual beats. Each beat should be 1-2 sentences describing what happens\n    visually in that panel. Format as JSON array of objects with 'panelIndex' and 'beat' fields.\"\n   ```\n\n2. **Character Consistency Analysis:**\n   - If characterConsistency=true and keyImages were analyzed:\n     - Retrieve stored ImageAnalysis for key images\n     - Create character consistency profile (appearance, emotion arcs, etc.)\n     - Include in subsequent prompts\n\n3. **DALL-E 3 Prompt Generation:**\n   - For each story beat, create detailed DALL-E 3 prompt\n   - System prompt pattern:\n   ```\n   \"You are a DALL-E 3 prompt expert specializing in manga panels.\n    Given a story beat, generate a detailed visual prompt (100-300 words) that:\n    - Specifies art style: {generationSettings.imageStyle}\n    - Maintains character consistency: {characterProfile}\n    - Follows manga composition principles\n    - Uses specific visual terms (angle, lighting, pose, emotion)\n    - Avoids abstract concepts; be concrete and visual\n    - Follows DALL-E 3 content policy\n\n    Return JSON with: { dallePrompt, visualFocus, transitionType, suggestedDialogue }\"\n   ```\n\n4. **Transition Logic:**\n   - Analyze flow between consecutive beats\n   - Suggest transition type ('cut', 'pan', 'zoom_in', etc.)\n   - Update imageUrl in previous panel to support transitions\n\n5. **Return Value:**\n   - Array of PanelPrompt objects, one per panel\n   - Each with populated dallePrompt, storyBeat, visualFocus, transitionType\n\n### Database Integration\n\nAfter generating prompts, save to Panel table:\n- Update each panel's `prompt` field with `dallePrompt`\n- Update `storyBeat` field\n- Update `status` to 'pending' (ready for image generation)\n\n### API Integration\n\nImplement route handlers in `backend/src/routes/manga.ts`:\n\n**POST /api/manga/:projectId/analyze**\n```typescript\n// 1. Fetch project and keyImages from DB\n// 2. Read image files and convert to Base64\n// 3. Call imageAnalysisService.analyzeMultiple()\n// 4. Store analysis results in DB (keyImages.analysis)\n// 5. Update project status to 'analyzing'  'complete'\n// 6. Return analysis results\n```\n\n**POST /api/manga/:projectId/generate-prompts**\n```typescript\n// 1. Validate GeneratePromptsRequest\n// 2. Fetch project and keyImages analyses from DB\n// 3. Call promptGenerationService.generatePanelPrompts()\n// 4. Update panel records with generated prompts\n// 5. Update project status to 'generating'\n// 6. Return array of PanelPrompt objects\n```\n\n### Testing Requirements\n\n```bash\n# 1. Prepare test image\n# (Use any PNG/JPG with a character or scene)\n\n# 2. Create project and upload image (Task 1)\nPROJECT_ID=$(curl -s -X POST http://localhost:5000/api/manga/create \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"projectName\":\"Test\",\"storyPrompt\":\"A hero finds treasure\"}' | jq -r '.id')\n\n# 3. Upload test image\ncurl -X POST http://localhost:5000/api/manga/$PROJECT_ID/upload \\\n  -F \"images=@test_image.jpg\"\n\n# 4. Analyze images\ncurl -X POST http://localhost:5000/api/manga/$PROJECT_ID/analyze \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"analysisDepth\":\"quick\"}'\n\n# 5. Generate prompts\ncurl -X POST http://localhost:5000/api/manga/$PROJECT_ID/generate-prompts \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\n    \"storyPrompt\": \"A hero finds treasure in a dark cave\",\n    \"panelCount\": 4,\n    \"characterConsistency\": true\n  }'\n\n# 6. Verify output\ncurl http://localhost:5000/api/manga/$PROJECT_ID | jq '.panels[].prompt'\n```\n\n### Files This Task Provides to Other Agents\n\n- **Panel prompt data** - Stored in DB panels table, used by Task 3 for image generation\n- **Character analysis** - Used by Task 5 frontend for display\n- **Art style consistency** - Guides Task 3's image generation\n\n### Output Validation Checklist\n\n- [ ] ImageAnalysisService.analyzeImage() calls Vision API successfully\n- [ ] Vision API responses parse correctly to ImageAnalysis\n- [ ] PromptGenerationService generates DALL-E-compatible prompts\n- [ ] Panel prompts maintain character consistency (if enabled)\n- [ ] Transition types are correctly assigned\n- [ ] All panel records updated in database with prompts\n- [ ] /analyze endpoint returns ImageAnalysis array\n- [ ] /generate-prompts endpoint returns PanelPrompt array\n- [ ] Error handling for API failures (rate limits, auth, etc.)\n- [ ] No TypeScript compilation errors\n\n---\n\n## Task 3: DALL-E 3 (Agent C)\n### Image Generation with Retry Logic & Progress Streaming\n\n**Time Estimate:** 50-70 minutes\n**Difficulty:** Intermediate-Advanced\n**Dependencies:** Task 1 (DB & API), Task 2 (panel prompts)\n\n### Objective\nImplement DALL-E 3 image generation with robust error handling, exponential backoff retry logic, local image storage, Server-Sent Events (SSE) streaming for real-time progress updates, and cost tracking per API call.\n\n### Target Files to Create/Modify\n\n```\nbackend/\n src/\n     services/\n         imageGenerationService.ts    [IMPLEMENT] DALL-E 3 API integration\n         (imageProcessor.ts)          [REFERENCE] Utility for image processing\n```\n\n### TypeScript Interfaces\n\n```typescript\nGeneratedPanel {\n  panelIndex: number;\n  imageUrl: string;              // DALL-E public URL (temporary)\n  localFilePath: string;         // /uploads/{projectId}/panel_{index}.png\n  prompt: string;                // Original prompt sent\n  revisedPrompt?: string;        // DALL-E 3's revised prompt (if modified)\n  costUsd: number;               // API call cost\n}\n\n// Request type\nGenerateImagesRequest {\n  panelIndices?: number[];       // undefined = all panels\n  batchMode: 'sequential' | 'parallel';\n}\n\n// Progress event (sent via SSE)\nProgressEvent {\n  type: 'progress' | 'complete' | 'error';\n  stage: string;                 // 'generating_images'\n  currentStep: number;           // Current panel index\n  totalSteps: number;            // Total panels\n  percentage: number;            // 0-100\n  message: string;               // Human-readable status\n  panelId?: string;\n  panelIndex?: number;\n  error?: string;                // Error message if type='error'\n}\n```\n\n### Implementation Details\n\n#### ImageGenerationService (`backend/src/services/imageGenerationService.ts`)\n\n**Constructor & Initialization:**\n```typescript\nconstructor() {\n  this.openai = new OpenAI({ apiKey: CONFIG.OPENAI_API_KEY });\n  this.uploadDir = path.resolve(CONFIG.STORAGE_PATH);\n}\n```\n\n**Method: generatePanel() - Single Panel Generation**\n\n```typescript\nasync generatePanel(\n  prompt: string,\n  panelIndex: number,\n  projectId: string,\n  settings?: GenerationSettings\n): Promise<GeneratedPanel>\n```\n\nImplementation:\n1. **Image Size Calculation:**\n   - Map aspectRatio to DALL-E 3 size:\n     - 'square'  '1024x1024'\n     - 'wide'  '1792x1024'\n     - 'tall'  '1024x1792'\n\n2. **API Call (with retry logic in wrapper):**\n   ```typescript\n   const response = await this.openai.images.generate({\n     model: CONFIG.DALLE_MODEL,           // 'dall-e-3'\n     prompt: prompt,\n     n: 1,\n     size: size,\n     quality: settings?.qualityLevel === 'hd' ? 'hd' : 'standard',\n     style: 'natural',                    // or 'vivid' for more dramatic\n   });\n   ```\n\n3. **Extract Response Data:**\n   - imageUrl = response.data[0].url\n   - revisedPrompt = response.data[0].revised_prompt\n   - Calculate cost based on settings.qualityLevel:\n     - standard: $0.040 per image\n     - hd: $0.080 per image\n\n4. **Download & Save Image:**\n   - Call this.downloadAndSave(imageUrl, projectId, panelIndex)\n   - Saves as PNG: `{STORAGE_PATH}/{projectId}/panel_{panelIndex}.png`\n   - Returns localFilePath\n\n5. **Return GeneratedPanel object**\n\n**Method: generateBatch() - Batch Generation with Mode Selection**\n\n```typescript\nasync generateBatch(\n  panelPrompts: PanelPrompt[],\n  projectId: string,\n  batchMode: 'sequential' | 'parallel',\n  settings?: GenerationSettings,\n  onProgress?: (event: ProgressEvent) => void\n): Promise<GeneratedPanel[]>\n```\n\nImplementation:\n1. Validate inputs\n2. Route to sequential or parallel handler\n3. Call onProgress callback with progress events\n4. Return array of GeneratedPanel\n\n**Method: generateSequential() - Rate-Limit Friendly**\n\n```typescript\nprivate async generateSequential(\n  panelPrompts: PanelPrompt[],\n  projectId: string,\n  settings?: GenerationSettings,\n  onProgress?: (event: ProgressEvent) => void\n): Promise<GeneratedPanel[]>\n```\n\nImplementation:\n1. Initialize results array\n2. For each panelPrompt (with index):\n   a. Call generatePanelWithRetry(panelPrompt, projectId, settings)\n   b. On success:\n      - Add to results array\n      - Call onProgress with percentage = (index + 1) / total * 100\n   c. On failure (after max retries):\n      - Update panel status to 'failed' in DB\n      - Log error\n      - Continue to next panel\n\n3. Return results array (may include failed panels with status='failed')\n\n**Method: generateParallel() - High Speed (Rate Limit Aware)**\n\n```typescript\nprivate async generateParallel(\n  panelPrompts: PanelPrompt[],\n  projectId: string,\n  settings?: GenerationSettings,\n  onProgress?: (event: ProgressEvent) => void\n): Promise<GeneratedPanel[]>\n```\n\nImplementation:\n1. **Batch Control:**\n   - Max concurrent = Math.floor(CONFIG.DALLE_RATE_LIMIT_PER_MINUTE / 2)\n   - Split panelPrompts into batches of max concurrent\n\n2. **For each batch:**\n   - Create Promise.allSettled() for batch\n   - Wait for all to settle\n   - Process results\n   - Send progress update to onProgress\n   - Delay before next batch (respect rate limits)\n\n3. **Failure Handling:**\n   - Collect failed panels\n   - Retry failed panels sequentially (exponential backoff)\n   - Update onProgress for retries\n\n4. **Return results array**\n\n**Method: generatePanelWithRetry() - Core Retry Logic**\n\n```typescript\nprivate async generatePanelWithRetry(\n  panelPrompt: PanelPrompt,\n  projectId: string,\n  settings?: GenerationSettings,\n  retryCount: number = 0\n): Promise<GeneratedPanel>\n```\n\nImplementation:\n1. Try to generate panel via generatePanel()\n2. On success: Return GeneratedPanel\n3. On failure:\n   - If retryCount < CONFIG.MAX_RETRIES_PER_PANEL:\n     - Calculate backoff delay: 2^retryCount * 1000ms (exponential)\n     - Wait for delay\n     - Recursively call with retryCount++\n   - If max retries exceeded:\n     - Throw error with panel index info\n\n**Exponential Backoff Formula:**\n```\ndelay(attempt) = base_delay * (2 ^ attempt) + random jitter\ndelay(0) = 1000ms (1 second)\ndelay(1) = 2000ms (2 seconds)\ndelay(2) = 4000ms (4 seconds)\n+ add random(0, 500ms) jitter to avoid thundering herd\n```\n\n**Method: downloadAndSave() - Store Images Locally**\n\n```typescript\nprivate async downloadAndSave(\n  imageUrl: string,\n  projectId: string,\n  panelIndex: number\n): Promise<string>\n```\n\nImplementation:\n1. Create project uploads directory if not exists: `{STORAGE_PATH}/{projectId}/`\n2. Fetch image from URL using axios or native fetch:\n   ```typescript\n   const response = await fetch(imageUrl);\n   const arrayBuffer = await response.arrayBuffer();\n   const buffer = Buffer.from(arrayBuffer);\n   ```\n3. Save to disk:\n   ```typescript\n   const filePath = path.join(this.uploadDir, projectId, `panel_${panelIndex}.png`);\n   await fs.writeFile(filePath, buffer);\n   ```\n4. Return relative or absolute path\n\n**Method: getImageSize() - Aspect Ratio to DALL-E Size**\n\n```typescript\nprivate getImageSize(\n  aspectRatio: string\n): '1024x1024' | '1792x1024' | '1024x1792'\n```\n\nSelf-explanatory mapping function.\n\n### Route Handler Integration\n\nImplement in `backend/src/routes/manga.ts`:\n\n**POST /api/manga/:projectId/generate-images - SSE Streaming**\n\n```typescript\nrouter.post('/:projectId/generate-images', async (req, res, next) => {\n  try {\n    const { projectId } = req.params;\n    const { panelIndices, batchMode } = req.body as GenerateImagesRequest;\n\n    // Set up SSE response\n    res.setHeader('Content-Type', 'text/event-stream');\n    res.setHeader('Cache-Control', 'no-cache');\n    res.setHeader('Connection', 'keep-alive');\n\n    // Fetch project and panels from DB\n    const project = await getProject(projectId);\n    if (!project) throw new NotFoundError('Project');\n\n    // Filter panels (all or specific indices)\n    const panelsToGenerate = project.panels.filter(\n      p => !panelIndices || panelIndices.includes(p.panelIndex)\n    );\n\n    // Generate prompts array\n    const panelPrompts: PanelPrompt[] = panelsToGenerate.map(p => ({\n      panelIndex: p.panelIndex,\n      dallePrompt: p.prompt!,\n      storyBeat: p.storyBeat!,\n      visualFocus: 'main subject',  // Extract from context if available\n      transitionType: 'cut',        // Default, could be from DB\n    }));\n\n    // Call imageGenerationService\n    imageGenService.generateBatch(\n      panelPrompts,\n      projectId,\n      batchMode,\n      project.generationSettings,\n      (progressEvent) => {\n        // Send progress as SSE\n        res.write(`data: ${JSON.stringify(progressEvent)}\\n\\n`);\n      }\n    ).then(generatedPanels => {\n      // Update database with generated images\n      for (const panel of generatedPanels) {\n        updatePanelImage(panel.panelIndex, {\n          imageUrl: panel.imageUrl,\n          imageFilePath: panel.localFilePath,\n          revisedPrompt: panel.revisedPrompt,\n          status: panel.revisedPrompt ? 'generated' : 'generated',\n        });\n      }\n\n      // Send completion event\n      res.write(`data: ${JSON.stringify({\n        type: 'complete',\n        message: 'Image generation complete',\n        totalCost: generatedPanels.reduce((sum, p) => sum + p.costUsd, 0),\n      })}\\n\\n`);\n\n      res.end();\n    }).catch(err => {\n      res.write(`data: ${JSON.stringify({\n        type: 'error',\n        message: err.message,\n      })}\\n\\n`);\n      res.end();\n    });\n  } catch (err) {\n    next(err);\n  }\n});\n```\n\n### Cost Tracking\n\n**Implementation:**\n- Track cost per API call in GeneratedPanel.costUsd\n- Sum across all panels: `totalCost = sum(generatedPanels.map(p => p.costUsd))`\n- Update project.totalCost in DB: `project.totalCost += generatedPanels totalCost`\n- Log costs for each call (useful for budget monitoring)\n\n**Cost Constants (from types.ts):**\n```typescript\nAPI_COSTS = {\n  VISION_PER_CALL: 0.025,    // GPT-4V\n  DALLE3_STANDARD: 0.040,    // per image\n  DALLE3_HD: 0.080,          // per image\n}\n```\n\n### Testing Requirements\n\n```bash\n# 1. Set up test project (with prompts from Task 2)\nPROJECT_ID=\"test-project-id\"\n# Or use output from Task 2 test\n\n# 2. Generate images (sequential mode)\ncurl -X POST http://localhost:5000/api/manga/$PROJECT_ID/generate-images \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"batchMode\": \"sequential\"}' \\\n  -H \"Accept: text/event-stream\"\n\n# 3. Verify local image files created\nls -la uploads/$PROJECT_ID/\n\n# 4. Check database for updated image URLs\nsqlite3 data/koma-fill.db \"SELECT panelIndex, imageFilePath, status FROM panels WHERE projectId='$PROJECT_ID';\"\n\n# 5. Verify cost tracking\ncurl http://localhost:5000/api/manga/$PROJECT_ID | jq '.totalCost'\n```\n\n### Files This Task Provides to Other Agents\n\n- **Generated panel images** - Stored in uploads/{projectId}/, used by Task 4\n- **Image file paths** - Updated in DB, used by Task 4 for layout composition\n- **Cost tracking** - Used by frontend for budget display\n\n### Output Validation Checklist\n\n- [ ] DALL-E 3 API calls succeed with valid prompts\n- [ ] Retry logic works with exponential backoff\n- [ ] Images download and save to {STORAGE_PATH}/{projectId}/\n- [ ] SSE streaming sends progress events correctly\n- [ ] onProgress callback fires with accurate percentage\n- [ ] Cost calculation correct (0.04 standard, 0.08 HD)\n- [ ] Panel records updated with imageUrl and imageFilePath\n- [ ] Sequential and parallel modes both work\n- [ ] Rate limiting respected (max 5 calls/min by default)\n- [ ] Error handling for network issues, API failures\n- [ ] No TypeScript compilation errors\n\n---\n\n## Task 4: + (Agent D)\n### Manga Layout Composition & Multi-Format Export\n\n**Time Estimate:** 45-60 minutes\n**Difficulty:** Intermediate (Sharp library learning curve)\n**Dependencies:** Task 1 (DB), Task 3 (generated images)\n\n### Objective\nImplement Sharp-based manga layout composition with grid calculation, panel resizing and positioning, border/gutter rendering, speech bubble overlay, and PNG/JPG/PDF export functionality.\n\n### Target Files to Create/Modify\n\n```\nbackend/\n src/\n     services/\n        layoutEngine.ts          [IMPLEMENT] Panel composition & layout\n        exportService.ts         [CREATE] PNG/JPG/PDF export\n     utils/\n         imageProcessor.ts        [HELPER] Image processing utilities\n```\n\n### TypeScript Interfaces\n\n```typescript\n// Layout composition result\nComposedLayout {\n  buffer: Buffer;                    // PNG image buffer\n  width: number;                     // Page width (px)\n  height: number;                    // Page height (px)\n  format: 'png';\n  panelPositions: PanelPosition[];   // Position data for each panel\n}\n\nPanelPosition {\n  panelIndex: number;\n  x: number;                         // Offset from top-left (px)\n  y: number;\n  width: number;                     // Panel width (px)\n  height: number;                    // Panel height (px)\n}\n\n// Input to layout engine\nLayoutConfig {\n  totalPanels: number;               // 4, 6, 8, etc.\n  format: LayoutFormat;              // 'vertical' | 'horizontal' | 'square'\n  readingOrder: ReadingOrder;        // 'japanese' | 'western'\n  gutterSize: number;                // Space between panels (px)\n  borderWidth: number;               // Panel border thickness (px)\n  borderColor: string;               // Hex color\n  backgroundColor: string;           // Hex color\n  pageWidth: number;                 // Canvas width (px)\n  pageHeight: number;                // Canvas height (px)\n}\n```\n\n### Implementation Details\n\n#### LayoutEngine (`backend/src/services/layoutEngine.ts`)\n\n**Method: composePanels() - Main Composition Function**\n\n```typescript\nasync composePanels(\n  panelImagePaths: string[],\n  config: LayoutConfig = DEFAULT_LAYOUT_CONFIG\n): Promise<ComposedLayout>\n```\n\nImplementation Steps:\n\n1. **Calculate Grid:**\n   ```typescript\n   const grid = this.calculateGrid(panelImagePaths.length, config);\n   // Returns { cols: number, rows: number }\n   ```\n   Already implemented - use it.\n\n2. **Calculate Panel Positions:**\n   ```typescript\n   const positions = this.calculatePanelPositions(grid, config);\n   // Returns: PanelPosition[] with x, y, width, height for each panel\n   ```\n   Already implemented - use it.\n\n3. **Create Background Canvas:**\n   ```typescript\n   import sharp from 'sharp';\n\n   let canvas = sharp({\n     create: {\n       width: config.pageWidth,\n       height: config.pageHeight,\n       channels: 4,                    // RGBA\n       background: config.backgroundColor,  // Parsed from hex\n     }\n   });\n   ```\n\n4. **Load & Resize Panel Images:**\n   ```typescript\n   const composites = await Promise.all(\n     panelImagePaths.map(async (imgPath, i) => {\n       if (!fs.existsSync(imgPath)) {\n         throw new Error(`Panel image not found: ${imgPath}`);\n       }\n\n       const position = positions[i];\n       const resized = await sharp(imgPath)\n         .resize(position.width, position.height, {\n           fit: 'cover',              // Fill panel, crop if needed\n           withoutEnlargement: false\n         })\n         .toBuffer();\n\n       return {\n         input: resized,\n         left: position.x,\n         top: position.y\n       };\n     })\n   );\n   ```\n\n5. **Composite Panels Onto Canvas:**\n   ```typescript\n   let result = await canvas.composite(composites).png();\n   ```\n\n6. **Add Borders (Optional - if borderWidth > 0):**\n   - Use SVG overlay to draw rectangles around each panel\n   - Create SVG:\n     ```svg\n     <svg width=\"800\" height=\"1200\">\n       <!-- For each panel position -->\n       <rect x=\"10\" y=\"10\" width=\"390\" height=\"590\"\n             fill=\"none\" stroke=\"black\" stroke-width=\"2\" />\n     </svg>\n     ```\n   - Composite SVG overlay:\n     ```typescript\n     const borderSvg = this.generateBorderSvg(positions, config);\n     result = await result.composite([{\n       input: borderSvg,\n       top: 0,\n       left: 0\n     }]);\n     ```\n\n7. **Return ComposedLayout:**\n   ```typescript\n   const buffer = await result.toBuffer();\n   return {\n     buffer,\n     width: config.pageWidth,\n     height: config.pageHeight,\n     format: 'png',\n     panelPositions: positions\n   };\n   ```\n\n**Method: addSpeechBubbles() - Overlay Speech Bubbles**\n\n```typescript\nasync addSpeechBubbles(\n  layout: ComposedLayout,\n  bubbles: SpeechBubble[]\n): Promise<ComposedLayout>\n```\n\nImplementation:\n\n1. **For each speech bubble:**\n   - Get panel position from layout.panelPositions[bubble.panelIndex]\n   - Calculate bubble position within panel:\n     - 'top'  y = panel.y + 30\n     - 'middle'  y = panel.y + panel.height/2 - 30\n     - 'bottom'  y = panel.y + panel.height - 60\n\n2. **Create SVG speech bubble:**\n   ```typescript\n   const svg = this.generateSpeechBubbleSvg(bubble, position, style);\n   // Generates SVG with text, shape varies by style:\n   // 'rounded', 'cloud', 'spiked', 'rectangular'\n   ```\n\n3. **Composite all bubble SVGs:**\n   ```typescript\n   let result = sharp(layout.buffer);\n   const bubbleSvgs = bubbles.map((bubble, idx) =>\n     this.generateSpeechBubbleSvg(bubble, panelPositions[bubble.panelIndex])\n   );\n\n   result = await result.composite(\n     bubbleSvgs.map((svg, i) => ({ input: svg }))\n   );\n   ```\n\n4. **Return updated ComposedLayout**\n\n**Helper: generateBorderSvg()**\n```typescript\nprivate generateBorderSvg(\n  positions: PanelPosition[],\n  config: LayoutConfig\n): Buffer\n```\n\nGenerate SVG with rectangle borders around each panel:\n```svg\n<svg width=\"800\" height=\"1200\">\n  <rect x=\"10\" y=\"10\" width=\"390\" height=\"590\"\n        fill=\"none\" stroke=\"#000000\" stroke-width=\"2\" />\n  <!-- repeated for each panel -->\n</svg>\n```\n\nConvert to Buffer and return.\n\n**Helper: generateSpeechBubbleSvg()**\n```typescript\nprivate generateSpeechBubbleSvg(\n  bubble: SpeechBubble,\n  panelPosition: PanelPosition,\n  targetY: number  // top/middle/bottom\n): Buffer\n```\n\nGenerate SVG with speech bubble shape. Example for 'rounded':\n```svg\n<svg width=\"300\" height=\"100\">\n  <!-- Rounded rectangle -->\n  <path d=\"M 10,10 Q 10,10 20,10 L 270,10 Q 280,10 280,20 L 280,70 Q 280,80 270,80 L 30,80 Q 20,80 20,70 L 20,40 L 0,60 L 20,50 L 20,20 Q 20,10 10,10\"\n        fill=\"white\" stroke=\"black\" stroke-width=\"1\" />\n  <text x=\"20\" y=\"50\" font-family=\"Arial\" font-size=\"14\">Your text here</text>\n</svg>\n```\n\nReturn SVG as Buffer via:\n```typescript\nconst svgBuffer = Buffer.from(svgString, 'utf-8');\n```\n\n### ExportService (`backend/src/services/exportService.ts`) - NEW FILE\n\nImplement export to PNG, JPG, PDF formats.\n\n```typescript\nexport class ExportService {\n  async exportPNG(\n    layout: ComposedLayout,\n    filepath: string,\n    compression: 'low' | 'medium' | 'high'\n  ): Promise<void>\n\n  async exportJPG(\n    layout: ComposedLayout,\n    filepath: string,\n    quality: number  // 60-95\n  ): Promise<void>\n\n  async exportPDF(\n    layout: ComposedLayout,\n    filepath: string,\n    metadata: { title?: string; author?: string }\n  ): Promise<void>\n}\n```\n\n**exportPNG():**\n```typescript\nasync exportPNG(layout, filepath, compression) {\n  const compressionLevel = compression === 'high' ? 9 : compression === 'medium' ? 6 : 1;\n  await sharp(layout.buffer)\n    .png({ compressionLevel })\n    .toFile(filepath);\n}\n```\n\n**exportJPG():**\n```typescript\nasync exportJPG(layout, filepath, quality = 80) {\n  await sharp(layout.buffer)\n    .jpeg({ quality, mozjpeg: true })\n    .toFile(filepath);\n}\n```\n\n**exportPDF():**\nRequires pdfkit library:\n```typescript\nimport PDFDocument from 'pdfkit';\nimport { createWriteStream } from 'fs';\n\nasync exportPDF(layout, filepath, metadata = {}) {\n  const doc = new PDFDocument({\n    size: [layout.width, layout.height]\n  });\n\n  if (metadata.title) doc.title(metadata.title);\n  if (metadata.author) doc.author(metadata.author);\n\n  // Add image to PDF\n  doc.image(layout.buffer, 0, 0, {\n    width: layout.width,\n    height: layout.height\n  });\n\n  doc.pipe(createWriteStream(filepath));\n  doc.end();\n}\n```\n\n### Route Handler Integration\n\nImplement in `backend/src/routes/manga.ts`:\n\n**POST /api/manga/:projectId/layout**\n```typescript\nrouter.post('/:projectId/layout', async (req: Request, res: Response, next: NextFunction) => {\n  try {\n    const { projectId } = req.params;\n    const { speechBubbles } = req.body as GenerateLayoutRequest;\n\n    // Fetch project and panels from DB\n    const project = await getProject(projectId);\n    if (!project) throw new NotFoundError('Project');\n\n    // Get panel image paths\n    const panelPaths = project.panels\n      .sort((a, b) => a.panelIndex - b.panelIndex)\n      .map(p => p.imageFilePath)\n      .filter(path => path !== undefined);\n\n    // Compose layout\n    const layoutEngine = new LayoutEngine();\n    let layout = await layoutEngine.composePanels(panelPaths, project.layoutConfig);\n\n    // Add speech bubbles if provided\n    if (speechBubbles && speechBubbles.length > 0) {\n      layout = await layoutEngine.addSpeechBubbles(layout, speechBubbles);\n    }\n\n    // Save layout buffer to temporary file for preview\n    const layoutPath = path.join(CONFIG.STORAGE_PATH, projectId, 'layout.png');\n    await fs.writeFile(layoutPath, layout.buffer);\n\n    // Update project status\n    await updateProject(projectId, { status: 'complete' });\n\n    // Return layout info\n    res.json({\n      message: 'Layout composed successfully',\n      projectId,\n      layoutPath: `/uploads/${projectId}/layout.png`,\n      panelPositions: layout.panelPositions,\n      dimensions: { width: layout.width, height: layout.height }\n    });\n  } catch (err) {\n    next(err);\n  }\n});\n```\n\n**POST /api/manga/:projectId/export**\n```typescript\nrouter.post('/:projectId/export', async (req: Request, res: Response, next: NextFunction) => {\n  try {\n    const { projectId } = req.params;\n    const { format, compression, resolution, title, author } = req.body as ExportRequest;\n\n    // Fetch project layout\n    const layoutPath = path.join(CONFIG.STORAGE_PATH, projectId, 'layout.png');\n    if (!fs.existsSync(layoutPath)) {\n      throw new Error('Layout not yet generated. Call /layout endpoint first.');\n    }\n\n    const layoutBuffer = await fs.promises.readFile(layoutPath);\n    const layout: ComposedLayout = {\n      buffer: layoutBuffer,\n      width: 800,  // From project.layoutConfig\n      height: 1200,\n      format: 'png',\n      panelPositions: []  // Could fetch from DB if needed\n    };\n\n    // Export to requested format\n    const exportService = new ExportService();\n    const timestamp = Date.now();\n    const exportPath = path.join(CONFIG.STORAGE_PATH, projectId, `manga_${timestamp}.${format}`);\n\n    if (format === 'png') {\n      await exportService.exportPNG(layout, exportPath, compression as 'low' | 'medium' | 'high');\n    } else if (format === 'jpg') {\n      const qualityMap = { low: 60, medium: 80, high: 95 };\n      await exportService.exportJPG(layout, exportPath, qualityMap[compression]);\n    } else if (format === 'pdf') {\n      await exportService.exportPDF(layout, exportPath, { title, author });\n    }\n\n    // Update project status\n    await updateProject(projectId, { status: 'exported' });\n\n    res.json({\n      message: 'Export successful',\n      projectId,\n      format,\n      downloadUrl: `/uploads/${projectId}/manga_${timestamp}.${format}`,\n      filePath: exportPath\n    });\n  } catch (err) {\n    next(err);\n  }\n});\n```\n\n### Testing Requirements\n\n```bash\n# 1. Generate layout from Task 3 images\nPROJECT_ID=\"test-project-id\"\ncurl -X POST http://localhost:5000/api/manga/$PROJECT_ID/layout \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\n    \"speechBubbles\": [\n      {\n        \"panelIndex\": 0,\n        \"text\": \"Wow!\",\n        \"position\": \"top\",\n        \"style\": \"rounded\"\n      }\n    ]\n  }'\n\n# 2. View composed layout\nopen http://localhost:5000/uploads/$PROJECT_ID/layout.png\n\n# 3. Export to PNG\ncurl -X POST http://localhost:5000/api/manga/$PROJECT_ID/export \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\n    \"format\": \"png\",\n    \"compression\": \"medium\",\n    \"resolution\": \"web\",\n    \"title\": \"My Manga\"\n  }'\n\n# 4. Export to PDF\ncurl -X POST http://localhost:5000/api/manga/$PROJECT_ID/export \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\n    \"format\": \"pdf\",\n    \"compression\": \"medium\",\n    \"title\": \"My Manga\",\n    \"author\": \"AI Creator\"\n  }'\n\n# 5. Verify files exist\nls -lh uploads/$PROJECT_ID/\n```\n\n### Files This Task Provides to Other Agents\n\n- **Composed layout image** - Used by frontend for preview\n- **Export files** - PNG/JPG/PDF outputs for download\n- **Layout metadata** - Panel positions for debugging/display\n\n### Output Validation Checklist\n\n- [ ] calculateGrid() and calculatePanelPositions() methods work correctly\n- [ ] composePanels() successfully combines images with sharp\n- [ ] Borders render correctly around panels\n- [ ] Speech bubbles overlay without distortion\n- [ ] Multiple speech bubble styles work ('rounded', 'cloud', 'spiked', 'rectangular')\n- [ ] Layout PNG saved and readable\n- [ ] exportPNG() produces valid PNG files\n- [ ] exportJPG() produces valid JPG files with quality control\n- [ ] exportPDF() produces valid PDF with metadata\n- [ ] /layout endpoint returns correct panel positions\n- [ ] /export endpoint returns download URLs\n- [ ] Compression settings affect file size appropriately\n- [ ] No TypeScript compilation errors\n\n---\n\n## Task 5: React (Agent E)\n### Complete React UI with Component Implementation\n\n**Time Estimate:** 60-80 minutes\n**Difficulty:** Intermediate (React component patterns)\n**Dependencies:** Tasks 1-4 (backend API must be running)\n\n### Objective\nComplete all React components for the koma-fill frontend including image upload with drag-drop, story prompt editor, panel grid with drag-and-drop reordering, complete manga generation workflow orchestration, real-time SSE progress updates, and multi-format export options. Configure Tailwind CSS for styling.\n\n### Target Files to Create/Modify\n\n```\nfrontend/\n src/\n    components/\n       ImageUploader.tsx           [IMPLEMENT] Dropzone with position selector\n       StoryPromptEditor.tsx       [ENHANCE] Add sample prompts\n       PanelGrid.tsx               [IMPLEMENT] Drag-and-drop reordering\n       LayoutSelector.tsx          [VERIFY] Layout config UI\n       ExportOptions.tsx           [VERIFY] Export format selection\n       ProgressBar.tsx             [CREATE] Real-time progress display\n    hooks/\n       useMangaGeneration.ts       [IMPLEMENT] Full workflow orchestration\n    services/\n       apiClient.ts                [IMPLEMENT] API client with SSE support\n    pages/\n       CreateMangaPage.tsx         [IMPLEMENT] Main workflow page\n       PreviewPage.tsx             [IMPLEMENT] Result preview & download\n    App.tsx                         [UPDATE] Routing\n    main.tsx                        [VERIFY] Entry point\n    index.css                       [UPDATE] Tailwind directives\n tailwind.config.js                  [CREATE] Tailwind configuration\n postcss.config.js                   [CREATE] PostCSS configuration\n package.json                        [UPDATE] Add Tailwind dependencies\n tsconfig.json                       [VERIFY] TypeScript config\n```\n\n### TypeScript Interfaces (from `frontend/src/types/index.ts`)\n\nAlready defined - reference for component props.\n\n### Implementation Details\n\n#### 1. Tailwind CSS Setup\n\n**Install Dependencies:**\n```bash\ncd frontend\nnpm install -D tailwindcss postcss autoprefixer\nnpx tailwindcss init -p\n```\n\n**tailwind.config.js:**\n```javascript\nexport default {\n  content: [\n    './index.html',\n    './src/**/*.{js,ts,jsx,tsx}',\n  ],\n  theme: {\n    extend: {\n      colors: {\n        manga: {\n          dark: '#1a1a1a',\n          light: '#f5f5f5',\n        }\n      }\n    },\n  },\n  plugins: [],\n}\n```\n\n**postcss.config.js:**\n```javascript\nexport default {\n  plugins: {\n    tailwindcss: {},\n    autoprefixer: {},\n  },\n}\n```\n\n**frontend/src/index.css:**\n```css\n@tailwind base;\n@tailwind components;\n@tailwind utilities;\n\n@layer components {\n  .btn-primary {\n    @apply px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700 transition;\n  }\n  .btn-secondary {\n    @apply px-4 py-2 bg-gray-300 text-gray-800 rounded-lg hover:bg-gray-400 transition;\n  }\n  .input-field {\n    @apply w-full px-3 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500;\n  }\n}\n```\n\n#### 2. API Client (`frontend/src/services/apiClient.ts`)\n\n```typescript\nimport { MangaProject, Panel, GenerationProgress, ProgressEvent } from '../types';\n\nconst API_BASE = import.meta.env.VITE_API_URL || 'http://localhost:5000/api';\n\nexport class APIClient {\n  /**\n   * Create new manga project\n   */\n  async createProject(name: string, storyPrompt: string, layoutConfig?: any) {\n    const response = await fetch(`${API_BASE}/manga/create`, {\n      method: 'POST',\n      headers: { 'Content-Type': 'application/json' },\n      body: JSON.stringify({\n        projectName: name,\n        storyPrompt,\n        layoutConfig\n      })\n    });\n    if (!response.ok) throw new Error(await response.text());\n    return response.json() as Promise<MangaProject>;\n  }\n\n  /**\n   * Upload key images\n   */\n  async uploadImages(projectId: string, files: File[]) {\n    const formData = new FormData();\n    files.forEach(file => formData.append('images', file));\n\n    const response = await fetch(`${API_BASE}/manga/${projectId}/upload`, {\n      method: 'POST',\n      body: formData\n    });\n    if (!response.ok) throw new Error(await response.text());\n    return response.json();\n  }\n\n  /**\n   * Analyze images using Vision API\n   */\n  async analyzeImages(projectId: string, depth: 'quick' | 'detailed' = 'quick') {\n    const response = await fetch(`${API_BASE}/manga/${projectId}/analyze`, {\n      method: 'POST',\n      headers: { 'Content-Type': 'application/json' },\n      body: JSON.stringify({ analysisDepth: depth })\n    });\n    if (!response.ok) throw new Error(await response.text());\n    return response.json();\n  }\n\n  /**\n   * Generate panel prompts\n   */\n  async generatePrompts(projectId: string, storyPrompt: string, panelCount: number) {\n    const response = await fetch(`${API_BASE}/manga/${projectId}/generate-prompts`, {\n      method: 'POST',\n      headers: { 'Content-Type': 'application/json' },\n      body: JSON.stringify({\n        storyPrompt,\n        panelCount,\n        characterConsistency: true\n      })\n    });\n    if (!response.ok) throw new Error(await response.text());\n    return response.json() as Promise<Panel[]>;\n  }\n\n  /**\n   * Generate images via DALL-E 3 (SSE streaming)\n   */\n  streamImageGeneration(\n    projectId: string,\n    batchMode: 'sequential' | 'parallel',\n    onProgress: (event: ProgressEvent) => void,\n    onError: (error: Error) => void\n  ): () => void {\n    const eventSource = new EventSource(\n      `${API_BASE}/manga/${projectId}/generate-images?batchMode=${batchMode}`\n    );\n\n    eventSource.onmessage = (event) => {\n      try {\n        const data = JSON.parse(event.data);\n        onProgress(data);\n      } catch (e) {\n        console.error('Failed to parse SSE message:', e);\n      }\n    };\n\n    eventSource.onerror = () => {\n      onError(new Error('Generation failed or connection lost'));\n      eventSource.close();\n    };\n\n    // Return cleanup function\n    return () => eventSource.close();\n  }\n\n  /**\n   * Compose layout with speech bubbles\n   */\n  async composeLayout(projectId: string, speechBubbles?: any) {\n    const response = await fetch(`${API_BASE}/manga/${projectId}/layout`, {\n      method: 'POST',\n      headers: { 'Content-Type': 'application/json' },\n      body: JSON.stringify({ speechBubbles })\n    });\n    if (!response.ok) throw new Error(await response.text());\n    return response.json();\n  }\n\n  /**\n   * Export to PNG/JPG/PDF\n   */\n  async exportManga(\n    projectId: string,\n    format: 'png' | 'jpg' | 'pdf',\n    compression: 'low' | 'medium' | 'high' = 'medium',\n    title?: string,\n    author?: string\n  ) {\n    const response = await fetch(`${API_BASE}/manga/${projectId}/export`, {\n      method: 'POST',\n      headers: { 'Content-Type': 'application/json' },\n      body: JSON.stringify({\n        format,\n        compression,\n        resolution: 'web',\n        title,\n        author\n      })\n    });\n    if (!response.ok) throw new Error(await response.text());\n    return response.json();\n  }\n\n  /**\n   * Fetch project details\n   */\n  async getProject(projectId: string) {\n    const response = await fetch(`${API_BASE}/manga/${projectId}`);\n    if (!response.ok) throw new Error(await response.text());\n    return response.json() as Promise<MangaProject>;\n  }\n\n  /**\n   * Reorder panels\n   */\n  async reorderPanels(projectId: string, panelOrder: number[]) {\n    const response = await fetch(`${API_BASE}/manga/${projectId}/reorder`, {\n      method: 'PUT',\n      headers: { 'Content-Type': 'application/json' },\n      body: JSON.stringify({ panelOrder })\n    });\n    if (!response.ok) throw new Error(await response.text());\n    return response.json();\n  }\n}\n\nexport const apiClient = new APIClient();\n```\n\n#### 3. useMangaGeneration Hook (`frontend/src/hooks/useMangaGeneration.ts`)\n\n```typescript\nimport { useState, useCallback } from 'react';\nimport { apiClient } from '../services/apiClient';\nimport { MangaProject, GenerationProgress, UploadedImage } from '../types';\n\nexport function useMangaGeneration() {\n  const [project, setProject] = useState<MangaProject | null>(null);\n  const [progress, setProgress] = useState<GenerationProgress>({\n    stage: 'idle',\n    currentStep: 0,\n    totalSteps: 0,\n    percentage: 0,\n    message: ''\n  });\n  const [error, setError] = useState<string | null>(null);\n\n  /**\n   * Complete workflow: Create  Upload  Analyze  Generate Prompts  Generate Images  Layout\n   */\n  const generateManga = useCallback(async (\n    projectName: string,\n    storyPrompt: string,\n    uploadedImages: UploadedImage[],\n    layoutConfig: any,\n    generationSettings: any\n  ) => {\n    try {\n      setError(null);\n\n      // Stage 1: Create project\n      setProgress({\n        stage: 'uploading',\n        currentStep: 0,\n        totalSteps: 5,\n        percentage: 20,\n        message: 'Creating project...'\n      });\n      const newProject = await apiClient.createProject(projectName, storyPrompt, layoutConfig);\n      setProject(newProject);\n\n      // Stage 2: Upload images\n      setProgress({\n        stage: 'uploading',\n        currentStep: 1,\n        totalSteps: 5,\n        percentage: 40,\n        message: 'Uploading reference images...'\n      });\n      const files = uploadedImages.map(img => img.file);\n      await apiClient.uploadImages(newProject.id, files);\n\n      // Stage 3: Analyze images\n      setProgress({\n        stage: 'analyzing',\n        currentStep: 2,\n        totalSteps: 5,\n        percentage: 60,\n        message: 'Analyzing images with Vision API...'\n      });\n      await apiClient.analyzeImages(newProject.id, 'detailed');\n\n      // Stage 4: Generate prompts\n      setProgress({\n        stage: 'generating_prompts',\n        currentStep: 3,\n        totalSteps: 5,\n        percentage: 70,\n        message: 'Generating panel prompts...'\n      });\n      await apiClient.generatePrompts(\n        newProject.id,\n        storyPrompt,\n        layoutConfig.totalPanels\n      );\n\n      // Stage 5: Generate images (with SSE streaming)\n      setProgress({\n        stage: 'generating_images',\n        currentStep: 4,\n        totalSteps: 5,\n        percentage: 75,\n        message: 'Starting image generation...'\n      });\n\n      await new Promise<void>((resolve, reject) => {\n        const cleanup = apiClient.streamImageGeneration(\n          newProject.id,\n          'sequential',  // or 'parallel' based on user preference\n          (progressEvent) => {\n            if (progressEvent.type === 'complete') {\n              setProgress(prev => ({\n                ...prev,\n                percentage: 90,\n                message: 'Image generation complete!'\n              }));\n              resolve();\n            } else if (progressEvent.type === 'error') {\n              reject(new Error(progressEvent.error || 'Generation failed'));\n            } else {\n              setProgress({\n                stage: 'generating_images',\n                currentStep: 4 + (progressEvent.currentStep || 0) * 0.1,\n                totalSteps: 5,\n                percentage: 75 + (progressEvent.percentage || 0) * 0.15,\n                message: progressEvent.message,\n                currentPanelIndex: progressEvent.panelIndex\n              });\n            }\n          },\n          reject\n        );\n      });\n\n      // Stage 6: Compose layout\n      setProgress({\n        stage: 'composing_layout',\n        currentStep: 5,\n        totalSteps: 5,\n        percentage: 95,\n        message: 'Composing final layout...'\n      });\n      await apiClient.composeLayout(newProject.id);\n\n      // Complete\n      const finalProject = await apiClient.getProject(newProject.id);\n      setProject(finalProject);\n      setProgress({\n        stage: 'idle',\n        currentStep: 5,\n        totalSteps: 5,\n        percentage: 100,\n        message: 'Manga generation complete!'\n      });\n\n    } catch (err) {\n      const errorMsg = err instanceof Error ? err.message : 'Unknown error';\n      setError(errorMsg);\n      setProgress({\n        stage: 'idle',\n        currentStep: 0,\n        totalSteps: 0,\n        percentage: 0,\n        message: `Error: ${errorMsg}`\n      });\n    }\n  }, []);\n\n  const exportManga = useCallback(async (\n    projectId: string,\n    format: 'png' | 'jpg' | 'pdf',\n    compression: 'low' | 'medium' | 'high' = 'medium'\n  ) => {\n    try {\n      setError(null);\n      setProgress({\n        stage: 'exporting',\n        currentStep: 0,\n        totalSteps: 1,\n        percentage: 50,\n        message: `Exporting as ${format.toUpperCase()}...`\n      });\n\n      const result = await apiClient.exportManga(projectId, format, compression);\n\n      setProgress({\n        stage: 'idle',\n        currentStep: 1,\n        totalSteps: 1,\n        percentage: 100,\n        message: 'Export complete!'\n      });\n\n      return result;\n    } catch (err) {\n      const errorMsg = err instanceof Error ? err.message : 'Export failed';\n      setError(errorMsg);\n      throw err;\n    }\n  }, []);\n\n  return {\n    project,\n    progress,\n    error,\n    generateManga,\n    exportManga,\n    setError\n  };\n}\n```\n\n#### 4. Components\n\n**ImageUploader.tsx:**\n```typescript\nimport { useCallback, useState } from 'react';\nimport { UploadedImage, ImagePosition } from '../types';\n\ninterface ImageUploaderProps {\n  onImagesSelected: (images: UploadedImage[]) => void;\n}\n\nexport function ImageUploader({ onImagesSelected }: ImageUploaderProps) {\n  const [images, setImages] = useState<UploadedImage[]>([]);\n  const [selectedPosition, setSelectedPosition] = useState<ImagePosition>('start');\n\n  const handleDrop = useCallback((e: React.DragEvent) => {\n    e.preventDefault();\n    const files = Array.from(e.dataTransfer.files).filter(f => f.type.startsWith('image/'));\n    addImages(files);\n  }, []);\n\n  const handleFileInput = (e: React.ChangeEvent<HTMLInputElement>) => {\n    if (e.target.files) {\n      addImages(Array.from(e.target.files));\n    }\n  };\n\n  const addImages = (files: File[]) => {\n    const newImages = files.map(file => ({\n      file,\n      previewUrl: URL.createObjectURL(file),\n      position: selectedPosition\n    }));\n    setImages(prev => [...prev, ...newImages]);\n    onImagesSelected([...images, ...newImages]);\n  };\n\n  const removeImage = (index: number) => {\n    const updated = images.filter((_, i) => i !== index);\n    setImages(updated);\n    onImagesSelected(updated);\n  };\n\n  return (\n    <div className=\"w-full max-w-2xl\">\n      <div\n        onDrop={handleDrop}\n        onDragOver={e => e.preventDefault()}\n        className=\"border-2 border-dashed border-gray-300 rounded-lg p-8 text-center cursor-pointer hover:border-blue-500 transition\"\n      >\n        <p className=\"text-gray-600 mb-4\">Drag and drop images here or click to select</p>\n        <input\n          type=\"file\"\n          multiple\n          accept=\"image/*\"\n          onChange={handleFileInput}\n          className=\"hidden\"\n          id=\"image-input\"\n        />\n        <label htmlFor=\"image-input\" className=\"btn-primary cursor-pointer\">\n          Select Images\n        </label>\n      </div>\n\n      <div className=\"mt-4\">\n        <label className=\"block mb-2\">Position in Story:</label>\n        <select\n          value={selectedPosition}\n          onChange={e => setSelectedPosition(e.target.value as ImagePosition)}\n          className=\"input-field\"\n        >\n          <option value=\"start\">Start (Reference)</option>\n          <option value=\"end\">End (Reference)</option>\n          <option value={1}>Panel 1</option>\n          <option value={2}>Panel 2</option>\n        </select>\n      </div>\n\n      {images.length > 0 && (\n        <div className=\"mt-6 grid grid-cols-2 gap-4\">\n          {images.map((img, idx) => (\n            <div key={idx} className=\"relative\">\n              <img src={img.previewUrl} alt={`Preview ${idx}`} className=\"rounded-lg w-full h-48 object-cover\" />\n              <button\n                onClick={() => removeImage(idx)}\n                className=\"absolute top-2 right-2 bg-red-500 text-white rounded-full w-6 h-6 flex items-center justify-center hover:bg-red-600\"\n              >\n                \n              </button>\n            </div>\n          ))}\n        </div>\n      )}\n    </div>\n  );\n}\n```\n\n**StoryPromptEditor.tsx (Enhanced):**\n```typescript\nimport { useState } from 'react';\n\ninterface StoryPromptEditorProps {\n  value: string;\n  onChange: (value: string) => void;\n}\n\nconst SAMPLE_PROMPTS = [\n  'A young ninja discovers their hidden powers and must save their village from a mysterious threat.',\n  'Two rival chefs compete in a cooking tournament, discovering they have more in common than they thought.',\n  'A time traveler must prevent a catastrophic event by gathering clues from different eras.',\n];\n\nexport function StoryPromptEditor({ value, onChange }: StoryPromptEditorProps) {\n  const [isExpanded, setIsExpanded] = useState(false);\n\n  return (\n    <div className=\"w-full max-w-2xl\">\n      <label className=\"block text-lg font-semibold mb-2\">Your Story Prompt</label>\n\n      <textarea\n        value={value}\n        onChange={e => onChange(e.target.value)}\n        placeholder=\"Write your manga story here. Be descriptive about characters, setting, and plot...\"\n        className=\"input-field h-32 resize-none\"\n      />\n\n      <div className=\"mt-4\">\n        <button\n          onClick={() => setIsExpanded(!isExpanded)}\n          className=\"text-blue-600 hover:underline text-sm\"\n        >\n          {isExpanded ? 'Hide' : 'Show'} Sample Prompts\n        </button>\n\n        {isExpanded && (\n          <div className=\"mt-3 space-y-2\">\n            {SAMPLE_PROMPTS.map((prompt, idx) => (\n              <button\n                key={idx}\n                onClick={() => onChange(prompt)}\n                className=\"block w-full text-left p-3 bg-gray-100 hover:bg-gray-200 rounded-lg text-sm transition\"\n              >\n                {prompt}\n              </button>\n            ))}\n          </div>\n        )}\n      </div>\n    </div>\n  );\n}\n```\n\n**PanelGrid.tsx (with Drag-and-Drop):**\n```typescript\nimport { useState } from 'react';\nimport { Panel } from '../types';\nimport { DndContext, closestCenter, KeyboardSensor, PointerSensor, useSensor, useSensors } from '@dnd-kit/core';\nimport { SortableContext, sortableKeyboardCoordinates, verticalListSortingStrategy, useSortable } from '@dnd-kit/sortable';\nimport { CSS } from '@dnd-kit/utilities';\n\nfunction SortablePanel({ panel }: { panel: Panel }) {\n  const { attributes, listeners, setNodeRef, transform, transition } = useSortable({ id: panel.id });\n  const style = { transform: CSS.Transform.toString(transform), transition };\n\n  return (\n    <div ref={setNodeRef} style={style} {...attributes} {...listeners} className=\"p-4\">\n      <div className=\"bg-white rounded-lg shadow p-4 cursor-grab active:cursor-grabbing\">\n        <img\n          src={panel.imageUrl}\n          alt={`Panel ${panel.panelIndex}`}\n          className=\"w-full h-auto rounded mb-2\"\n        />\n        <p className=\"text-sm text-gray-600\">{panel.storyBeat}</p>\n        <span className={`inline-block mt-2 px-2 py-1 rounded text-xs text-white ${\n          panel.status === 'generated' ? 'bg-green-500' :\n          panel.status === 'pending' ? 'bg-blue-500' :\n          'bg-red-500'\n        }`}>\n          {panel.status}\n        </span>\n      </div>\n    </div>\n  );\n}\n\ninterface PanelGridProps {\n  panels: Panel[];\n  onReorder: (newOrder: Panel[]) => void;\n}\n\nexport function PanelGrid({ panels, onReorder }: PanelGridProps) {\n  const sensors = useSensors(\n    useSensor(PointerSensor),\n    useSensor(KeyboardSensor, { coordinateGetter: sortableKeyboardCoordinates })\n  );\n\n  const handleDragEnd = (event: any) => {\n    const { active, over } = event;\n    if (over && active.id !== over.id) {\n      const oldIndex = panels.findIndex(p => p.id === active.id);\n      const newIndex = panels.findIndex(p => p.id === over.id);\n      const newPanels = [...panels];\n      [newPanels[oldIndex], newPanels[newIndex]] = [newPanels[newIndex], newPanels[oldIndex]];\n      onReorder(newPanels);\n    }\n  };\n\n  return (\n    <DndContext sensors={sensors} collisionDetection={closestCenter} onDragEnd={handleDragEnd}>\n      <SortableContext items={panels.map(p => p.id)} strategy={verticalListSortingStrategy}>\n        <div className=\"grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-4\">\n          {panels.map(panel => (\n            <SortablePanel key={panel.id} panel={panel} />\n          ))}\n        </div>\n      </SortableContext>\n    </DndContext>\n  );\n}\n```\n\n**ProgressBar.tsx:**\n```typescript\nimport { GenerationProgress } from '../types';\n\nexport function ProgressBar({ progress }: { progress: GenerationProgress }) {\n  return (\n    <div className=\"w-full max-w-2xl\">\n      <div className=\"mb-2 flex justify-between\">\n        <span className=\"text-sm font-semibold\">{progress.message}</span>\n        <span className=\"text-sm text-gray-600\">{Math.round(progress.percentage)}%</span>\n      </div>\n      <div className=\"w-full h-3 bg-gray-200 rounded-full overflow-hidden\">\n        <div\n          className=\"h-full bg-blue-600 transition-all duration-300\"\n          style={{ width: `${progress.percentage}%` }}\n        />\n      </div>\n    </div>\n  );\n}\n```\n\n#### 5. Pages\n\n**CreateMangaPage.tsx:**\n```typescript\nimport { useState } from 'react';\nimport { ImageUploader } from '../components/ImageUploader';\nimport { StoryPromptEditor } from '../components/StoryPromptEditor';\nimport { LayoutSelector } from '../components/LayoutSelector';\nimport { ProgressBar } from '../components/ProgressBar';\nimport { useMangaGeneration } from '../hooks/useMangaGeneration';\nimport { UploadedImage, LayoutConfig } from '../types';\n\nexport function CreateMangaPage() {\n  const [projectName, setProjectName] = useState('');\n  const [storyPrompt, setStoryPrompt] = useState('');\n  const [uploadedImages, setUploadedImages] = useState<UploadedImage[]>([]);\n  const [layoutConfig, setLayoutConfig] = useState<LayoutConfig>({\n    totalPanels: 4,\n    format: 'vertical',\n    readingOrder: 'japanese',\n    gutterSize: 10,\n    borderWidth: 2,\n    borderColor: '#000000',\n    backgroundColor: '#FFFFFF',\n    pageWidth: 800,\n    pageHeight: 1200\n  });\n\n  const { progress, error, generateManga } = useMangaGeneration();\n\n  const handleStart = async () => {\n    if (!projectName || !storyPrompt) {\n      alert('Please enter project name and story prompt');\n      return;\n    }\n\n    await generateManga(projectName, storyPrompt, uploadedImages, layoutConfig, {\n      imageStyle: 'manga style',\n      aspectRatio: 'square',\n      qualityLevel: 'standard'\n    });\n  };\n\n  return (\n    <div className=\"min-h-screen bg-gray-50 py-12 px-4\">\n      <div className=\"max-w-4xl mx-auto space-y-8\">\n        <h1 className=\"text-4xl font-bold text-center mb-2\">koma-fill</h1>\n        <p className=\"text-center text-gray-600\">AI-Powered Manga Panel Generator</p>\n\n        {error && <div className=\"bg-red-100 border border-red-400 text-red-700 px-4 py-3 rounded\">{error}</div>}\n\n        {progress.stage === 'idle' ? (\n          <div className=\"space-y-8\">\n            <div className=\"bg-white p-6 rounded-lg shadow\">\n              <label className=\"block text-lg font-semibold mb-2\">Project Name</label>\n              <input\n                type=\"text\"\n                value={projectName}\n                onChange={e => setProjectName(e.target.value)}\n                className=\"input-field\"\n                placeholder=\"My Awesome Manga\"\n              />\n            </div>\n\n            <div className=\"bg-white p-6 rounded-lg shadow\">\n              <StoryPromptEditor value={storyPrompt} onChange={setStoryPrompt} />\n            </div>\n\n            <div className=\"bg-white p-6 rounded-lg shadow\">\n              <ImageUploader onImagesSelected={setUploadedImages} />\n            </div>\n\n            <div className=\"bg-white p-6 rounded-lg shadow\">\n              <LayoutSelector config={layoutConfig} onChange={setLayoutConfig} />\n            </div>\n\n            <button onClick={handleStart} className=\"btn-primary w-full text-lg py-3\">\n              Generate Manga\n            </button>\n          </div>\n        ) : (\n          <div className=\"bg-white p-6 rounded-lg shadow\">\n            <ProgressBar progress={progress} />\n          </div>\n        )}\n      </div>\n    </div>\n  );\n}\n```\n\n**PreviewPage.tsx:**\n```typescript\nimport { useParams, useNavigate } from 'react-router-dom';\nimport { useEffect, useState } from 'react';\nimport { apiClient } from '../services/apiClient';\nimport { PanelGrid } from '../components/PanelGrid';\nimport { ExportOptions } from '../components/ExportOptions';\nimport { MangaProject } from '../types';\n\nexport function PreviewPage() {\n  const { projectId } = useParams<{ projectId: string }>();\n  const navigate = useNavigate();\n  const [project, setProject] = useState<MangaProject | null>(null);\n  const [loading, setLoading] = useState(true);\n\n  useEffect(() => {\n    if (projectId) {\n      apiClient.getProject(projectId).then(setProject).finally(() => setLoading(false));\n    }\n  }, [projectId]);\n\n  if (loading) return <div className=\"flex justify-center py-12\">Loading...</div>;\n  if (!project) return <div className=\"text-center py-12\">Project not found</div>;\n\n  return (\n    <div className=\"min-h-screen bg-gray-50 py-12 px-4\">\n      <div className=\"max-w-6xl mx-auto\">\n        <button onClick={() => navigate('/')} className=\"btn-secondary mb-6\"> Back</button>\n\n        <h1 className=\"text-3xl font-bold mb-2\">{project.name}</h1>\n        <p className=\"text-gray-600 mb-6\">Project Status: {project.status}</p>\n\n        {project.panels.length > 0 && (\n          <div className=\"bg-white p-6 rounded-lg shadow mb-8\">\n            <h2 className=\"text-2xl font-semibold mb-4\">Panels</h2>\n            <PanelGrid panels={project.panels} onReorder={() => {}} />\n          </div>\n        )}\n\n        <div className=\"bg-white p-6 rounded-lg shadow\">\n          <h2 className=\"text-2xl font-semibold mb-4\">Export</h2>\n          <ExportOptions projectId={project.id} />\n        </div>\n      </div>\n    </div>\n  );\n}\n```\n\n#### 6. Update App.tsx\n\n```typescript\nimport { BrowserRouter as Router, Routes, Route, Navigate } from 'react-router-dom';\nimport { CreateMangaPage } from './pages/CreateMangaPage';\nimport { PreviewPage } from './pages/PreviewPage';\nimport './index.css';\n\nexport default function App() {\n  return (\n    <Router>\n      <Routes>\n        <Route path=\"/\" element={<CreateMangaPage />} />\n        <Route path=\"/project/:projectId\" element={<PreviewPage />} />\n        <Route path=\"*\" element={<Navigate to=\"/\" />} />\n      </Routes>\n    </Router>\n  );\n}\n```\n\n### package.json Updates\n\nAdd dependencies:\n```bash\nnpm install -D tailwindcss postcss autoprefixer\nnpm install react-router-dom @dnd-kit/core @dnd-kit/sortable @dnd-kit/utilities\n```\n\n### Testing Requirements\n\n```bash\n# 1. Start backend (from Task 1)\ncd backend && npm run dev\n\n# 2. In another terminal, start frontend\ncd frontend && npm run dev\n\n# 3. Open browser: http://localhost:3000\n\n# 4. Test workflow:\n# - Enter project name and story\n# - Upload reference images\n# - Configure layout\n# - Click \"Generate Manga\"\n# - Watch progress bar\n# - See panel grid with images\n# - Export to PNG/JPG/PDF\n```\n\n### Files This Task Uses from Other Agents\n\n- **API endpoints** from Task 1 (database & routes)\n- **Analysis data** from Task 2 (character consistency)\n- **Generated images** from Task 3 (panel images)\n- **Composed layouts** from Task 4 (final manga)\n\n### Output Validation Checklist\n\n- [ ] Tailwind CSS configured and working\n- [ ] ImageUploader component with drag-drop works\n- [ ] react-dropzone integration functional\n- [ ] StoryPromptEditor displays with sample prompts\n- [ ] Sample prompt insertion works\n- [ ] PanelGrid displays with drag-and-drop reordering\n- [ ] @dnd-kit integration functional\n- [ ] useMangaGeneration hook orchestrates full workflow\n- [ ] SSE progress streaming displays correctly\n- [ ] ProgressBar updates in real-time\n- [ ] apiClient makes correct API calls\n- [ ] All components have TypeScript types\n- [ ] CreateMangaPage workflow complete\n- [ ] PreviewPage shows generated manga\n- [ ] ExportOptions functional (PNG/JPG/PDF)\n- [ ] Routing works (create  preview)\n- [ ] Error handling displays user-friendly messages\n- [ ] npm run dev starts without errors\n- [ ] No TypeScript compilation errors\n\n---\n\n## Integration Testing (After All Tasks Complete)\n\nAfter all 5 agents finish their implementations, run the following integration tests:\n\n```bash\n# 1. Start backend\ncd /mnt/Projects/koma-fill/backend\nnpm install\nnpm run dev\n# Expected: \" koma-fill server running on http://localhost:5000\"\n\n# 2. Start frontend (new terminal)\ncd /mnt/Projects/koma-fill/frontend\nnpm install\nnpm run dev\n# Expected: \"VITE  ready in XXX ms\"\n\n# 3. Complete workflow test\n# Open http://localhost:3000 in browser\n# - Create project\n# - Upload 2 reference images\n# - Enter story prompt\n# - Select layout (4 panels)\n# - Click \"Generate Manga\"\n# - Wait for completion\n# - View generated panels\n# - Export to PNG\n# - Verify PNG file created in uploads/\n\n# 4. Verify database\nsqlite3 /mnt/Projects/koma-fill/data/koma-fill.db\n> SELECT COUNT(*) FROM projects;\n> SELECT COUNT(*) FROM panels;\n> SELECT COUNT(*) FROM keyImages;\n\n# 5. Check file structure\nls -la /mnt/Projects/koma-fill/uploads/\nls -la /mnt/Projects/koma-fill/data/\n\n# 6. API health check\ncurl http://localhost:5000/api/health\n# Expected: {\"status\":\"ok\",\"timestamp\":\"...\"}\n```\n\n### Known Integration Points to Verify\n\n- Task 1  Task 2: Panel prompts saved in DB, readable by frontend\n- Task 2  Task 3: Vision analysis influences character consistency in prompts\n- Task 3  Task 4: Generated images saved to disk, paths in database\n- Task 4  Task 5: Layout images served via `/uploads/` static directory\n- Task 5  All: Frontend calls all backend API endpoints successfully\n\n---\n\n## Success Criteria Summary\n\nAll 5 tasks completed when:\n\n1. **Backend (Task 1)**: Express server with SQLite database, all CRUD routes working\n2. **Vision & Prompts (Task 2)**: OpenAI Vision API analyzes images, GPT-4o generates DALL-E prompts\n3. **Image Generation (Task 3)**: DALL-E 3 generates 4+ images with retry logic, SSE progress works\n4. **Layout & Export (Task 4)**: Sharp composes panels into manga layout, exports PNG/JPG/PDF\n5. **Frontend (Task 5)**: React UI allows workflow from story  generated manga  export\n\n**Total Expected Time**: 4-5 hours per agent (can run in parallel)\n**Minimum Test Time**: 30 minutes for integration testing\n\nGood luck, KAMUI agents! \n\n---\n\n*Last Updated: 2025-02-12*\n*For issues or questions, refer to the specific task prompts above*",
        "tooltip": ": ClaudeCode1: # KAMUI-4D Parallel Task Prompts for koma-fill\n## Manga Generation AI System - Multi-Agent Implementation Guide\n\n**Version:** 1.0\n**Project:** koma-fill - AI-powered manga panel generation system\n**Target:** KAMUI-4D Editor (Multi-AI CLI parallel execution)\n\n---\n\n## How to Use These Prompts in KAMUI-4D\n\nThis document contains **5 independent task prompts** designed to run in parallel across multiple AI coding agents. Each prompt is self-contained and can be executed independently without blocking other tasks.\n\n### Setup Instructions\n\n1. **Install dependencies** (run once before starting tasks):\n   ```bash\n   cd /mnt/Projects/koma-fill/backend\n   npm install\n\n   cd /mnt/Projects/koma-fill/frontend\n   npm install\n   ```\n\n2. **Environment Configuration**:\n   Create `/mnt/Projects/koma-fill/.env`:\n   ```\n   NODE_ENV=development\n   PORT=5000\n   BASE_URL=http://localhost:5000\n   OPENAI_API_KEY=your_openai_api_key_here\n   OPENAI_ORG_ID=your_org_id_optional\n   DATABASE_PATH=./data/koma-fill.db\n   STORAGE_PATH=./uploads\n   MAX_IMAGE_SIZE_MB=20\n   DALLE_RATE_LIMIT_PER_MINUTE=5\n   VISION_RATE_LIMIT_PER_MINUTE=30\n   MAX_RETRIES_PER_PANEL=3\n   ALLOWED_ORIGINS=http://localhost:3000\n   ```\n\n3. **Execution Strategy**:\n   - Copy each task prompt below into a separate KAMUI-4D session/agent\n   - **Tasks 1-5 can ALL start simultaneously** (no blocking dependencies)\n   - Each task should run independently in its own AI CLI session\n   - Monitor each agent's progress via console output\n   - **Integration testing** should happen after all 5 tasks complete (see bottom of doc)\n\n4. **Task Dependencies**:\n   ```\n   Task 1 (Backend)  provides database & API contracts\n   Task 2 (Vision)  uses Task 1's API, reads backend/src/models/types.ts\n   Task 3 (Images)  uses Task 1's API, reads backend/src/models/types.ts\n   Task 4 (Layout)  uses Task 1's API, reads backend/src/models/types.ts\n   Task 5 (Frontend)  calls Tasks 1-4 via REST API\n   ```\n   **All tasks can start immediately** - they communicate via file system and API contracts.\n\n---\n\n## Task 1: Backend (Agent A)\n### Express Server, SQLite Database & CRUD Routes Foundation\n\n**Time Estimate:** 45-60 minutes\n**Difficulty:** Intermediate\n**Dependencies:** None (this is the foundation layer)\n\n### Objective\nSet up a fully functional Express.js backend with SQLite database, implement CRUD operations for manga projects and panels, configure file upload handling with multer, and provide a solid API foundation for other agents to build upon.\n\n### Target Files to Create/Modify\n\n```\nbackend/\n src/\n    database/\n       connection.ts          [NEW] SQLite connection & initialization\n       schema.ts              [NEW] Table schema definitions\n    index.ts                   [MODIFY] Add DB initialization\n    app.ts                     [COMPLETE] Already done - verify middleware\n    routes/\n       manga.ts               [IMPLEMENT] Route handlers with DB calls\n    middleware/\n        errorHandler.ts        [VERIFY] Already complete\n uploads/                        [CREATE] Directory for image storage\n data/                           [CREATE] Directory for SQLite DB\n```\n\n### TypeScript Interfaces (from `/mnt/Projects/koma-fill/backend/src/models/types.ts`)\n\nKey types you'll use:\n```typescript\n// Core entities\nMangaProject {\n  id: string;                    // UUID\n  name: string;\n  description?: string;\n  status: ProjectStatus;         // 'draft' | 'analyzing' | 'generating' | 'complete' | 'exported'\n  layoutConfig: LayoutConfig;\n  generationSettings: GenerationSettings;\n  panels: Panel[];\n  keyImages: KeyImage[];\n  totalCost: number;\n  createdAt: string;             // ISO datetime\n  updatedAt: string;\n}\n\nPanel {\n  id: string;                    // UUID\n  projectId: string;\n  panelIndex: number;            // 0-based\n  imageUrl?: string;\n  imageFilePath?: string;\n  prompt?: string;\n  storyBeat?: string;\n  speechBubbleText?: string;\n  status: PanelStatus;           // 'pending' | 'generated' | 'failed' | 'placeholder'\n  retryCount: number;\n  generatedAt?: string;\n  createdAt: string;\n}\n\nKeyImage {\n  id: string;                    // UUID\n  projectId: string;\n  imageFilePath: string;\n  position: ImagePosition;       // 'start' | 'end' | number\n  analysis?: ImageAnalysis;\n  createdAt: string;\n}\n\nLayoutConfig {\n  totalPanels: number;           // 4, 6, 8, etc.\n  format: LayoutFormat;          // 'vertical' | 'horizontal' | 'square'\n  readingOrder: ReadingOrder;    // 'japanese' | 'western'\n  gutterSize: number;            // px\n  borderWidth: number;           // px\n  borderColor: string;           // hex #RRGGBB\n  backgroundColor: string;       // hex\n  pageWidth: number;             // px\n  pageHeight: number;            // px\n}\n\nGenerationSettings {\n  imageStyle: string;            // e.g., \"manga style, black and white ink\"\n  aspectRatio: 'square' | 'wide' | 'tall';\n  qualityLevel: 'standard' | 'hd';\n  negativePrompt?: string;\n  seed?: number;\n}\n```\n\n### Implementation Checklist\n\n#### 1. Create Database Connection Module (`backend/src/database/connection.ts`)\n```typescript\n// Requirements:\n- Initialize better-sqlite3 connection\n- Create/open database at DATABASE_PATH from .env\n- Export initDatabase() async function\n- Enable foreign keys constraint\n- Handle database file creation if needed\n- Connection should be cached/singleton\n```\n\n#### 2. Create Database Schema Module (`backend/src/database/schema.ts`)\n```typescript\n// SQL Schema Requirements:\nCREATE TABLE projects (\n  id TEXT PRIMARY KEY,\n  name TEXT NOT NULL,\n  description TEXT,\n  status TEXT NOT NULL,\n  layoutConfig JSON NOT NULL,\n  generationSettings JSON NOT NULL,\n  totalCost REAL DEFAULT 0,\n  createdAt TEXT NOT NULL,\n  updatedAt TEXT NOT NULL\n);\n\nCREATE TABLE panels (\n  id TEXT PRIMARY KEY,\n  projectId TEXT NOT NULL,\n  panelIndex INTEGER NOT NULL,\n  imageUrl TEXT,\n  imageFilePath TEXT,\n  prompt TEXT,\n  storyBeat TEXT,\n  speechBubbleText TEXT,\n  status TEXT NOT NULL,\n  retryCount INTEGER DEFAULT 0,\n  generatedAt TEXT,\n  createdAt TEXT NOT NULL,\n  FOREIGN KEY (projectId) REFERENCES projects(id)\n);\n\nCREATE TABLE keyImages (\n  id TEXT PRIMARY KEY,\n  projectId TEXT NOT NULL,\n  imageFilePath TEXT NOT NULL,\n  position TEXT NOT NULL,\n  analysis JSON,\n  createdAt TEXT NOT NULL,\n  FOREIGN KEY (projectId) REFERENCES projects(id)\n);\n\nCREATE INDEX idx_project_status ON projects(status);\nCREATE INDEX idx_panel_project ON panels(projectId);\nCREATE INDEX idx_panel_status ON panels(status);\n```\n\n#### 3. Modify `backend/src/index.ts`\n```typescript\n// Add:\n- Import { initDatabase } from './database/connection'\n- Call await initDatabase() before app.listen()\n- Log database initialization success\n```\n\n#### 4. Create Repository Layer (`backend/src/repositories/`)\n```typescript\n// Create:\n- ProjectRepository with methods:\n  - createProject(data: CreateMangaRequest): Promise<MangaProject>\n  - getProject(id: string): Promise<MangaProject | null>\n  - listProjects(limit: number, offset: number): Promise<MangaProject[]>\n  - updateProject(id: string, updates: Partial<MangaProject>): Promise<MangaProject>\n  - deleteProject(id: string): Promise<void>\n\n- PanelRepository with methods:\n  - createPanel(projectId: string, data: Panel): Promise<Panel>\n  - getPanelsByProject(projectId: string): Promise<Panel[]>\n  - getPanel(panelId: string): Promise<Panel | null>\n  - updatePanel(panelId: string, updates: Partial<Panel>): Promise<Panel>\n  - updatePanelStatus(panelId: string, status: PanelStatus): Promise<void>\n\n- KeyImageRepository with methods:\n  - createKeyImage(projectId: string, data: KeyImage): Promise<KeyImage>\n  - getKeyImages(projectId: string): Promise<KeyImage[]>\n  - updateKeyImageAnalysis(imageId: string, analysis: ImageAnalysis): Promise<void>\n```\n\n#### 5. Implement Routes in `backend/src/routes/manga.ts`\nReplace TODO comments with actual implementations:\n\n- **POST /api/manga/create**\n  - Validate CreateMangaRequest using Joi\n  - Generate unique project ID (uuid)\n  - Create project in database with 'draft' status\n  - Create initial panel records (count = layoutConfig.totalPanels)\n  - Return created MangaProject with 201 status\n\n- **POST /api/manga/:projectId/upload**\n  - Files already handled by multer middleware\n  - Save KeyImage records to database with file paths\n  - Store position information\n  - Return array of KeyImage objects\n\n- **GET /api/manga/:projectId**\n  - Fetch project + panels + key images from database\n  - Return complete MangaProject object\n  - Throw NotFoundError if project doesn't exist\n\n- **GET /api/manga**\n  - Implement pagination (limit/offset query params)\n  - Return array of projects\n  - Include total count header\n\n- **PUT /api/manga/:projectId/reorder**\n  - Parse ReorderPanelsRequest body\n  - Update panelIndex for each panel based on new order\n  - Return updated panels array\n\n### Testing Requirements\n\nAfter implementation, verify:\n\n```bash\n# 1. Database initialization\nnpm run dev\n# Check console: \" configured\" for database\n\n# 2. Create project\ncurl -X POST http://localhost:5000/api/manga/create \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\n    \"projectName\": \"Test Manga\",\n    \"storyPrompt\": \"A hero on a quest\",\n    \"layoutConfig\": { \"totalPanels\": 4 }\n  }'\n\n# 3. Get project\ncurl http://localhost:5000/api/manga/{projectId}\n\n# 4. Upload images\ncurl -X POST http://localhost:5000/api/manga/{projectId}/upload \\\n  -F \"images=@test1.jpg\" \\\n  -F \"images=@test2.jpg\"\n\n# 5. Check database\nsqlite3 data/koma-fill.db \"SELECT * FROM projects; SELECT * FROM panels;\"\n```\n\n### Files This Task Provides to Other Agents\n\n- **Database schema** - Tasks 2, 3, 4, 5 will read/write to these tables\n- **API contracts** - manga.ts route signatures that Tasks 2-4 will call\n- **File storage structure** - uploads/ directory path that Task 3 will use\n- **Type definitions** - already in backend/src/models/types.ts (reference only)\n\n### Output Validation Checklist\n\n- [ ] Database file created at `data/koma-fill.db`\n- [ ] All 3 tables created with correct schema\n- [ ] Repositories implement CRUD operations\n- [ ] All route handlers work without TODO comments\n- [ ] multer uploads save files to `uploads/` directory\n- [ ] POST /create returns 201 with MangaProject object\n- [ ] GET /:projectId returns full project with panels\n- [ ] Error handler catches and responds appropriately\n- [ ] No TypeScript compilation errors\n- [ ] npm run dev starts without errors\n\n---\n\n## Task 2: + (Agent B)\n### Vision API Integration & DALL-E Prompt Generation\n\n**Time Estimate:** 50-60 minutes\n**Difficulty:** Intermediate\n**Dependencies:** Task 1 (needs database & API routes available)\n\n### Objective\nImplement OpenAI Vision API integration to analyze uploaded key images and extract character/style information. Then implement story-to-panel prompt generation using GPT-4o to create DALL-E 3 compatible prompts that maintain consistency across panels.\n\n### Target Files to Create/Modify\n\n```\nbackend/\n src/\n     services/\n         imageAnalysisService.ts      [IMPLEMENT] Vision API analysis\n         promptGenerationService.ts   [CREATE] Story  panel prompts\n```\n\n### System Prompts (Already Provided)\n\nBoth vision analysis prompts are defined in `imageAnalysisService.ts`:\n- `QUICK_ANALYSIS_PROMPT` - fast, ~500 tokens\n- `DETAILED_ANALYSIS_PROMPT` - thorough, ~2000 tokens\n\nThese guide the Vision API to return structured JSON matching the `ImageAnalysis` interface.\n\n### TypeScript Interfaces\n\n```typescript\n// Input: Key image file path (from Task 1)\n// Output: ImageAnalysis object\n\nImageAnalysis {\n  description: string;\n  characters: CharacterInfo[];\n  objects: string[];\n  colors: string[];\n  composition: string;\n  mood: string;\n  artStyle: string;\n  suggestedTransitions: string[];\n}\n\nCharacterInfo {\n  name?: string;\n  appearance: string;        // detailed physical description\n  emotion: string;\n  position: string;          // screen position (e.g., \"center-left\")\n}\n\n// Panel prompt generation\nPanelPrompt {\n  panelIndex: number;\n  dallePrompt: string;       // Full DALL-E 3 prompt (100-300 words)\n  storyBeat: string;         // What happens in this panel\n  visualFocus: string;       // Main visual element\n  transitionType: TransitionType;  // 'cut' | 'pan' | 'zoom_in' | 'zoom_out' | 'fade' | 'action'\n  suggestedDialogue?: string;\n}\n```\n\n### Implementation Details\n\n#### ImageAnalysisService (`backend/src/services/imageAnalysisService.ts`)\n\n**Constructor:**\n```typescript\nconstructor() {\n  this.openai = new OpenAI({\n    apiKey: CONFIG.OPENAI_API_KEY,\n    organization: CONFIG.OPENAI_ORG_ID\n  });\n}\n```\n\n**Method: analyzeImage(imageBase64: string, depth: 'quick' | 'detailed')**\n- Input: Base64-encoded image data from KeyImage file\n- Implementation:\n  1. Read image file and convert to Base64 (if not already)\n  2. Call `this.openai.chat.completions.create()`:\n     - model: CONFIG.VISION_MODEL ('gpt-4o')\n     - messages: [\n       { role: 'system', content: QUICK_ANALYSIS_PROMPT or DETAILED_ANALYSIS_PROMPT }\n       { role: 'user', content: [\n         { type: 'image_url', image_url: { url: `data:image/png;base64,${imageBase64}` } }\n       ]}\n     ]\n     - response_format: { type: 'json_object' }\n     - max_tokens: depth === 'quick' ? 500 : 2000\n  3. Parse response.choices[0].message.content as JSON\n  4. Validate against ImageAnalysis schema\n  5. Return ImageAnalysis object\n\n**Method: analyzeMultiple(images, depth)**\n- Input: Array of { base64, position } objects\n- Use Promise.all with rate limiting (max CONFIG.VISION_RATE_LIMIT_PER_MINUTE calls/min)\n- Implement backoff if rate limited\n- Return array of ImageAnalysis objects\n\n**Method: extractCharacters(analysis)**\n- Optional: Deep-dive character extraction\n- Can call another Vision API pass if needed for more detail\n\n#### PromptGenerationService (NEW FILE - `backend/src/services/promptGenerationService.ts`)\n\n**Constructor:**\n```typescript\nconstructor() {\n  this.openai = new OpenAI({ apiKey: CONFIG.OPENAI_API_KEY });\n}\n```\n\n**Method: generatePanelPrompts(request: GeneratePromptsRequest)**\n\nInput:\n```typescript\nGeneratePromptsRequest {\n  storyPrompt: string;           // User's story\n  panelCount: number;            // Total panels to generate\n  characterConsistency: boolean; // Whether to maintain character consistency\n}\n```\n\nImplementation:\n1. **Story Breakdown Phase:**\n   - Call GPT-4o to split story into N panel beats\n   - System prompt should guide structure like:\n   ```\n   \"You are a manga story expert. Break the provided story into exactly {panelCount}\n    distinct visual beats. Each beat should be 1-2 sentences describing what happens\n    visually in that panel. Format as JSON array of objects with 'panelIndex' and 'beat' fields.\"\n   ```\n\n2. **Character Consistency Analysis:**\n   - If characterConsistency=true and keyImages were analyzed:\n     - Retrieve stored ImageAnalysis for key images\n     - Create character consistency profile (appearance, emotion arcs, etc.)\n     - Include in subsequent prompts\n\n3. **DALL-E 3 Prompt Generation:**\n   - For each story beat, create detailed DALL-E 3 prompt\n   - System prompt pattern:\n   ```\n   \"You are a DALL-E 3 prompt expert specializing in manga panels.\n    Given a story beat, generate a detailed visual prompt (100-300 words) that:\n    - Specifies art style: {generationSettings.imageStyle}\n    - Maintains character consistency: {characterProfile}\n    - Follows manga composition principles\n    - Uses specific visual terms (angle, lighting, pose, emotion)\n    - Avoids abstract concepts; be concrete and visual\n    - Follows DALL-E 3 content policy\n\n    Return JSON with: { dallePrompt, visualFocus, transitionType, suggestedDialogue }\"\n   ```\n\n4. **Transition Logic:**\n   - Analyze flow between consecutive beats\n   - Suggest transition type ('cut', 'pan', 'zoom_in', etc.)\n   - Update imageUrl in previous panel to support transitions\n\n5. **Return Value:**\n   - Array of PanelPrompt objects, one per panel\n   - Each with populated dallePrompt, storyBeat, visualFocus, transitionType\n\n### Database Integration\n\nAfter generating prompts, save to Panel table:\n- Update each panel's `prompt` field with `dallePrompt`\n- Update `storyBeat` field\n- Update `status` to 'pending' (ready for image generation)\n\n### API Integration\n\nImplement route handlers in `backend/src/routes/manga.ts`:\n\n**POST /api/manga/:projectId/analyze**\n```typescript\n// 1. Fetch project and keyImages from DB\n// 2. Read image files and convert to Base64\n// 3. Call imageAnalysisService.analyzeMultiple()\n// 4. Store analysis results in DB (keyImages.analysis)\n// 5. Update project status to 'analyzing'  'complete'\n// 6. Return analysis results\n```\n\n**POST /api/manga/:projectId/generate-prompts**\n```typescript\n// 1. Validate GeneratePromptsRequest\n// 2. Fetch project and keyImages analyses from DB\n// 3. Call promptGenerationService.generatePanelPrompts()\n// 4. Update panel records with generated prompts\n// 5. Update project status to 'generating'\n// 6. Return array of PanelPrompt objects\n```\n\n### Testing Requirements\n\n```bash\n# 1. Prepare test image\n# (Use any PNG/JPG with a character or scene)\n\n# 2. Create project and upload image (Task 1)\nPROJECT_ID=$(curl -s -X POST http://localhost:5000/api/manga/create \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"projectName\":\"Test\",\"storyPrompt\":\"A hero finds treasure\"}' | jq -r '.id')\n\n# 3. Upload test image\ncurl -X POST http://localhost:5000/api/manga/$PROJECT_ID/upload \\\n  -F \"images=@test_image.jpg\"\n\n# 4. Analyze images\ncurl -X POST http://localhost:5000/api/manga/$PROJECT_ID/analyze \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"analysisDepth\":\"quick\"}'\n\n# 5. Generate prompts\ncurl -X POST http://localhost:5000/api/manga/$PROJECT_ID/generate-prompts \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\n    \"storyPrompt\": \"A hero finds treasure in a dark cave\",\n    \"panelCount\": 4,\n    \"characterConsistency\": true\n  }'\n\n# 6. Verify output\ncurl http://localhost:5000/api/manga/$PROJECT_ID | jq '.panels[].prompt'\n```\n\n### Files This Task Provides to Other Agents\n\n- **Panel prompt data** - Stored in DB panels table, used by Task 3 for image generation\n- **Character analysis** - Used by Task 5 frontend for display\n- **Art style consistency** - Guides Task 3's image generation\n\n### Output Validation Checklist\n\n- [ ] ImageAnalysisService.analyzeImage() calls Vision API successfully\n- [ ] Vision API responses parse correctly to ImageAnalysis\n- [ ] PromptGenerationService generates DALL-E-compatible prompts\n- [ ] Panel prompts maintain character consistency (if enabled)\n- [ ] Transition types are correctly assigned\n- [ ] All panel records updated in database with prompts\n- [ ] /analyze endpoint returns ImageAnalysis array\n- [ ] /generate-prompts endpoint returns PanelPrompt array\n- [ ] Error handling for API failures (rate limits, auth, etc.)\n- [ ] No TypeScript compilation errors\n\n---\n\n## Task 3: DALL-E 3 (Agent C)\n### Image Generation with Retry Logic & Progress Streaming\n\n**Time Estimate:** 50-70 minutes\n**Difficulty:** Intermediate-Advanced\n**Dependencies:** Task 1 (DB & API), Task 2 (panel prompts)\n\n### Objective\nImplement DALL-E 3 image generation with robust error handling, exponential backoff retry logic, local image storage, Server-Sent Events (SSE) streaming for real-time progress updates, and cost tracking per API call.\n\n### Target Files to Create/Modify\n\n```\nbackend/\n src/\n     services/\n         imageGenerationService.ts    [IMPLEMENT] DALL-E 3 API integration\n         (imageProcessor.ts)          [REFERENCE] Utility for image processing\n```\n\n### TypeScript Interfaces\n\n```typescript\nGeneratedPanel {\n  panelIndex: number;\n  imageUrl: string;              // DALL-E public URL (temporary)\n  localFilePath: string;         // /uploads/{projectId}/panel_{index}.png\n  prompt: string;                // Original prompt sent\n  revisedPrompt?: string;        // DALL-E 3's revised prompt (if modified)\n  costUsd: number;               // API call cost\n}\n\n// Request type\nGenerateImagesRequest {\n  panelIndices?: number[];       // undefined = all panels\n  batchMode: 'sequential' | 'parallel';\n}\n\n// Progress event (sent via SSE)\nProgressEvent {\n  type: 'progress' | 'complete' | 'error';\n  stage: string;                 // 'generating_images'\n  currentStep: number;           // Current panel index\n  totalSteps: number;            // Total panels\n  percentage: number;            // 0-100\n  message: string;               // Human-readable status\n  panelId?: string;\n  panelIndex?: number;\n  error?: string;                // Error message if type='error'\n}\n```\n\n### Implementation Details\n\n#### ImageGenerationService (`backend/src/services/imageGenerationService.ts`)\n\n**Constructor & Initialization:**\n```typescript\nconstructor() {\n  this.openai = new OpenAI({ apiKey: CONFIG.OPENAI_API_KEY });\n  this.uploadDir = path.resolve(CONFIG.STORAGE_PATH);\n}\n```\n\n**Method: generatePanel() - Single Panel Generation**\n\n```typescript\nasync generatePanel(\n  prompt: string,\n  panelIndex: number,\n  projectId: string,\n  settings?: GenerationSettings\n): Promise<GeneratedPanel>\n```\n\nImplementation:\n1. **Image Size Calculation:**\n   - Map aspectRatio to DALL-E 3 size:\n     - 'square'  '1024x1024'\n     - 'wide'  '1792x1024'\n     - 'tall'  '1024x1792'\n\n2. **API Call (with retry logic in wrapper):**\n   ```typescript\n   const response = await this.openai.images.generate({\n     model: CONFIG.DALLE_MODEL,           // 'dall-e-3'\n     prompt: prompt,\n     n: 1,\n     size: size,\n     quality: settings?.qualityLevel === 'hd' ? 'hd' : 'standard',\n     style: 'natural',                    // or 'vivid' for more dramatic\n   });\n   ```\n\n3. **Extract Response Data:**\n   - imageUrl = response.data[0].url\n   - revisedPrompt = response.data[0].revised_prompt\n   - Calculate cost based on settings.qualityLevel:\n     - standard: $0.040 per image\n     - hd: $0.080 per image\n\n4. **Download & Save Image:**\n   - Call this.downloadAndSave(imageUrl, projectId, panelIndex)\n   - Saves as PNG: `{STORAGE_PATH}/{projectId}/panel_{panelIndex}.png`\n   - Returns localFilePath\n\n5. **Return GeneratedPanel object**\n\n**Method: generateBatch() - Batch Generation with Mode Selection**\n\n```typescript\nasync generateBatch(\n  panelPrompts: PanelPrompt[],\n  projectId: string,\n  batchMode: 'sequential' | 'parallel',\n  settings?: GenerationSettings,\n  onProgress?: (event: ProgressEvent) => void\n): Promise<GeneratedPanel[]>\n```\n\nImplementation:\n1. Validate inputs\n2. Route to sequential or parallel handler\n3. Call onProgress callback with progress events\n4. Return array of GeneratedPanel\n\n**Method: generateSequential() - Rate-Limit Friendly**\n\n```typescript\nprivate async generateSequential(\n  panelPrompts: PanelPrompt[],\n  projectId: string,\n  settings?: GenerationSettings,\n  onProgress?: (event: ProgressEvent) => void\n): Promise<GeneratedPanel[]>\n```\n\nImplementation:\n1. Initialize results array\n2. For each panelPrompt (with index):\n   a. Call generatePanelWithRetry(panelPrompt, projectId, settings)\n   b. On success:\n      - Add to results array\n      - Call onProgress with percentage = (index + 1) / total * 100\n   c. On failure (after max retries):\n      - Update panel status to 'failed' in DB\n      - Log error\n      - Continue to next panel\n\n3. Return results array (may include failed panels with status='failed')\n\n**Method: generateParallel() - High Speed (Rate Limit Aware)**\n\n```typescript\nprivate async generateParallel(\n  panelPrompts: PanelPrompt[],\n  projectId: string,\n  settings?: GenerationSettings,\n  onProgress?: (event: ProgressEvent) => void\n): Promise<GeneratedPanel[]>\n```\n\nImplementation:\n1. **Batch Control:**\n   - Max concurrent = Math.floor(CONFIG.DALLE_RATE_LIMIT_PER_MINUTE / 2)\n   - Split panelPrompts into batches of max concurrent\n\n2. **For each batch:**\n   - Create Promise.allSettled() for batch\n   - Wait for all to settle\n   - Process results\n   - Send progress update to onProgress\n   - Delay before next batch (respect rate limits)\n\n3. **Failure Handling:**\n   - Collect failed panels\n   - Retry failed panels sequentially (exponential backoff)\n   - Update onProgress for retries\n\n4. **Return results array**\n\n**Method: generatePanelWithRetry() - Core Retry Logic**\n\n```typescript\nprivate async generatePanelWithRetry(\n  panelPrompt: PanelPrompt,\n  projectId: string,\n  settings?: GenerationSettings,\n  retryCount: number = 0\n): Promise<GeneratedPanel>\n```\n\nImplementation:\n1. Try to generate panel via generatePanel()\n2. On success: Return GeneratedPanel\n3. On failure:\n   - If retryCount < CONFIG.MAX_RETRIES_PER_PANEL:\n     - Calculate backoff delay: 2^retryCount * 1000ms (exponential)\n     - Wait for delay\n     - Recursively call with retryCount++\n   - If max retries exceeded:\n     - Throw error with panel index info\n\n**Exponential Backoff Formula:**\n```\ndelay(attempt) = base_delay * (2 ^ attempt) + random jitter\ndelay(0) = 1000ms (1 second)\ndelay(1) = 2000ms (2 seconds)\ndelay(2) = 4000ms (4 seconds)\n+ add random(0, 500ms) jitter to avoid thundering herd\n```\n\n**Method: downloadAndSave() - Store Images Locally**\n\n```typescript\nprivate async downloadAndSave(\n  imageUrl: string,\n  projectId: string,\n  panelIndex: number\n): Promise<string>\n```\n\nImplementation:\n1. Create project uploads directory if not exists: `{STORAGE_PATH}/{projectId}/`\n2. Fetch image from URL using axios or native fetch:\n   ```typescript\n   const response = await fetch(imageUrl);\n   const arrayBuffer = await response.arrayBuffer();\n   const buffer = Buffer.from(arrayBuffer);\n   ```\n3. Save to disk:\n   ```typescript\n   const filePath = path.join(this.uploadDir, projectId, `panel_${panelIndex}.png`);\n   await fs.writeFile(filePath, buffer);\n   ```\n4. Return relative or absolute path\n\n**Method: getImageSize() - Aspect Ratio to DALL-E Size**\n\n```typescript\nprivate getImageSize(\n  aspectRatio: string\n): '1024x1024' | '1792x1024' | '1024x1792'\n```\n\nSelf-explanatory mapping function.\n\n### Route Handler Integration\n\nImplement in `backend/src/routes/manga.ts`:\n\n**POST /api/manga/:projectId/generate-images - SSE Streaming**\n\n```typescript\nrouter.post('/:projectId/generate-images', async (req, res, next) => {\n  try {\n    const { projectId } = req.params;\n    const { panelIndices, batchMode } = req.body as GenerateImagesRequest;\n\n    // Set up SSE response\n    res.setHeader('Content-Type', 'text/event-stream');\n    res.setHeader('Cache-Control', 'no-cache');\n    res.setHeader('Connection', 'keep-alive');\n\n    // Fetch project and panels from DB\n    const project = await getProject(projectId);\n    if (!project) throw new NotFoundError('Project');\n\n    // Filter panels (all or specific indices)\n    const panelsToGenerate = project.panels.filter(\n      p => !panelIndices || panelIndices.includes(p.panelIndex)\n    );\n\n    // Generate prompts array\n    const panelPrompts: PanelPrompt[] = panelsToGenerate.map(p => ({\n      panelIndex: p.panelIndex,\n      dallePrompt: p.prompt!,\n      storyBeat: p.storyBeat!,\n      visualFocus: 'main subject',  // Extract from context if available\n      transitionType: 'cut',        // Default, could be from DB\n    }));\n\n    // Call imageGenerationService\n    imageGenService.generateBatch(\n      panelPrompts,\n      projectId,\n      batchMode,\n      project.generationSettings,\n      (progressEvent) => {\n        // Send progress as SSE\n        res.write(`data: ${JSON.stringify(progressEvent)}\\n\\n`);\n      }\n    ).then(generatedPanels => {\n      // Update database with generated images\n      for (const panel of generatedPanels) {\n        updatePanelImage(panel.panelIndex, {\n          imageUrl: panel.imageUrl,\n          imageFilePath: panel.localFilePath,\n          revisedPrompt: panel.revisedPrompt,\n          status: panel.revisedPrompt ? 'generated' : 'generated',\n        });\n      }\n\n      // Send completion event\n      res.write(`data: ${JSON.stringify({\n        type: 'complete',\n        message: 'Image generation complete',\n        totalCost: generatedPanels.reduce((sum, p) => sum + p.costUsd, 0),\n      })}\\n\\n`);\n\n      res.end();\n    }).catch(err => {\n      res.write(`data: ${JSON.stringify({\n        type: 'error',\n        message: err.message,\n      })}\\n\\n`);\n      res.end();\n    });\n  } catch (err) {\n    next(err);\n  }\n});\n```\n\n### Cost Tracking\n\n**Implementation:**\n- Track cost per API call in GeneratedPanel.costUsd\n- Sum across all panels: `totalCost = sum(generatedPanels.map(p => p.costUsd))`\n- Update project.totalCost in DB: `project.totalCost += generatedPanels totalCost`\n- Log costs for each call (useful for budget monitoring)\n\n**Cost Constants (from types.ts):**\n```typescript\nAPI_COSTS = {\n  VISION_PER_CALL: 0.025,    // GPT-4V\n  DALLE3_STANDARD: 0.040,    // per image\n  DALLE3_HD: 0.080,          // per image\n}\n```\n\n### Testing Requirements\n\n```bash\n# 1. Set up test project (with prompts from Task 2)\nPROJECT_ID=\"test-project-id\"\n# Or use output from Task 2 test\n\n# 2. Generate images (sequential mode)\ncurl -X POST http://localhost:5000/api/manga/$PROJECT_ID/generate-images \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"batchMode\": \"sequential\"}' \\\n  -H \"Accept: text/event-stream\"\n\n# 3. Verify local image files created\nls -la uploads/$PROJECT_ID/\n\n# 4. Check database for updated image URLs\nsqlite3 data/koma-fill.db \"SELECT panelIndex, imageFilePath, status FROM panels WHERE projectId='$PROJECT_ID';\"\n\n# 5. Verify cost tracking\ncurl http://localhost:5000/api/manga/$PROJECT_ID | jq '.totalCost'\n```\n\n### Files This Task Provides to Other Agents\n\n- **Generated panel images** - Stored in uploads/{projectId}/, used by Task 4\n- **Image file paths** - Updated in DB, used by Task 4 for layout composition\n- **Cost tracking** - Used by frontend for budget display\n\n### Output Validation Checklist\n\n- [ ] DALL-E 3 API calls succeed with valid prompts\n- [ ] Retry logic works with exponential backoff\n- [ ] Images download and save to {STORAGE_PATH}/{projectId}/\n- [ ] SSE streaming sends progress events correctly\n- [ ] onProgress callback fires with accurate percentage\n- [ ] Cost calculation correct (0.04 standard, 0.08 HD)\n- [ ] Panel records updated with imageUrl and imageFilePath\n- [ ] Sequential and parallel modes both work\n- [ ] Rate limiting respected (max 5 calls/min by default)\n- [ ] Error handling for network issues, API failures\n- [ ] No TypeScript compilation errors\n\n---\n\n## Task 4: + (Agent D)\n### Manga Layout Composition & Multi-Format Export\n\n**Time Estimate:** 45-60 minutes\n**Difficulty:** Intermediate (Sharp library learning curve)\n**Dependencies:** Task 1 (DB), Task 3 (generated images)\n\n### Objective\nImplement Sharp-based manga layout composition with grid calculation, panel resizing and positioning, border/gutter rendering, speech bubble overlay, and PNG/JPG/PDF export functionality.\n\n### Target Files to Create/Modify\n\n```\nbackend/\n src/\n     services/\n        layoutEngine.ts          [IMPLEMENT] Panel composition & layout\n        exportService.ts         [CREATE] PNG/JPG/PDF export\n     utils/\n         imageProcessor.ts        [HELPER] Image processing utilities\n```\n\n### TypeScript Interfaces\n\n```typescript\n// Layout composition result\nComposedLayout {\n  buffer: Buffer;                    // PNG image buffer\n  width: number;                     // Page width (px)\n  height: number;                    // Page height (px)\n  format: 'png';\n  panelPositions: PanelPosition[];   // Position data for each panel\n}\n\nPanelPosition {\n  panelIndex: number;\n  x: number;                         // Offset from top-left (px)\n  y: number;\n  width: number;                     // Panel width (px)\n  height: number;                    // Panel height (px)\n}\n\n// Input to layout engine\nLayoutConfig {\n  totalPanels: number;               // 4, 6, 8, etc.\n  format: LayoutFormat;              // 'vertical' | 'horizontal' | 'square'\n  readingOrder: ReadingOrder;        // 'japanese' | 'western'\n  gutterSize: number;                // Space between panels (px)\n  borderWidth: number;               // Panel border thickness (px)\n  borderColor: string;               // Hex color\n  backgroundColor: string;           // Hex color\n  pageWidth: number;                 // Canvas width (px)\n  pageHeight: number;                // Canvas height (px)\n}\n```\n\n### Implementation Details\n\n#### LayoutEngine (`backend/src/services/layoutEngine.ts`)\n\n**Method: composePanels() - Main Composition Function**\n\n```typescript\nasync composePanels(\n  panelImagePaths: string[],\n  config: LayoutConfig = DEFAULT_LAYOUT_CONFIG\n): Promise<ComposedLayout>\n```\n\nImplementation Steps:\n\n1. **Calculate Grid:**\n   ```typescript\n   const grid = this.calculateGrid(panelImagePaths.length, config);\n   // Returns { cols: number, rows: number }\n   ```\n   Already implemented - use it.\n\n2. **Calculate Panel Positions:**\n   ```typescript\n   const positions = this.calculatePanelPositions(grid, config);\n   // Returns: PanelPosition[] with x, y, width, height for each panel\n   ```\n   Already implemented - use it.\n\n3. **Create Background Canvas:**\n   ```typescript\n   import sharp from 'sharp';\n\n   let canvas = sharp({\n     create: {\n       width: config.pageWidth,\n       height: config.pageHeight,\n       channels: 4,                    // RGBA\n       background: config.backgroundColor,  // Parsed from hex\n     }\n   });\n   ```\n\n4. **Load & Resize Panel Images:**\n   ```typescript\n   const composites = await Promise.all(\n     panelImagePaths.map(async (imgPath, i) => {\n       if (!fs.existsSync(imgPath)) {\n         throw new Error(`Panel image not found: ${imgPath}`);\n       }\n\n       const position = positions[i];\n       const resized = await sharp(imgPath)\n         .resize(position.width, position.height, {\n           fit: 'cover',              // Fill panel, crop if needed\n           withoutEnlargement: false\n         })\n         .toBuffer();\n\n       return {\n         input: resized,\n         left: position.x,\n         top: position.y\n       };\n     })\n   );\n   ```\n\n5. **Composite Panels Onto Canvas:**\n   ```typescript\n   let result = await canvas.composite(composites).png();\n   ```\n\n6. **Add Borders (Optional - if borderWidth > 0):**\n   - Use SVG overlay to draw rectangles around each panel\n   - Create SVG:\n     ```svg\n     <svg width=\"800\" height=\"1200\">\n       <!-- For each panel position -->\n       <rect x=\"10\" y=\"10\" width=\"390\" height=\"590\"\n             fill=\"none\" stroke=\"black\" stroke-width=\"2\" />\n     </svg>\n     ```\n   - Composite SVG overlay:\n     ```typescript\n     const borderSvg = this.generateBorderSvg(positions, config);\n     result = await result.composite([{\n       input: borderSvg,\n       top: 0,\n       left: 0\n     }]);\n     ```\n\n7. **Return ComposedLayout:**\n   ```typescript\n   const buffer = await result.toBuffer();\n   return {\n     buffer,\n     width: config.pageWidth,\n     height: config.pageHeight,\n     format: 'png',\n     panelPositions: positions\n   };\n   ```\n\n**Method: addSpeechBubbles() - Overlay Speech Bubbles**\n\n```typescript\nasync addSpeechBubbles(\n  layout: ComposedLayout,\n  bubbles: SpeechBubble[]\n): Promise<ComposedLayout>\n```\n\nImplementation:\n\n1. **For each speech bubble:**\n   - Get panel position from layout.panelPositions[bubble.panelIndex]\n   - Calculate bubble position within panel:\n     - 'top'  y = panel.y + 30\n     - 'middle'  y = panel.y + panel.height/2 - 30\n     - 'bottom'  y = panel.y + panel.height - 60\n\n2. **Create SVG speech bubble:**\n   ```typescript\n   const svg = this.generateSpeechBubbleSvg(bubble, position, style);\n   // Generates SVG with text, shape varies by style:\n   // 'rounded', 'cloud', 'spiked', 'rectangular'\n   ```\n\n3. **Composite all bubble SVGs:**\n   ```typescript\n   let result = sharp(layout.buffer);\n   const bubbleSvgs = bubbles.map((bubble, idx) =>\n     this.generateSpeechBubbleSvg(bubble, panelPositions[bubble.panelIndex])\n   );\n\n   result = await result.composite(\n     bubbleSvgs.map((svg, i) => ({ input: svg }))\n   );\n   ```\n\n4. **Return updated ComposedLayout**\n\n**Helper: generateBorderSvg()**\n```typescript\nprivate generateBorderSvg(\n  positions: PanelPosition[],\n  config: LayoutConfig\n): Buffer\n```\n\nGenerate SVG with rectangle borders around each panel:\n```svg\n<svg width=\"800\" height=\"1200\">\n  <rect x=\"10\" y=\"10\" width=\"390\" height=\"590\"\n        fill=\"none\" stroke=\"#000000\" stroke-width=\"2\" />\n  <!-- repeated for each panel -->\n</svg>\n```\n\nConvert to Buffer and return.\n\n**Helper: generateSpeechBubbleSvg()**\n```typescript\nprivate generateSpeechBubbleSvg(\n  bubble: SpeechBubble,\n  panelPosition: PanelPosition,\n  targetY: number  // top/middle/bottom\n): Buffer\n```\n\nGenerate SVG with speech bubble shape. Example for 'rounded':\n```svg\n<svg width=\"300\" height=\"100\">\n  <!-- Rounded rectangle -->\n  <path d=\"M 10,10 Q 10,10 20,10 L 270,10 Q 280,10 280,20 L 280,70 Q 280,80 270,80 L 30,80 Q 20,80 20,70 L 20,40 L 0,60 L 20,50 L 20,20 Q 20,10 10,10\"\n        fill=\"white\" stroke=\"black\" stroke-width=\"1\" />\n  <text x=\"20\" y=\"50\" font-family=\"Arial\" font-size=\"14\">Your text here</text>\n</svg>\n```\n\nReturn SVG as Buffer via:\n```typescript\nconst svgBuffer = Buffer.from(svgString, 'utf-8');\n```\n\n### ExportService (`backend/src/services/exportService.ts`) - NEW FILE\n\nImplement export to PNG, JPG, PDF formats.\n\n```typescript\nexport class ExportService {\n  async exportPNG(\n    layout: ComposedLayout,\n    filepath: string,\n    compression: 'low' | 'medium' | 'high'\n  ): Promise<void>\n\n  async exportJPG(\n    layout: ComposedLayout,\n    filepath: string,\n    quality: number  // 60-95\n  ): Promise<void>\n\n  async exportPDF(\n    layout: ComposedLayout,\n    filepath: string,\n    metadata: { title?: string; author?: string }\n  ): Promise<void>\n}\n```\n\n**exportPNG():**\n```typescript\nasync exportPNG(layout, filepath, compression) {\n  const compressionLevel = compression === 'high' ? 9 : compression === 'medium' ? 6 : 1;\n  await sharp(layout.buffer)\n    .png({ compressionLevel })\n    .toFile(filepath);\n}\n```\n\n**exportJPG():**\n```typescript\nasync exportJPG(layout, filepath, quality = 80) {\n  await sharp(layout.buffer)\n    .jpeg({ quality, mozjpeg: true })\n    .toFile(filepath);\n}\n```\n\n**exportPDF():**\nRequires pdfkit library:\n```typescript\nimport PDFDocument from 'pdfkit';\nimport { createWriteStream } from 'fs';\n\nasync exportPDF(layout, filepath, metadata = {}) {\n  const doc = new PDFDocument({\n    size: [layout.width, layout.height]\n  });\n\n  if (metadata.title) doc.title(metadata.title);\n  if (metadata.author) doc.author(metadata.author);\n\n  // Add image to PDF\n  doc.image(layout.buffer, 0, 0, {\n    width: layout.width,\n    height: layout.height\n  });\n\n  doc.pipe(createWriteStream(filepath));\n  doc.end();\n}\n```\n\n### Route Handler Integration\n\nImplement in `backend/src/routes/manga.ts`:\n\n**POST /api/manga/:projectId/layout**\n```typescript\nrouter.post('/:projectId/layout', async (req: Request, res: Response, next: NextFunction) => {\n  try {\n    const { projectId } = req.params;\n    const { speechBubbles } = req.body as GenerateLayoutRequest;\n\n    // Fetch project and panels from DB\n    const project = await getProject(projectId);\n    if (!project) throw new NotFoundError('Project');\n\n    // Get panel image paths\n    const panelPaths = project.panels\n      .sort((a, b) => a.panelIndex - b.panelIndex)\n      .map(p => p.imageFilePath)\n      .filter(path => path !== undefined);\n\n    // Compose layout\n    const layoutEngine = new LayoutEngine();\n    let layout = await layoutEngine.composePanels(panelPaths, project.layoutConfig);\n\n    // Add speech bubbles if provided\n    if (speechBubbles && speechBubbles.length > 0) {\n      layout = await layoutEngine.addSpeechBubbles(layout, speechBubbles);\n    }\n\n    // Save layout buffer to temporary file for preview\n    const layoutPath = path.join(CONFIG.STORAGE_PATH, projectId, 'layout.png');\n    await fs.writeFile(layoutPath, layout.buffer);\n\n    // Update project status\n    await updateProject(projectId, { status: 'complete' });\n\n    // Return layout info\n    res.json({\n      message: 'Layout composed successfully',\n      projectId,\n      layoutPath: `/uploads/${projectId}/layout.png`,\n      panelPositions: layout.panelPositions,\n      dimensions: { width: layout.width, height: layout.height }\n    });\n  } catch (err) {\n    next(err);\n  }\n});\n```\n\n**POST /api/manga/:projectId/export**\n```typescript\nrouter.post('/:projectId/export', async (req: Request, res: Response, next: NextFunction) => {\n  try {\n    const { projectId } = req.params;\n    const { format, compression, resolution, title, author } = req.body as ExportRequest;\n\n    // Fetch project layout\n    const layoutPath = path.join(CONFIG.STORAGE_PATH, projectId, 'layout.png');\n    if (!fs.existsSync(layoutPath)) {\n      throw new Error('Layout not yet generated. Call /layout endpoint first.');\n    }\n\n    const layoutBuffer = await fs.promises.readFile(layoutPath);\n    const layout: ComposedLayout = {\n      buffer: layoutBuffer,\n      width: 800,  // From project.layoutConfig\n      height: 1200,\n      format: 'png',\n      panelPositions: []  // Could fetch from DB if needed\n    };\n\n    // Export to requested format\n    const exportService = new ExportService();\n    const timestamp = Date.now();\n    const exportPath = path.join(CONFIG.STORAGE_PATH, projectId, `manga_${timestamp}.${format}`);\n\n    if (format === 'png') {\n      await exportService.exportPNG(layout, exportPath, compression as 'low' | 'medium' | 'high');\n    } else if (format === 'jpg') {\n      const qualityMap = { low: 60, medium: 80, high: 95 };\n      await exportService.exportJPG(layout, exportPath, qualityMap[compression]);\n    } else if (format === 'pdf') {\n      await exportService.exportPDF(layout, exportPath, { title, author });\n    }\n\n    // Update project status\n    await updateProject(projectId, { status: 'exported' });\n\n    res.json({\n      message: 'Export successful',\n      projectId,\n      format,\n      downloadUrl: `/uploads/${projectId}/manga_${timestamp}.${format}`,\n      filePath: exportPath\n    });\n  } catch (err) {\n    next(err);\n  }\n});\n```\n\n### Testing Requirements\n\n```bash\n# 1. Generate layout from Task 3 images\nPROJECT_ID=\"test-project-id\"\ncurl -X POST http://localhost:5000/api/manga/$PROJECT_ID/layout \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\n    \"speechBubbles\": [\n      {\n        \"panelIndex\": 0,\n        \"text\": \"Wow!\",\n        \"position\": \"top\",\n        \"style\": \"rounded\"\n      }\n    ]\n  }'\n\n# 2. View composed layout\nopen http://localhost:5000/uploads/$PROJECT_ID/layout.png\n\n# 3. Export to PNG\ncurl -X POST http://localhost:5000/api/manga/$PROJECT_ID/export \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\n    \"format\": \"png\",\n    \"compression\": \"medium\",\n    \"resolution\": \"web\",\n    \"title\": \"My Manga\"\n  }'\n\n# 4. Export to PDF\ncurl -X POST http://localhost:5000/api/manga/$PROJECT_ID/export \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\n    \"format\": \"pdf\",\n    \"compression\": \"medium\",\n    \"title\": \"My Manga\",\n    \"author\": \"AI Creator\"\n  }'\n\n# 5. Verify files exist\nls -lh uploads/$PROJECT_ID/\n```\n\n### Files This Task Provides to Other Agents\n\n- **Composed layout image** - Used by frontend for preview\n- **Export files** - PNG/JPG/PDF outputs for download\n- **Layout metadata** - Panel positions for debugging/display\n\n### Output Validation Checklist\n\n- [ ] calculateGrid() and calculatePanelPositions() methods work correctly\n- [ ] composePanels() successfully combines images with sharp\n- [ ] Borders render correctly around panels\n- [ ] Speech bubbles overlay without distortion\n- [ ] Multiple speech bubble styles work ('rounded', 'cloud', 'spiked', 'rectangular')\n- [ ] Layout PNG saved and readable\n- [ ] exportPNG() produces valid PNG files\n- [ ] exportJPG() produces valid JPG files with quality control\n- [ ] exportPDF() produces valid PDF with metadata\n- [ ] /layout endpoint returns correct panel positions\n- [ ] /export endpoint returns download URLs\n- [ ] Compression settings affect file size appropriately\n- [ ] No TypeScript compilation errors\n\n---\n\n## Task 5: React (Agent E)\n### Complete React UI with Component Implementation\n\n**Time Estimate:** 60-80 minutes\n**Difficulty:** Intermediate (React component patterns)\n**Dependencies:** Tasks 1-4 (backend API must be running)\n\n### Objective\nComplete all React components for the koma-fill frontend including image upload with drag-drop, story prompt editor, panel grid with drag-and-drop reordering, complete manga generation workflow orchestration, real-time SSE progress updates, and multi-format export options. Configure Tailwind CSS for styling.\n\n### Target Files to Create/Modify\n\n```\nfrontend/\n src/\n    components/\n       ImageUploader.tsx           [IMPLEMENT] Dropzone with position selector\n       StoryPromptEditor.tsx       [ENHANCE] Add sample prompts\n       PanelGrid.tsx               [IMPLEMENT] Drag-and-drop reordering\n       LayoutSelector.tsx          [VERIFY] Layout config UI\n       ExportOptions.tsx           [VERIFY] Export format selection\n       ProgressBar.tsx             [CREATE] Real-time progress display\n    hooks/\n       useMangaGeneration.ts       [IMPLEMENT] Full workflow orchestration\n    services/\n       apiClient.ts                [IMPLEMENT] API client with SSE support\n    pages/\n       CreateMangaPage.tsx         [IMPLEMENT] Main workflow page\n       PreviewPage.tsx             [IMPLEMENT] Result preview & download\n    App.tsx                         [UPDATE] Routing\n    main.tsx                        [VERIFY] Entry point\n    index.css                       [UPDATE] Tailwind directives\n tailwind.config.js                  [CREATE] Tailwind configuration\n postcss.config.js                   [CREATE] PostCSS configuration\n package.json                        [UPDATE] Add Tailwind dependencies\n tsconfig.json                       [VERIFY] TypeScript config\n```\n\n### TypeScript Interfaces (from `frontend/src/types/index.ts`)\n\nAlready defined - reference for component props.\n\n### Implementation Details\n\n#### 1. Tailwind CSS Setup\n\n**Install Dependencies:**\n```bash\ncd frontend\nnpm install -D tailwindcss postcss autoprefixer\nnpx tailwindcss init -p\n```\n\n**tailwind.config.js:**\n```javascript\nexport default {\n  content: [\n    './index.html',\n    './src/**/*.{js,ts,jsx,tsx}',\n  ],\n  theme: {\n    extend: {\n      colors: {\n        manga: {\n          dark: '#1a1a1a',\n          light: '#f5f5f5',\n        }\n      }\n    },\n  },\n  plugins: [],\n}\n```\n\n**postcss.config.js:**\n```javascript\nexport default {\n  plugins: {\n    tailwindcss: {},\n    autoprefixer: {},\n  },\n}\n```\n\n**frontend/src/index.css:**\n```css\n@tailwind base;\n@tailwind components;\n@tailwind utilities;\n\n@layer components {\n  .btn-primary {\n    @apply px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700 transition;\n  }\n  .btn-secondary {\n    @apply px-4 py-2 bg-gray-300 text-gray-800 rounded-lg hover:bg-gray-400 transition;\n  }\n  .input-field {\n    @apply w-full px-3 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500;\n  }\n}\n```\n\n#### 2. API Client (`frontend/src/services/apiClient.ts`)\n\n```typescript\nimport { MangaProject, Panel, GenerationProgress, ProgressEvent } from '../types';\n\nconst API_BASE = import.meta.env.VITE_API_URL || 'http://localhost:5000/api';\n\nexport class APIClient {\n  /**\n   * Create new manga project\n   */\n  async createProject(name: string, storyPrompt: string, layoutConfig?: any) {\n    const response = await fetch(`${API_BASE}/manga/create`, {\n      method: 'POST',\n      headers: { 'Content-Type': 'application/json' },\n      body: JSON.stringify({\n        projectName: name,\n        storyPrompt,\n        layoutConfig\n      })\n    });\n    if (!response.ok) throw new Error(await response.text());\n    return response.json() as Promise<MangaProject>;\n  }\n\n  /**\n   * Upload key images\n   */\n  async uploadImages(projectId: string, files: File[]) {\n    const formData = new FormData();\n    files.forEach(file => formData.append('images', file));\n\n    const response = await fetch(`${API_BASE}/manga/${projectId}/upload`, {\n      method: 'POST',\n      body: formData\n    });\n    if (!response.ok) throw new Error(await response.text());\n    return response.json();\n  }\n\n  /**\n   * Analyze images using Vision API\n   */\n  async analyzeImages(projectId: string, depth: 'quick' | 'detailed' = 'quick') {\n    const response = await fetch(`${API_BASE}/manga/${projectId}/analyze`, {\n      method: 'POST',\n      headers: { 'Content-Type': 'application/json' },\n      body: JSON.stringify({ analysisDepth: depth })\n    });\n    if (!response.ok) throw new Error(await response.text());\n    return response.json();\n  }\n\n  /**\n   * Generate panel prompts\n   */\n  async generatePrompts(projectId: string, storyPrompt: string, panelCount: number) {\n    const response = await fetch(`${API_BASE}/manga/${projectId}/generate-prompts`, {\n      method: 'POST',\n      headers: { 'Content-Type': 'application/json' },\n      body: JSON.stringify({\n        storyPrompt,\n        panelCount,\n        characterConsistency: true\n      })\n    });\n    if (!response.ok) throw new Error(await response.text());\n    return response.json() as Promise<Panel[]>;\n  }\n\n  /**\n   * Generate images via DALL-E 3 (SSE streaming)\n   */\n  streamImageGeneration(\n    projectId: string,\n    batchMode: 'sequential' | 'parallel',\n    onProgress: (event: ProgressEvent) => void,\n    onError: (error: Error) => void\n  ): () => void {\n    const eventSource = new EventSource(\n      `${API_BASE}/manga/${projectId}/generate-images?batchMode=${batchMode}`\n    );\n\n    eventSource.onmessage = (event) => {\n      try {\n        const data = JSON.parse(event.data);\n        onProgress(data);\n      } catch (e) {\n        console.error('Failed to parse SSE message:', e);\n      }\n    };\n\n    eventSource.onerror = () => {\n      onError(new Error('Generation failed or connection lost'));\n      eventSource.close();\n    };\n\n    // Return cleanup function\n    return () => eventSource.close();\n  }\n\n  /**\n   * Compose layout with speech bubbles\n   */\n  async composeLayout(projectId: string, speechBubbles?: any) {\n    const response = await fetch(`${API_BASE}/manga/${projectId}/layout`, {\n      method: 'POST',\n      headers: { 'Content-Type': 'application/json' },\n      body: JSON.stringify({ speechBubbles })\n    });\n    if (!response.ok) throw new Error(await response.text());\n    return response.json();\n  }\n\n  /**\n   * Export to PNG/JPG/PDF\n   */\n  async exportManga(\n    projectId: string,\n    format: 'png' | 'jpg' | 'pdf',\n    compression: 'low' | 'medium' | 'high' = 'medium',\n    title?: string,\n    author?: string\n  ) {\n    const response = await fetch(`${API_BASE}/manga/${projectId}/export`, {\n      method: 'POST',\n      headers: { 'Content-Type': 'application/json' },\n      body: JSON.stringify({\n        format,\n        compression,\n        resolution: 'web',\n        title,\n        author\n      })\n    });\n    if (!response.ok) throw new Error(await response.text());\n    return response.json();\n  }\n\n  /**\n   * Fetch project details\n   */\n  async getProject(projectId: string) {\n    const response = await fetch(`${API_BASE}/manga/${projectId}`);\n    if (!response.ok) throw new Error(await response.text());\n    return response.json() as Promise<MangaProject>;\n  }\n\n  /**\n   * Reorder panels\n   */\n  async reorderPanels(projectId: string, panelOrder: number[]) {\n    const response = await fetch(`${API_BASE}/manga/${projectId}/reorder`, {\n      method: 'PUT',\n      headers: { 'Content-Type': 'application/json' },\n      body: JSON.stringify({ panelOrder })\n    });\n    if (!response.ok) throw new Error(await response.text());\n    return response.json();\n  }\n}\n\nexport const apiClient = new APIClient();\n```\n\n#### 3. useMangaGeneration Hook (`frontend/src/hooks/useMangaGeneration.ts`)\n\n```typescript\nimport { useState, useCallback } from 'react';\nimport { apiClient } from '../services/apiClient';\nimport { MangaProject, GenerationProgress, UploadedImage } from '../types';\n\nexport function useMangaGeneration() {\n  const [project, setProject] = useState<MangaProject | null>(null);\n  const [progress, setProgress] = useState<GenerationProgress>({\n    stage: 'idle',\n    currentStep: 0,\n    totalSteps: 0,\n    percentage: 0,\n    message: ''\n  });\n  const [error, setError] = useState<string | null>(null);\n\n  /**\n   * Complete workflow: Create  Upload  Analyze  Generate Prompts  Generate Images  Layout\n   */\n  const generateManga = useCallback(async (\n    projectName: string,\n    storyPrompt: string,\n    uploadedImages: UploadedImage[],\n    layoutConfig: any,\n    generationSettings: any\n  ) => {\n    try {\n      setError(null);\n\n      // Stage 1: Create project\n      setProgress({\n        stage: 'uploading',\n        currentStep: 0,\n        totalSteps: 5,\n        percentage: 20,\n        message: 'Creating project...'\n      });\n      const newProject = await apiClient.createProject(projectName, storyPrompt, layoutConfig);\n      setProject(newProject);\n\n      // Stage 2: Upload images\n      setProgress({\n        stage: 'uploading',\n        currentStep: 1,\n        totalSteps: 5,\n        percentage: 40,\n        message: 'Uploading reference images...'\n      });\n      const files = uploadedImages.map(img => img.file);\n      await apiClient.uploadImages(newProject.id, files);\n\n      // Stage 3: Analyze images\n      setProgress({\n        stage: 'analyzing',\n        currentStep: 2,\n        totalSteps: 5,\n        percentage: 60,\n        message: 'Analyzing images with Vision API...'\n      });\n      await apiClient.analyzeImages(newProject.id, 'detailed');\n\n      // Stage 4: Generate prompts\n      setProgress({\n        stage: 'generating_prompts',\n        currentStep: 3,\n        totalSteps: 5,\n        percentage: 70,\n        message: 'Generating panel prompts...'\n      });\n      await apiClient.generatePrompts(\n        newProject.id,\n        storyPrompt,\n        layoutConfig.totalPanels\n      );\n\n      // Stage 5: Generate images (with SSE streaming)\n      setProgress({\n        stage: 'generating_images',\n        currentStep: 4,\n        totalSteps: 5,\n        percentage: 75,\n        message: 'Starting image generation...'\n      });\n\n      await new Promise<void>((resolve, reject) => {\n        const cleanup = apiClient.streamImageGeneration(\n          newProject.id,\n          'sequential',  // or 'parallel' based on user preference\n          (progressEvent) => {\n            if (progressEvent.type === 'complete') {\n              setProgress(prev => ({\n                ...prev,\n                percentage: 90,\n                message: 'Image generation complete!'\n              }));\n              resolve();\n            } else if (progressEvent.type === 'error') {\n              reject(new Error(progressEvent.error || 'Generation failed'));\n            } else {\n              setProgress({\n                stage: 'generating_images',\n                currentStep: 4 + (progressEvent.currentStep || 0) * 0.1,\n                totalSteps: 5,\n                percentage: 75 + (progressEvent.percentage || 0) * 0.15,\n                message: progressEvent.message,\n                currentPanelIndex: progressEvent.panelIndex\n              });\n            }\n          },\n          reject\n        );\n      });\n\n      // Stage 6: Compose layout\n      setProgress({\n        stage: 'composing_layout',\n        currentStep: 5,\n        totalSteps: 5,\n        percentage: 95,\n        message: 'Composing final layout...'\n      });\n      await apiClient.composeLayout(newProject.id);\n\n      // Complete\n      const finalProject = await apiClient.getProject(newProject.id);\n      setProject(finalProject);\n      setProgress({\n        stage: 'idle',\n        currentStep: 5,\n        totalSteps: 5,\n        percentage: 100,\n        message: 'Manga generation complete!'\n      });\n\n    } catch (err) {\n      const errorMsg = err instanceof Error ? err.message : 'Unknown error';\n      setError(errorMsg);\n      setProgress({\n        stage: 'idle',\n        currentStep: 0,\n        totalSteps: 0,\n        percentage: 0,\n        message: `Error: ${errorMsg}`\n      });\n    }\n  }, []);\n\n  const exportManga = useCallback(async (\n    projectId: string,\n    format: 'png' | 'jpg' | 'pdf',\n    compression: 'low' | 'medium' | 'high' = 'medium'\n  ) => {\n    try {\n      setError(null);\n      setProgress({\n        stage: 'exporting',\n        currentStep: 0,\n        totalSteps: 1,\n        percentage: 50,\n        message: `Exporting as ${format.toUpperCase()}...`\n      });\n\n      const result = await apiClient.exportManga(projectId, format, compression);\n\n      setProgress({\n        stage: 'idle',\n        currentStep: 1,\n        totalSteps: 1,\n        percentage: 100,\n        message: 'Export complete!'\n      });\n\n      return result;\n    } catch (err) {\n      const errorMsg = err instanceof Error ? err.message : 'Export failed';\n      setError(errorMsg);\n      throw err;\n    }\n  }, []);\n\n  return {\n    project,\n    progress,\n    error,\n    generateManga,\n    exportManga,\n    setError\n  };\n}\n```\n\n#### 4. Components\n\n**ImageUploader.tsx:**\n```typescript\nimport { useCallback, useState } from 'react';\nimport { UploadedImage, ImagePosition } from '../types';\n\ninterface ImageUploaderProps {\n  onImagesSelected: (images: UploadedImage[]) => void;\n}\n\nexport function ImageUploader({ onImagesSelected }: ImageUploaderProps) {\n  const [images, setImages] = useState<UploadedImage[]>([]);\n  const [selectedPosition, setSelectedPosition] = useState<ImagePosition>('start');\n\n  const handleDrop = useCallback((e: React.DragEvent) => {\n    e.preventDefault();\n    const files = Array.from(e.dataTransfer.files).filter(f => f.type.startsWith('image/'));\n    addImages(files);\n  }, []);\n\n  const handleFileInput = (e: React.ChangeEvent<HTMLInputElement>) => {\n    if (e.target.files) {\n      addImages(Array.from(e.target.files));\n    }\n  };\n\n  const addImages = (files: File[]) => {\n    const newImages = files.map(file => ({\n      file,\n      previewUrl: URL.createObjectURL(file),\n      position: selectedPosition\n    }));\n    setImages(prev => [...prev, ...newImages]);\n    onImagesSelected([...images, ...newImages]);\n  };\n\n  const removeImage = (index: number) => {\n    const updated = images.filter((_, i) => i !== index);\n    setImages(updated);\n    onImagesSelected(updated);\n  };\n\n  return (\n    <div className=\"w-full max-w-2xl\">\n      <div\n        onDrop={handleDrop}\n        onDragOver={e => e.preventDefault()}\n        className=\"border-2 border-dashed border-gray-300 rounded-lg p-8 text-center cursor-pointer hover:border-blue-500 transition\"\n      >\n        <p className=\"text-gray-600 mb-4\">Drag and drop images here or click to select</p>\n        <input\n          type=\"file\"\n          multiple\n          accept=\"image/*\"\n          onChange={handleFileInput}\n          className=\"hidden\"\n          id=\"image-input\"\n        />\n        <label htmlFor=\"image-input\" className=\"btn-primary cursor-pointer\">\n          Select Images\n        </label>\n      </div>\n\n      <div className=\"mt-4\">\n        <label className=\"block mb-2\">Position in Story:</label>\n        <select\n          value={selectedPosition}\n          onChange={e => setSelectedPosition(e.target.value as ImagePosition)}\n          className=\"input-field\"\n        >\n          <option value=\"start\">Start (Reference)</option>\n          <option value=\"end\">End (Reference)</option>\n          <option value={1}>Panel 1</option>\n          <option value={2}>Panel 2</option>\n        </select>\n      </div>\n\n      {images.length > 0 && (\n        <div className=\"mt-6 grid grid-cols-2 gap-4\">\n          {images.map((img, idx) => (\n            <div key={idx} className=\"relative\">\n              <img src={img.previewUrl} alt={`Preview ${idx}`} className=\"rounded-lg w-full h-48 object-cover\" />\n              <button\n                onClick={() => removeImage(idx)}\n                className=\"absolute top-2 right-2 bg-red-500 text-white rounded-full w-6 h-6 flex items-center justify-center hover:bg-red-600\"\n              >\n                \n              </button>\n            </div>\n          ))}\n        </div>\n      )}\n    </div>\n  );\n}\n```\n\n**StoryPromptEditor.tsx (Enhanced):**\n```typescript\nimport { useState } from 'react';\n\ninterface StoryPromptEditorProps {\n  value: string;\n  onChange: (value: string) => void;\n}\n\nconst SAMPLE_PROMPTS = [\n  'A young ninja discovers their hidden powers and must save their village from a mysterious threat.',\n  'Two rival chefs compete in a cooking tournament, discovering they have more in common than they thought.',\n  'A time traveler must prevent a catastrophic event by gathering clues from different eras.',\n];\n\nexport function StoryPromptEditor({ value, onChange }: StoryPromptEditorProps) {\n  const [isExpanded, setIsExpanded] = useState(false);\n\n  return (\n    <div className=\"w-full max-w-2xl\">\n      <label className=\"block text-lg font-semibold mb-2\">Your Story Prompt</label>\n\n      <textarea\n        value={value}\n        onChange={e => onChange(e.target.value)}\n        placeholder=\"Write your manga story here. Be descriptive about characters, setting, and plot...\"\n        className=\"input-field h-32 resize-none\"\n      />\n\n      <div className=\"mt-4\">\n        <button\n          onClick={() => setIsExpanded(!isExpanded)}\n          className=\"text-blue-600 hover:underline text-sm\"\n        >\n          {isExpanded ? 'Hide' : 'Show'} Sample Prompts\n        </button>\n\n        {isExpanded && (\n          <div className=\"mt-3 space-y-2\">\n            {SAMPLE_PROMPTS.map((prompt, idx) => (\n              <button\n                key={idx}\n                onClick={() => onChange(prompt)}\n                className=\"block w-full text-left p-3 bg-gray-100 hover:bg-gray-200 rounded-lg text-sm transition\"\n              >\n                {prompt}\n              </button>\n            ))}\n          </div>\n        )}\n      </div>\n    </div>\n  );\n}\n```\n\n**PanelGrid.tsx (with Drag-and-Drop):**\n```typescript\nimport { useState } from 'react';\nimport { Panel } from '../types';\nimport { DndContext, closestCenter, KeyboardSensor, PointerSensor, useSensor, useSensors } from '@dnd-kit/core';\nimport { SortableContext, sortableKeyboardCoordinates, verticalListSortingStrategy, useSortable } from '@dnd-kit/sortable';\nimport { CSS } from '@dnd-kit/utilities';\n\nfunction SortablePanel({ panel }: { panel: Panel }) {\n  const { attributes, listeners, setNodeRef, transform, transition } = useSortable({ id: panel.id });\n  const style = { transform: CSS.Transform.toString(transform), transition };\n\n  return (\n    <div ref={setNodeRef} style={style} {...attributes} {...listeners} className=\"p-4\">\n      <div className=\"bg-white rounded-lg shadow p-4 cursor-grab active:cursor-grabbing\">\n        <img\n          src={panel.imageUrl}\n          alt={`Panel ${panel.panelIndex}`}\n          className=\"w-full h-auto rounded mb-2\"\n        />\n        <p className=\"text-sm text-gray-600\">{panel.storyBeat}</p>\n        <span className={`inline-block mt-2 px-2 py-1 rounded text-xs text-white ${\n          panel.status === 'generated' ? 'bg-green-500' :\n          panel.status === 'pending' ? 'bg-blue-500' :\n          'bg-red-500'\n        }`}>\n          {panel.status}\n        </span>\n      </div>\n    </div>\n  );\n}\n\ninterface PanelGridProps {\n  panels: Panel[];\n  onReorder: (newOrder: Panel[]) => void;\n}\n\nexport function PanelGrid({ panels, onReorder }: PanelGridProps) {\n  const sensors = useSensors(\n    useSensor(PointerSensor),\n    useSensor(KeyboardSensor, { coordinateGetter: sortableKeyboardCoordinates })\n  );\n\n  const handleDragEnd = (event: any) => {\n    const { active, over } = event;\n    if (over && active.id !== over.id) {\n      const oldIndex = panels.findIndex(p => p.id === active.id);\n      const newIndex = panels.findIndex(p => p.id === over.id);\n      const newPanels = [...panels];\n      [newPanels[oldIndex], newPanels[newIndex]] = [newPanels[newIndex], newPanels[oldIndex]];\n      onReorder(newPanels);\n    }\n  };\n\n  return (\n    <DndContext sensors={sensors} collisionDetection={closestCenter} onDragEnd={handleDragEnd}>\n      <SortableContext items={panels.map(p => p.id)} strategy={verticalListSortingStrategy}>\n        <div className=\"grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-4\">\n          {panels.map(panel => (\n            <SortablePanel key={panel.id} panel={panel} />\n          ))}\n        </div>\n      </SortableContext>\n    </DndContext>\n  );\n}\n```\n\n**ProgressBar.tsx:**\n```typescript\nimport { GenerationProgress } from '../types';\n\nexport function ProgressBar({ progress }: { progress: GenerationProgress }) {\n  return (\n    <div className=\"w-full max-w-2xl\">\n      <div className=\"mb-2 flex justify-between\">\n        <span className=\"text-sm font-semibold\">{progress.message}</span>\n        <span className=\"text-sm text-gray-600\">{Math.round(progress.percentage)}%</span>\n      </div>\n      <div className=\"w-full h-3 bg-gray-200 rounded-full overflow-hidden\">\n        <div\n          className=\"h-full bg-blue-600 transition-all duration-300\"\n          style={{ width: `${progress.percentage}%` }}\n        />\n      </div>\n    </div>\n  );\n}\n```\n\n#### 5. Pages\n\n**CreateMangaPage.tsx:**\n```typescript\nimport { useState } from 'react';\nimport { ImageUploader } from '../components/ImageUploader';\nimport { StoryPromptEditor } from '../components/StoryPromptEditor';\nimport { LayoutSelector } from '../components/LayoutSelector';\nimport { ProgressBar } from '../components/ProgressBar';\nimport { useMangaGeneration } from '../hooks/useMangaGeneration';\nimport { UploadedImage, LayoutConfig } from '../types';\n\nexport function CreateMangaPage() {\n  const [projectName, setProjectName] = useState('');\n  const [storyPrompt, setStoryPrompt] = useState('');\n  const [uploadedImages, setUploadedImages] = useState<UploadedImage[]>([]);\n  const [layoutConfig, setLayoutConfig] = useState<LayoutConfig>({\n    totalPanels: 4,\n    format: 'vertical',\n    readingOrder: 'japanese',\n    gutterSize: 10,\n    borderWidth: 2,\n    borderColor: '#000000',\n    backgroundColor: '#FFFFFF',\n    pageWidth: 800,\n    pageHeight: 1200\n  });\n\n  const { progress, error, generateManga } = useMangaGeneration();\n\n  const handleStart = async () => {\n    if (!projectName || !storyPrompt) {\n      alert('Please enter project name and story prompt');\n      return;\n    }\n\n    await generateManga(projectName, storyPrompt, uploadedImages, layoutConfig, {\n      imageStyle: 'manga style',\n      aspectRatio: 'square',\n      qualityLevel: 'standard'\n    });\n  };\n\n  return (\n    <div className=\"min-h-screen bg-gray-50 py-12 px-4\">\n      <div className=\"max-w-4xl mx-auto space-y-8\">\n        <h1 className=\"text-4xl font-bold text-center mb-2\">koma-fill</h1>\n        <p className=\"text-center text-gray-600\">AI-Powered Manga Panel Generator</p>\n\n        {error && <div className=\"bg-red-100 border border-red-400 text-red-700 px-4 py-3 rounded\">{error}</div>}\n\n        {progress.stage === 'idle' ? (\n          <div className=\"space-y-8\">\n            <div className=\"bg-white p-6 rounded-lg shadow\">\n              <label className=\"block text-lg font-semibold mb-2\">Project Name</label>\n              <input\n                type=\"text\"\n                value={projectName}\n                onChange={e => setProjectName(e.target.value)}\n                className=\"input-field\"\n                placeholder=\"My Awesome Manga\"\n              />\n            </div>\n\n            <div className=\"bg-white p-6 rounded-lg shadow\">\n              <StoryPromptEditor value={storyPrompt} onChange={setStoryPrompt} />\n            </div>\n\n            <div className=\"bg-white p-6 rounded-lg shadow\">\n              <ImageUploader onImagesSelected={setUploadedImages} />\n            </div>\n\n            <div className=\"bg-white p-6 rounded-lg shadow\">\n              <LayoutSelector config={layoutConfig} onChange={setLayoutConfig} />\n            </div>\n\n            <button onClick={handleStart} className=\"btn-primary w-full text-lg py-3\">\n              Generate Manga\n            </button>\n          </div>\n        ) : (\n          <div className=\"bg-white p-6 rounded-lg shadow\">\n            <ProgressBar progress={progress} />\n          </div>\n        )}\n      </div>\n    </div>\n  );\n}\n```\n\n**PreviewPage.tsx:**\n```typescript\nimport { useParams, useNavigate } from 'react-router-dom';\nimport { useEffect, useState } from 'react';\nimport { apiClient } from '../services/apiClient';\nimport { PanelGrid } from '../components/PanelGrid';\nimport { ExportOptions } from '../components/ExportOptions';\nimport { MangaProject } from '../types';\n\nexport function PreviewPage() {\n  const { projectId } = useParams<{ projectId: string }>();\n  const navigate = useNavigate();\n  const [project, setProject] = useState<MangaProject | null>(null);\n  const [loading, setLoading] = useState(true);\n\n  useEffect(() => {\n    if (projectId) {\n      apiClient.getProject(projectId).then(setProject).finally(() => setLoading(false));\n    }\n  }, [projectId]);\n\n  if (loading) return <div className=\"flex justify-center py-12\">Loading...</div>;\n  if (!project) return <div className=\"text-center py-12\">Project not found</div>;\n\n  return (\n    <div className=\"min-h-screen bg-gray-50 py-12 px-4\">\n      <div className=\"max-w-6xl mx-auto\">\n        <button onClick={() => navigate('/')} className=\"btn-secondary mb-6\"> Back</button>\n\n        <h1 className=\"text-3xl font-bold mb-2\">{project.name}</h1>\n        <p className=\"text-gray-600 mb-6\">Project Status: {project.status}</p>\n\n        {project.panels.length > 0 && (\n          <div className=\"bg-white p-6 rounded-lg shadow mb-8\">\n            <h2 className=\"text-2xl font-semibold mb-4\">Panels</h2>\n            <PanelGrid panels={project.panels} onReorder={() => {}} />\n          </div>\n        )}\n\n        <div className=\"bg-white p-6 rounded-lg shadow\">\n          <h2 className=\"text-2xl font-semibold mb-4\">Export</h2>\n          <ExportOptions projectId={project.id} />\n        </div>\n      </div>\n    </div>\n  );\n}\n```\n\n#### 6. Update App.tsx\n\n```typescript\nimport { BrowserRouter as Router, Routes, Route, Navigate } from 'react-router-dom';\nimport { CreateMangaPage } from './pages/CreateMangaPage';\nimport { PreviewPage } from './pages/PreviewPage';\nimport './index.css';\n\nexport default function App() {\n  return (\n    <Router>\n      <Routes>\n        <Route path=\"/\" element={<CreateMangaPage />} />\n        <Route path=\"/project/:projectId\" element={<PreviewPage />} />\n        <Route path=\"*\" element={<Navigate to=\"/\" />} />\n      </Routes>\n    </Router>\n  );\n}\n```\n\n### package.json Updates\n\nAdd dependencies:\n```bash\nnpm install -D tailwindcss postcss autoprefixer\nnpm install react-router-dom @dnd-kit/core @dnd-kit/sortable @dnd-kit/utilities\n```\n\n### Testing Requirements\n\n```bash\n# 1. Start backend (from Task 1)\ncd backend && npm run dev\n\n# 2. In another terminal, start frontend\ncd frontend && npm run dev\n\n# 3. Open browser: http://localhost:3000\n\n# 4. Test workflow:\n# - Enter project name and story\n# - Upload reference images\n# - Configure layout\n# - Click \"Generate Manga\"\n# - Watch progress bar\n# - See panel grid with images\n# - Export to PNG/JPG/PDF\n```\n\n### Files This Task Uses from Other Agents\n\n- **API endpoints** from Task 1 (database & routes)\n- **Analysis data** from Task 2 (character consistency)\n- **Generated images** from Task 3 (panel images)\n- **Composed layouts** from Task 4 (final manga)\n\n### Output Validation Checklist\n\n- [ ] Tailwind CSS configured and working\n- [ ] ImageUploader component with drag-drop works\n- [ ] react-dropzone integration functional\n- [ ] StoryPromptEditor displays with sample prompts\n- [ ] Sample prompt insertion works\n- [ ] PanelGrid displays with drag-and-drop reordering\n- [ ] @dnd-kit integration functional\n- [ ] useMangaGeneration hook orchestrates full workflow\n- [ ] SSE progress streaming displays correctly\n- [ ] ProgressBar updates in real-time\n- [ ] apiClient makes correct API calls\n- [ ] All components have TypeScript types\n- [ ] CreateMangaPage workflow complete\n- [ ] PreviewPage shows generated manga\n- [ ] ExportOptions functional (PNG/JPG/PDF)\n- [ ] Routing works (create  preview)\n- [ ] Error handling displays user-friendly messages\n- [ ] npm run dev starts without errors\n- [ ] No TypeScript compilation errors\n\n---\n\n## Integration Testing (After All Tasks Complete)\n\nAfter all 5 agents finish their implementations, run the following integration tests:\n\n```bash\n# 1. Start backend\ncd /mnt/Projects/koma-fill/backend\nnpm install\nnpm run dev\n# Expected: \" koma-fill server running on http://localhost:5000\"\n\n# 2. Start frontend (new terminal)\ncd /mnt/Projects/koma-fill/frontend\nnpm install\nnpm run dev\n# Expected: \"VITE  ready in XXX ms\"\n\n# 3. Complete workflow test\n# Open http://localhost:3000 in browser\n# - Create project\n# - Upload 2 reference images\n# - Enter story prompt\n# - Select layout (4 panels)\n# - Click \"Generate Manga\"\n# - Wait for completion\n# - View generated panels\n# - Export to PNG\n# - Verify PNG file created in uploads/\n\n# 4. Verify database\nsqlite3 /mnt/Projects/koma-fill/data/koma-fill.db\n> SELECT COUNT(*) FROM projects;\n> SELECT COUNT(*) FROM panels;\n> SELECT COUNT(*) FROM keyImages;\n\n# 5. Check file structure\nls -la /mnt/Projects/koma-fill/uploads/\nls -la /mnt/Projects/koma-fill/data/\n\n# 6. API health check\ncurl http://localhost:5000/api/health\n# Expected: {\"status\":\"ok\",\"timestamp\":\"...\"}\n```\n\n### Known Integration Points to Verify\n\n- Task 1  Task 2: Panel prompts saved in DB, readable by frontend\n- Task 2  Task 3: Vision analysis influences character consistency in prompts\n- Task 3  Task 4: Generated images saved to disk, paths in database\n- Task 4  Task 5: Layout images served via `/uploads/` static directory\n- Task 5  All: Frontend calls all backend API endpoints successfully\n\n---\n\n## Success Criteria Summary\n\nAll 5 tasks completed when:\n\n1. **Backend (Task 1)**: Express server with SQLite database, all CRUD routes working\n2. **Vision & Prompts (Task 2)**: OpenAI Vision API analyzes images, GPT-4o generates DALL-E prompts\n3. **Image Generation (Task 3)**: DALL-E 3 generates 4+ images with retry logic, SSE progress works\n4. **Layout & Export (Task 4)**: Sharp composes panels into manga layout, exports PNG/JPG/PDF\n5. **Frontend (Task 5)**: React UI allows workflow from story  generated manga  export\n\n**Total Expected Time**: 4-5 hours per agent (can run in parallel)\n**Minimum Test Time**: 30 minutes for integration testing\n\nGood luck, KAMUI agents! \n\n---\n\n*Last Updated: 2025-02-12*\n*For issues or questions, refer to the specific task prompts above*\n: \nID: task-1770909068862-42049e\nBranch: task/task-1770909068862-42049e\nWorktree: Users/yuyafujita/Projects/koma-fill/.worktrees/task-1770909068862-42049e",
        "branchColor": "#b84fe8",
        "index": 26
      },
      {
        "type": "anchor",
        "label": "[] ClaudeCode2: # KAMUI-4D Parallel",
        "branch": "task/task-1770909069061-f69cf1",
        "worktreePath": "/Users/yuyafujita/Projects/koma-fill/.worktrees/task-1770909069061-f69cf1",
        "parentCommitHash": "1515fedca072442ad0656037229bce50b2e341f3",
        "lane": 12,
        "isMerged": false,
        "mergeCommitHash": null,
        "statusChildren": [],
        "isDefaultWorktree": false,
        "renderMode": "node",
        "shouldHide": false,
        "tagLabel": "task/task-1770909069061-f69cf1",
        "taskId": "task-1770909069061-f69cf1",
        "taskStatus": "working",
        "taskStatusLabel": "",
        "taskName": "ClaudeCode2: # KAMUI-4D Parallel Task Prompts for koma-fill\n## Manga Generation AI System - Multi-Agent Implementation Guide\n\n**Version:** 1.0\n**Project:** koma-fill - AI-powered manga panel generation system\n**Target:** KAMUI-4D Editor (Multi-AI CLI parallel execution)\n\n---\n\n## How to Use These Prompts in KAMUI-4D\n\nThis document contains **5 independent task prompts** designed to run in parallel across multiple AI coding agents. Each prompt is self-contained and can be executed independently without blocking other tasks.\n\n### Setup Instructions\n\n1. **Install dependencies** (run once before starting tasks):\n   ```bash\n   cd /mnt/Projects/koma-fill/backend\n   npm install\n\n   cd /mnt/Projects/koma-fill/frontend\n   npm install\n   ```\n\n2. **Environment Configuration**:\n   Create `/mnt/Projects/koma-fill/.env`:\n   ```\n   NODE_ENV=development\n   PORT=5000\n   BASE_URL=http://localhost:5000\n   OPENAI_API_KEY=your_openai_api_key_here\n   OPENAI_ORG_ID=your_org_id_optional\n   DATABASE_PATH=./data/koma-fill.db\n   STORAGE_PATH=./uploads\n   MAX_IMAGE_SIZE_MB=20\n   DALLE_RATE_LIMIT_PER_MINUTE=5\n   VISION_RATE_LIMIT_PER_MINUTE=30\n   MAX_RETRIES_PER_PANEL=3\n   ALLOWED_ORIGINS=http://localhost:3000\n   ```\n\n3. **Execution Strategy**:\n   - Copy each task prompt below into a separate KAMUI-4D session/agent\n   - **Tasks 1-5 can ALL start simultaneously** (no blocking dependencies)\n   - Each task should run independently in its own AI CLI session\n   - Monitor each agent's progress via console output\n   - **Integration testing** should happen after all 5 tasks complete (see bottom of doc)\n\n4. **Task Dependencies**:\n   ```\n   Task 1 (Backend)  provides database & API contracts\n   Task 2 (Vision)  uses Task 1's API, reads backend/src/models/types.ts\n   Task 3 (Images)  uses Task 1's API, reads backend/src/models/types.ts\n   Task 4 (Layout)  uses Task 1's API, reads backend/src/models/types.ts\n   Task 5 (Frontend)  calls Tasks 1-4 via REST API\n   ```\n   **All tasks can start immediately** - they communicate via file system and API contracts.\n\n---\n\n## Task 1: Backend (Agent A)\n### Express Server, SQLite Database & CRUD Routes Foundation\n\n**Time Estimate:** 45-60 minutes\n**Difficulty:** Intermediate\n**Dependencies:** None (this is the foundation layer)\n\n### Objective\nSet up a fully functional Express.js backend with SQLite database, implement CRUD operations for manga projects and panels, configure file upload handling with multer, and provide a solid API foundation for other agents to build upon.\n\n### Target Files to Create/Modify\n\n```\nbackend/\n src/\n    database/\n       connection.ts          [NEW] SQLite connection & initialization\n       schema.ts              [NEW] Table schema definitions\n    index.ts                   [MODIFY] Add DB initialization\n    app.ts                     [COMPLETE] Already done - verify middleware\n    routes/\n       manga.ts               [IMPLEMENT] Route handlers with DB calls\n    middleware/\n        errorHandler.ts        [VERIFY] Already complete\n uploads/                        [CREATE] Directory for image storage\n data/                           [CREATE] Directory for SQLite DB\n```\n\n### TypeScript Interfaces (from `/mnt/Projects/koma-fill/backend/src/models/types.ts`)\n\nKey types you'll use:\n```typescript\n// Core entities\nMangaProject {\n  id: string;                    // UUID\n  name: string;\n  description?: string;\n  status: ProjectStatus;         // 'draft' | 'analyzing' | 'generating' | 'complete' | 'exported'\n  layoutConfig: LayoutConfig;\n  generationSettings: GenerationSettings;\n  panels: Panel[];\n  keyImages: KeyImage[];\n  totalCost: number;\n  createdAt: string;             // ISO datetime\n  updatedAt: string;\n}\n\nPanel {\n  id: string;                    // UUID\n  projectId: string;\n  panelIndex: number;            // 0-based\n  imageUrl?: string;\n  imageFilePath?: string;\n  prompt?: string;\n  storyBeat?: string;\n  speechBubbleText?: string;\n  status: PanelStatus;           // 'pending' | 'generated' | 'failed' | 'placeholder'\n  retryCount: number;\n  generatedAt?: string;\n  createdAt: string;\n}\n\nKeyImage {\n  id: string;                    // UUID\n  projectId: string;\n  imageFilePath: string;\n  position: ImagePosition;       // 'start' | 'end' | number\n  analysis?: ImageAnalysis;\n  createdAt: string;\n}\n\nLayoutConfig {\n  totalPanels: number;           // 4, 6, 8, etc.\n  format: LayoutFormat;          // 'vertical' | 'horizontal' | 'square'\n  readingOrder: ReadingOrder;    // 'japanese' | 'western'\n  gutterSize: number;            // px\n  borderWidth: number;           // px\n  borderColor: string;           // hex #RRGGBB\n  backgroundColor: string;       // hex\n  pageWidth: number;             // px\n  pageHeight: number;            // px\n}\n\nGenerationSettings {\n  imageStyle: string;            // e.g., \"manga style, black and white ink\"\n  aspectRatio: 'square' | 'wide' | 'tall';\n  qualityLevel: 'standard' | 'hd';\n  negativePrompt?: string;\n  seed?: number;\n}\n```\n\n### Implementation Checklist\n\n#### 1. Create Database Connection Module (`backend/src/database/connection.ts`)\n```typescript\n// Requirements:\n- Initialize better-sqlite3 connection\n- Create/open database at DATABASE_PATH from .env\n- Export initDatabase() async function\n- Enable foreign keys constraint\n- Handle database file creation if needed\n- Connection should be cached/singleton\n```\n\n#### 2. Create Database Schema Module (`backend/src/database/schema.ts`)\n```typescript\n// SQL Schema Requirements:\nCREATE TABLE projects (\n  id TEXT PRIMARY KEY,\n  name TEXT NOT NULL,\n  description TEXT,\n  status TEXT NOT NULL,\n  layoutConfig JSON NOT NULL,\n  generationSettings JSON NOT NULL,\n  totalCost REAL DEFAULT 0,\n  createdAt TEXT NOT NULL,\n  updatedAt TEXT NOT NULL\n);\n\nCREATE TABLE panels (\n  id TEXT PRIMARY KEY,\n  projectId TEXT NOT NULL,\n  panelIndex INTEGER NOT NULL,\n  imageUrl TEXT,\n  imageFilePath TEXT,\n  prompt TEXT,\n  storyBeat TEXT,\n  speechBubbleText TEXT,\n  status TEXT NOT NULL,\n  retryCount INTEGER DEFAULT 0,\n  generatedAt TEXT,\n  createdAt TEXT NOT NULL,\n  FOREIGN KEY (projectId) REFERENCES projects(id)\n);\n\nCREATE TABLE keyImages (\n  id TEXT PRIMARY KEY,\n  projectId TEXT NOT NULL,\n  imageFilePath TEXT NOT NULL,\n  position TEXT NOT NULL,\n  analysis JSON,\n  createdAt TEXT NOT NULL,\n  FOREIGN KEY (projectId) REFERENCES projects(id)\n);\n\nCREATE INDEX idx_project_status ON projects(status);\nCREATE INDEX idx_panel_project ON panels(projectId);\nCREATE INDEX idx_panel_status ON panels(status);\n```\n\n#### 3. Modify `backend/src/index.ts`\n```typescript\n// Add:\n- Import { initDatabase } from './database/connection'\n- Call await initDatabase() before app.listen()\n- Log database initialization success\n```\n\n#### 4. Create Repository Layer (`backend/src/repositories/`)\n```typescript\n// Create:\n- ProjectRepository with methods:\n  - createProject(data: CreateMangaRequest): Promise<MangaProject>\n  - getProject(id: string): Promise<MangaProject | null>\n  - listProjects(limit: number, offset: number): Promise<MangaProject[]>\n  - updateProject(id: string, updates: Partial<MangaProject>): Promise<MangaProject>\n  - deleteProject(id: string): Promise<void>\n\n- PanelRepository with methods:\n  - createPanel(projectId: string, data: Panel): Promise<Panel>\n  - getPanelsByProject(projectId: string): Promise<Panel[]>\n  - getPanel(panelId: string): Promise<Panel | null>\n  - updatePanel(panelId: string, updates: Partial<Panel>): Promise<Panel>\n  - updatePanelStatus(panelId: string, status: PanelStatus): Promise<void>\n\n- KeyImageRepository with methods:\n  - createKeyImage(projectId: string, data: KeyImage): Promise<KeyImage>\n  - getKeyImages(projectId: string): Promise<KeyImage[]>\n  - updateKeyImageAnalysis(imageId: string, analysis: ImageAnalysis): Promise<void>\n```\n\n#### 5. Implement Routes in `backend/src/routes/manga.ts`\nReplace TODO comments with actual implementations:\n\n- **POST /api/manga/create**\n  - Validate CreateMangaRequest using Joi\n  - Generate unique project ID (uuid)\n  - Create project in database with 'draft' status\n  - Create initial panel records (count = layoutConfig.totalPanels)\n  - Return created MangaProject with 201 status\n\n- **POST /api/manga/:projectId/upload**\n  - Files already handled by multer middleware\n  - Save KeyImage records to database with file paths\n  - Store position information\n  - Return array of KeyImage objects\n\n- **GET /api/manga/:projectId**\n  - Fetch project + panels + key images from database\n  - Return complete MangaProject object\n  - Throw NotFoundError if project doesn't exist\n\n- **GET /api/manga**\n  - Implement pagination (limit/offset query params)\n  - Return array of projects\n  - Include total count header\n\n- **PUT /api/manga/:projectId/reorder**\n  - Parse ReorderPanelsRequest body\n  - Update panelIndex for each panel based on new order\n  - Return updated panels array\n\n### Testing Requirements\n\nAfter implementation, verify:\n\n```bash\n# 1. Database initialization\nnpm run dev\n# Check console: \" configured\" for database\n\n# 2. Create project\ncurl -X POST http://localhost:5000/api/manga/create \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\n    \"projectName\": \"Test Manga\",\n    \"storyPrompt\": \"A hero on a quest\",\n    \"layoutConfig\": { \"totalPanels\": 4 }\n  }'\n\n# 3. Get project\ncurl http://localhost:5000/api/manga/{projectId}\n\n# 4. Upload images\ncurl -X POST http://localhost:5000/api/manga/{projectId}/upload \\\n  -F \"images=@test1.jpg\" \\\n  -F \"images=@test2.jpg\"\n\n# 5. Check database\nsqlite3 data/koma-fill.db \"SELECT * FROM projects; SELECT * FROM panels;\"\n```\n\n### Files This Task Provides to Other Agents\n\n- **Database schema** - Tasks 2, 3, 4, 5 will read/write to these tables\n- **API contracts** - manga.ts route signatures that Tasks 2-4 will call\n- **File storage structure** - uploads/ directory path that Task 3 will use\n- **Type definitions** - already in backend/src/models/types.ts (reference only)\n\n### Output Validation Checklist\n\n- [ ] Database file created at `data/koma-fill.db`\n- [ ] All 3 tables created with correct schema\n- [ ] Repositories implement CRUD operations\n- [ ] All route handlers work without TODO comments\n- [ ] multer uploads save files to `uploads/` directory\n- [ ] POST /create returns 201 with MangaProject object\n- [ ] GET /:projectId returns full project with panels\n- [ ] Error handler catches and responds appropriately\n- [ ] No TypeScript compilation errors\n- [ ] npm run dev starts without errors\n\n---\n\n## Task 2: + (Agent B)\n### Vision API Integration & DALL-E Prompt Generation\n\n**Time Estimate:** 50-60 minutes\n**Difficulty:** Intermediate\n**Dependencies:** Task 1 (needs database & API routes available)\n\n### Objective\nImplement OpenAI Vision API integration to analyze uploaded key images and extract character/style information. Then implement story-to-panel prompt generation using GPT-4o to create DALL-E 3 compatible prompts that maintain consistency across panels.\n\n### Target Files to Create/Modify\n\n```\nbackend/\n src/\n     services/\n         imageAnalysisService.ts      [IMPLEMENT] Vision API analysis\n         promptGenerationService.ts   [CREATE] Story  panel prompts\n```\n\n### System Prompts (Already Provided)\n\nBoth vision analysis prompts are defined in `imageAnalysisService.ts`:\n- `QUICK_ANALYSIS_PROMPT` - fast, ~500 tokens\n- `DETAILED_ANALYSIS_PROMPT` - thorough, ~2000 tokens\n\nThese guide the Vision API to return structured JSON matching the `ImageAnalysis` interface.\n\n### TypeScript Interfaces\n\n```typescript\n// Input: Key image file path (from Task 1)\n// Output: ImageAnalysis object\n\nImageAnalysis {\n  description: string;\n  characters: CharacterInfo[];\n  objects: string[];\n  colors: string[];\n  composition: string;\n  mood: string;\n  artStyle: string;\n  suggestedTransitions: string[];\n}\n\nCharacterInfo {\n  name?: string;\n  appearance: string;        // detailed physical description\n  emotion: string;\n  position: string;          // screen position (e.g., \"center-left\")\n}\n\n// Panel prompt generation\nPanelPrompt {\n  panelIndex: number;\n  dallePrompt: string;       // Full DALL-E 3 prompt (100-300 words)\n  storyBeat: string;         // What happens in this panel\n  visualFocus: string;       // Main visual element\n  transitionType: TransitionType;  // 'cut' | 'pan' | 'zoom_in' | 'zoom_out' | 'fade' | 'action'\n  suggestedDialogue?: string;\n}\n```\n\n### Implementation Details\n\n#### ImageAnalysisService (`backend/src/services/imageAnalysisService.ts`)\n\n**Constructor:**\n```typescript\nconstructor() {\n  this.openai = new OpenAI({\n    apiKey: CONFIG.OPENAI_API_KEY,\n    organization: CONFIG.OPENAI_ORG_ID\n  });\n}\n```\n\n**Method: analyzeImage(imageBase64: string, depth: 'quick' | 'detailed')**\n- Input: Base64-encoded image data from KeyImage file\n- Implementation:\n  1. Read image file and convert to Base64 (if not already)\n  2. Call `this.openai.chat.completions.create()`:\n     - model: CONFIG.VISION_MODEL ('gpt-4o')\n     - messages: [\n       { role: 'system', content: QUICK_ANALYSIS_PROMPT or DETAILED_ANALYSIS_PROMPT }\n       { role: 'user', content: [\n         { type: 'image_url', image_url: { url: `data:image/png;base64,${imageBase64}` } }\n       ]}\n     ]\n     - response_format: { type: 'json_object' }\n     - max_tokens: depth === 'quick' ? 500 : 2000\n  3. Parse response.choices[0].message.content as JSON\n  4. Validate against ImageAnalysis schema\n  5. Return ImageAnalysis object\n\n**Method: analyzeMultiple(images, depth)**\n- Input: Array of { base64, position } objects\n- Use Promise.all with rate limiting (max CONFIG.VISION_RATE_LIMIT_PER_MINUTE calls/min)\n- Implement backoff if rate limited\n- Return array of ImageAnalysis objects\n\n**Method: extractCharacters(analysis)**\n- Optional: Deep-dive character extraction\n- Can call another Vision API pass if needed for more detail\n\n#### PromptGenerationService (NEW FILE - `backend/src/services/promptGenerationService.ts`)\n\n**Constructor:**\n```typescript\nconstructor() {\n  this.openai = new OpenAI({ apiKey: CONFIG.OPENAI_API_KEY });\n}\n```\n\n**Method: generatePanelPrompts(request: GeneratePromptsRequest)**\n\nInput:\n```typescript\nGeneratePromptsRequest {\n  storyPrompt: string;           // User's story\n  panelCount: number;            // Total panels to generate\n  characterConsistency: boolean; // Whether to maintain character consistency\n}\n```\n\nImplementation:\n1. **Story Breakdown Phase:**\n   - Call GPT-4o to split story into N panel beats\n   - System prompt should guide structure like:\n   ```\n   \"You are a manga story expert. Break the provided story into exactly {panelCount}\n    distinct visual beats. Each beat should be 1-2 sentences describing what happens\n    visually in that panel. Format as JSON array of objects with 'panelIndex' and 'beat' fields.\"\n   ```\n\n2. **Character Consistency Analysis:**\n   - If characterConsistency=true and keyImages were analyzed:\n     - Retrieve stored ImageAnalysis for key images\n     - Create character consistency profile (appearance, emotion arcs, etc.)\n     - Include in subsequent prompts\n\n3. **DALL-E 3 Prompt Generation:**\n   - For each story beat, create detailed DALL-E 3 prompt\n   - System prompt pattern:\n   ```\n   \"You are a DALL-E 3 prompt expert specializing in manga panels.\n    Given a story beat, generate a detailed visual prompt (100-300 words) that:\n    - Specifies art style: {generationSettings.imageStyle}\n    - Maintains character consistency: {characterProfile}\n    - Follows manga composition principles\n    - Uses specific visual terms (angle, lighting, pose, emotion)\n    - Avoids abstract concepts; be concrete and visual\n    - Follows DALL-E 3 content policy\n\n    Return JSON with: { dallePrompt, visualFocus, transitionType, suggestedDialogue }\"\n   ```\n\n4. **Transition Logic:**\n   - Analyze flow between consecutive beats\n   - Suggest transition type ('cut', 'pan', 'zoom_in', etc.)\n   - Update imageUrl in previous panel to support transitions\n\n5. **Return Value:**\n   - Array of PanelPrompt objects, one per panel\n   - Each with populated dallePrompt, storyBeat, visualFocus, transitionType\n\n### Database Integration\n\nAfter generating prompts, save to Panel table:\n- Update each panel's `prompt` field with `dallePrompt`\n- Update `storyBeat` field\n- Update `status` to 'pending' (ready for image generation)\n\n### API Integration\n\nImplement route handlers in `backend/src/routes/manga.ts`:\n\n**POST /api/manga/:projectId/analyze**\n```typescript\n// 1. Fetch project and keyImages from DB\n// 2. Read image files and convert to Base64\n// 3. Call imageAnalysisService.analyzeMultiple()\n// 4. Store analysis results in DB (keyImages.analysis)\n// 5. Update project status to 'analyzing'  'complete'\n// 6. Return analysis results\n```\n\n**POST /api/manga/:projectId/generate-prompts**\n```typescript\n// 1. Validate GeneratePromptsRequest\n// 2. Fetch project and keyImages analyses from DB\n// 3. Call promptGenerationService.generatePanelPrompts()\n// 4. Update panel records with generated prompts\n// 5. Update project status to 'generating'\n// 6. Return array of PanelPrompt objects\n```\n\n### Testing Requirements\n\n```bash\n# 1. Prepare test image\n# (Use any PNG/JPG with a character or scene)\n\n# 2. Create project and upload image (Task 1)\nPROJECT_ID=$(curl -s -X POST http://localhost:5000/api/manga/create \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"projectName\":\"Test\",\"storyPrompt\":\"A hero finds treasure\"}' | jq -r '.id')\n\n# 3. Upload test image\ncurl -X POST http://localhost:5000/api/manga/$PROJECT_ID/upload \\\n  -F \"images=@test_image.jpg\"\n\n# 4. Analyze images\ncurl -X POST http://localhost:5000/api/manga/$PROJECT_ID/analyze \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"analysisDepth\":\"quick\"}'\n\n# 5. Generate prompts\ncurl -X POST http://localhost:5000/api/manga/$PROJECT_ID/generate-prompts \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\n    \"storyPrompt\": \"A hero finds treasure in a dark cave\",\n    \"panelCount\": 4,\n    \"characterConsistency\": true\n  }'\n\n# 6. Verify output\ncurl http://localhost:5000/api/manga/$PROJECT_ID | jq '.panels[].prompt'\n```\n\n### Files This Task Provides to Other Agents\n\n- **Panel prompt data** - Stored in DB panels table, used by Task 3 for image generation\n- **Character analysis** - Used by Task 5 frontend for display\n- **Art style consistency** - Guides Task 3's image generation\n\n### Output Validation Checklist\n\n- [ ] ImageAnalysisService.analyzeImage() calls Vision API successfully\n- [ ] Vision API responses parse correctly to ImageAnalysis\n- [ ] PromptGenerationService generates DALL-E-compatible prompts\n- [ ] Panel prompts maintain character consistency (if enabled)\n- [ ] Transition types are correctly assigned\n- [ ] All panel records updated in database with prompts\n- [ ] /analyze endpoint returns ImageAnalysis array\n- [ ] /generate-prompts endpoint returns PanelPrompt array\n- [ ] Error handling for API failures (rate limits, auth, etc.)\n- [ ] No TypeScript compilation errors\n\n---\n\n## Task 3: DALL-E 3 (Agent C)\n### Image Generation with Retry Logic & Progress Streaming\n\n**Time Estimate:** 50-70 minutes\n**Difficulty:** Intermediate-Advanced\n**Dependencies:** Task 1 (DB & API), Task 2 (panel prompts)\n\n### Objective\nImplement DALL-E 3 image generation with robust error handling, exponential backoff retry logic, local image storage, Server-Sent Events (SSE) streaming for real-time progress updates, and cost tracking per API call.\n\n### Target Files to Create/Modify\n\n```\nbackend/\n src/\n     services/\n         imageGenerationService.ts    [IMPLEMENT] DALL-E 3 API integration\n         (imageProcessor.ts)          [REFERENCE] Utility for image processing\n```\n\n### TypeScript Interfaces\n\n```typescript\nGeneratedPanel {\n  panelIndex: number;\n  imageUrl: string;              // DALL-E public URL (temporary)\n  localFilePath: string;         // /uploads/{projectId}/panel_{index}.png\n  prompt: string;                // Original prompt sent\n  revisedPrompt?: string;        // DALL-E 3's revised prompt (if modified)\n  costUsd: number;               // API call cost\n}\n\n// Request type\nGenerateImagesRequest {\n  panelIndices?: number[];       // undefined = all panels\n  batchMode: 'sequential' | 'parallel';\n}\n\n// Progress event (sent via SSE)\nProgressEvent {\n  type: 'progress' | 'complete' | 'error';\n  stage: string;                 // 'generating_images'\n  currentStep: number;           // Current panel index\n  totalSteps: number;            // Total panels\n  percentage: number;            // 0-100\n  message: string;               // Human-readable status\n  panelId?: string;\n  panelIndex?: number;\n  error?: string;                // Error message if type='error'\n}\n```\n\n### Implementation Details\n\n#### ImageGenerationService (`backend/src/services/imageGenerationService.ts`)\n\n**Constructor & Initialization:**\n```typescript\nconstructor() {\n  this.openai = new OpenAI({ apiKey: CONFIG.OPENAI_API_KEY });\n  this.uploadDir = path.resolve(CONFIG.STORAGE_PATH);\n}\n```\n\n**Method: generatePanel() - Single Panel Generation**\n\n```typescript\nasync generatePanel(\n  prompt: string,\n  panelIndex: number,\n  projectId: string,\n  settings?: GenerationSettings\n): Promise<GeneratedPanel>\n```\n\nImplementation:\n1. **Image Size Calculation:**\n   - Map aspectRatio to DALL-E 3 size:\n     - 'square'  '1024x1024'\n     - 'wide'  '1792x1024'\n     - 'tall'  '1024x1792'\n\n2. **API Call (with retry logic in wrapper):**\n   ```typescript\n   const response = await this.openai.images.generate({\n     model: CONFIG.DALLE_MODEL,           // 'dall-e-3'\n     prompt: prompt,\n     n: 1,\n     size: size,\n     quality: settings?.qualityLevel === 'hd' ? 'hd' : 'standard',\n     style: 'natural',                    // or 'vivid' for more dramatic\n   });\n   ```\n\n3. **Extract Response Data:**\n   - imageUrl = response.data[0].url\n   - revisedPrompt = response.data[0].revised_prompt\n   - Calculate cost based on settings.qualityLevel:\n     - standard: $0.040 per image\n     - hd: $0.080 per image\n\n4. **Download & Save Image:**\n   - Call this.downloadAndSave(imageUrl, projectId, panelIndex)\n   - Saves as PNG: `{STORAGE_PATH}/{projectId}/panel_{panelIndex}.png`\n   - Returns localFilePath\n\n5. **Return GeneratedPanel object**\n\n**Method: generateBatch() - Batch Generation with Mode Selection**\n\n```typescript\nasync generateBatch(\n  panelPrompts: PanelPrompt[],\n  projectId: string,\n  batchMode: 'sequential' | 'parallel',\n  settings?: GenerationSettings,\n  onProgress?: (event: ProgressEvent) => void\n): Promise<GeneratedPanel[]>\n```\n\nImplementation:\n1. Validate inputs\n2. Route to sequential or parallel handler\n3. Call onProgress callback with progress events\n4. Return array of GeneratedPanel\n\n**Method: generateSequential() - Rate-Limit Friendly**\n\n```typescript\nprivate async generateSequential(\n  panelPrompts: PanelPrompt[],\n  projectId: string,\n  settings?: GenerationSettings,\n  onProgress?: (event: ProgressEvent) => void\n): Promise<GeneratedPanel[]>\n```\n\nImplementation:\n1. Initialize results array\n2. For each panelPrompt (with index):\n   a. Call generatePanelWithRetry(panelPrompt, projectId, settings)\n   b. On success:\n      - Add to results array\n      - Call onProgress with percentage = (index + 1) / total * 100\n   c. On failure (after max retries):\n      - Update panel status to 'failed' in DB\n      - Log error\n      - Continue to next panel\n\n3. Return results array (may include failed panels with status='failed')\n\n**Method: generateParallel() - High Speed (Rate Limit Aware)**\n\n```typescript\nprivate async generateParallel(\n  panelPrompts: PanelPrompt[],\n  projectId: string,\n  settings?: GenerationSettings,\n  onProgress?: (event: ProgressEvent) => void\n): Promise<GeneratedPanel[]>\n```\n\nImplementation:\n1. **Batch Control:**\n   - Max concurrent = Math.floor(CONFIG.DALLE_RATE_LIMIT_PER_MINUTE / 2)\n   - Split panelPrompts into batches of max concurrent\n\n2. **For each batch:**\n   - Create Promise.allSettled() for batch\n   - Wait for all to settle\n   - Process results\n   - Send progress update to onProgress\n   - Delay before next batch (respect rate limits)\n\n3. **Failure Handling:**\n   - Collect failed panels\n   - Retry failed panels sequentially (exponential backoff)\n   - Update onProgress for retries\n\n4. **Return results array**\n\n**Method: generatePanelWithRetry() - Core Retry Logic**\n\n```typescript\nprivate async generatePanelWithRetry(\n  panelPrompt: PanelPrompt,\n  projectId: string,\n  settings?: GenerationSettings,\n  retryCount: number = 0\n): Promise<GeneratedPanel>\n```\n\nImplementation:\n1. Try to generate panel via generatePanel()\n2. On success: Return GeneratedPanel\n3. On failure:\n   - If retryCount < CONFIG.MAX_RETRIES_PER_PANEL:\n     - Calculate backoff delay: 2^retryCount * 1000ms (exponential)\n     - Wait for delay\n     - Recursively call with retryCount++\n   - If max retries exceeded:\n     - Throw error with panel index info\n\n**Exponential Backoff Formula:**\n```\ndelay(attempt) = base_delay * (2 ^ attempt) + random jitter\ndelay(0) = 1000ms (1 second)\ndelay(1) = 2000ms (2 seconds)\ndelay(2) = 4000ms (4 seconds)\n+ add random(0, 500ms) jitter to avoid thundering herd\n```\n\n**Method: downloadAndSave() - Store Images Locally**\n\n```typescript\nprivate async downloadAndSave(\n  imageUrl: string,\n  projectId: string,\n  panelIndex: number\n): Promise<string>\n```\n\nImplementation:\n1. Create project uploads directory if not exists: `{STORAGE_PATH}/{projectId}/`\n2. Fetch image from URL using axios or native fetch:\n   ```typescript\n   const response = await fetch(imageUrl);\n   const arrayBuffer = await response.arrayBuffer();\n   const buffer = Buffer.from(arrayBuffer);\n   ```\n3. Save to disk:\n   ```typescript\n   const filePath = path.join(this.uploadDir, projectId, `panel_${panelIndex}.png`);\n   await fs.writeFile(filePath, buffer);\n   ```\n4. Return relative or absolute path\n\n**Method: getImageSize() - Aspect Ratio to DALL-E Size**\n\n```typescript\nprivate getImageSize(\n  aspectRatio: string\n): '1024x1024' | '1792x1024' | '1024x1792'\n```\n\nSelf-explanatory mapping function.\n\n### Route Handler Integration\n\nImplement in `backend/src/routes/manga.ts`:\n\n**POST /api/manga/:projectId/generate-images - SSE Streaming**\n\n```typescript\nrouter.post('/:projectId/generate-images', async (req, res, next) => {\n  try {\n    const { projectId } = req.params;\n    const { panelIndices, batchMode } = req.body as GenerateImagesRequest;\n\n    // Set up SSE response\n    res.setHeader('Content-Type', 'text/event-stream');\n    res.setHeader('Cache-Control', 'no-cache');\n    res.setHeader('Connection', 'keep-alive');\n\n    // Fetch project and panels from DB\n    const project = await getProject(projectId);\n    if (!project) throw new NotFoundError('Project');\n\n    // Filter panels (all or specific indices)\n    const panelsToGenerate = project.panels.filter(\n      p => !panelIndices || panelIndices.includes(p.panelIndex)\n    );\n\n    // Generate prompts array\n    const panelPrompts: PanelPrompt[] = panelsToGenerate.map(p => ({\n      panelIndex: p.panelIndex,\n      dallePrompt: p.prompt!,\n      storyBeat: p.storyBeat!,\n      visualFocus: 'main subject',  // Extract from context if available\n      transitionType: 'cut',        // Default, could be from DB\n    }));\n\n    // Call imageGenerationService\n    imageGenService.generateBatch(\n      panelPrompts,\n      projectId,\n      batchMode,\n      project.generationSettings,\n      (progressEvent) => {\n        // Send progress as SSE\n        res.write(`data: ${JSON.stringify(progressEvent)}\\n\\n`);\n      }\n    ).then(generatedPanels => {\n      // Update database with generated images\n      for (const panel of generatedPanels) {\n        updatePanelImage(panel.panelIndex, {\n          imageUrl: panel.imageUrl,\n          imageFilePath: panel.localFilePath,\n          revisedPrompt: panel.revisedPrompt,\n          status: panel.revisedPrompt ? 'generated' : 'generated',\n        });\n      }\n\n      // Send completion event\n      res.write(`data: ${JSON.stringify({\n        type: 'complete',\n        message: 'Image generation complete',\n        totalCost: generatedPanels.reduce((sum, p) => sum + p.costUsd, 0),\n      })}\\n\\n`);\n\n      res.end();\n    }).catch(err => {\n      res.write(`data: ${JSON.stringify({\n        type: 'error',\n        message: err.message,\n      })}\\n\\n`);\n      res.end();\n    });\n  } catch (err) {\n    next(err);\n  }\n});\n```\n\n### Cost Tracking\n\n**Implementation:**\n- Track cost per API call in GeneratedPanel.costUsd\n- Sum across all panels: `totalCost = sum(generatedPanels.map(p => p.costUsd))`\n- Update project.totalCost in DB: `project.totalCost += generatedPanels totalCost`\n- Log costs for each call (useful for budget monitoring)\n\n**Cost Constants (from types.ts):**\n```typescript\nAPI_COSTS = {\n  VISION_PER_CALL: 0.025,    // GPT-4V\n  DALLE3_STANDARD: 0.040,    // per image\n  DALLE3_HD: 0.080,          // per image\n}\n```\n\n### Testing Requirements\n\n```bash\n# 1. Set up test project (with prompts from Task 2)\nPROJECT_ID=\"test-project-id\"\n# Or use output from Task 2 test\n\n# 2. Generate images (sequential mode)\ncurl -X POST http://localhost:5000/api/manga/$PROJECT_ID/generate-images \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"batchMode\": \"sequential\"}' \\\n  -H \"Accept: text/event-stream\"\n\n# 3. Verify local image files created\nls -la uploads/$PROJECT_ID/\n\n# 4. Check database for updated image URLs\nsqlite3 data/koma-fill.db \"SELECT panelIndex, imageFilePath, status FROM panels WHERE projectId='$PROJECT_ID';\"\n\n# 5. Verify cost tracking\ncurl http://localhost:5000/api/manga/$PROJECT_ID | jq '.totalCost'\n```\n\n### Files This Task Provides to Other Agents\n\n- **Generated panel images** - Stored in uploads/{projectId}/, used by Task 4\n- **Image file paths** - Updated in DB, used by Task 4 for layout composition\n- **Cost tracking** - Used by frontend for budget display\n\n### Output Validation Checklist\n\n- [ ] DALL-E 3 API calls succeed with valid prompts\n- [ ] Retry logic works with exponential backoff\n- [ ] Images download and save to {STORAGE_PATH}/{projectId}/\n- [ ] SSE streaming sends progress events correctly\n- [ ] onProgress callback fires with accurate percentage\n- [ ] Cost calculation correct (0.04 standard, 0.08 HD)\n- [ ] Panel records updated with imageUrl and imageFilePath\n- [ ] Sequential and parallel modes both work\n- [ ] Rate limiting respected (max 5 calls/min by default)\n- [ ] Error handling for network issues, API failures\n- [ ] No TypeScript compilation errors\n\n---\n\n## Task 4: + (Agent D)\n### Manga Layout Composition & Multi-Format Export\n\n**Time Estimate:** 45-60 minutes\n**Difficulty:** Intermediate (Sharp library learning curve)\n**Dependencies:** Task 1 (DB), Task 3 (generated images)\n\n### Objective\nImplement Sharp-based manga layout composition with grid calculation, panel resizing and positioning, border/gutter rendering, speech bubble overlay, and PNG/JPG/PDF export functionality.\n\n### Target Files to Create/Modify\n\n```\nbackend/\n src/\n     services/\n        layoutEngine.ts          [IMPLEMENT] Panel composition & layout\n        exportService.ts         [CREATE] PNG/JPG/PDF export\n     utils/\n         imageProcessor.ts        [HELPER] Image processing utilities\n```\n\n### TypeScript Interfaces\n\n```typescript\n// Layout composition result\nComposedLayout {\n  buffer: Buffer;                    // PNG image buffer\n  width: number;                     // Page width (px)\n  height: number;                    // Page height (px)\n  format: 'png';\n  panelPositions: PanelPosition[];   // Position data for each panel\n}\n\nPanelPosition {\n  panelIndex: number;\n  x: number;                         // Offset from top-left (px)\n  y: number;\n  width: number;                     // Panel width (px)\n  height: number;                    // Panel height (px)\n}\n\n// Input to layout engine\nLayoutConfig {\n  totalPanels: number;               // 4, 6, 8, etc.\n  format: LayoutFormat;              // 'vertical' | 'horizontal' | 'square'\n  readingOrder: ReadingOrder;        // 'japanese' | 'western'\n  gutterSize: number;                // Space between panels (px)\n  borderWidth: number;               // Panel border thickness (px)\n  borderColor: string;               // Hex color\n  backgroundColor: string;           // Hex color\n  pageWidth: number;                 // Canvas width (px)\n  pageHeight: number;                // Canvas height (px)\n}\n```\n\n### Implementation Details\n\n#### LayoutEngine (`backend/src/services/layoutEngine.ts`)\n\n**Method: composePanels() - Main Composition Function**\n\n```typescript\nasync composePanels(\n  panelImagePaths: string[],\n  config: LayoutConfig = DEFAULT_LAYOUT_CONFIG\n): Promise<ComposedLayout>\n```\n\nImplementation Steps:\n\n1. **Calculate Grid:**\n   ```typescript\n   const grid = this.calculateGrid(panelImagePaths.length, config);\n   // Returns { cols: number, rows: number }\n   ```\n   Already implemented - use it.\n\n2. **Calculate Panel Positions:**\n   ```typescript\n   const positions = this.calculatePanelPositions(grid, config);\n   // Returns: PanelPosition[] with x, y, width, height for each panel\n   ```\n   Already implemented - use it.\n\n3. **Create Background Canvas:**\n   ```typescript\n   import sharp from 'sharp';\n\n   let canvas = sharp({\n     create: {\n       width: config.pageWidth,\n       height: config.pageHeight,\n       channels: 4,                    // RGBA\n       background: config.backgroundColor,  // Parsed from hex\n     }\n   });\n   ```\n\n4. **Load & Resize Panel Images:**\n   ```typescript\n   const composites = await Promise.all(\n     panelImagePaths.map(async (imgPath, i) => {\n       if (!fs.existsSync(imgPath)) {\n         throw new Error(`Panel image not found: ${imgPath}`);\n       }\n\n       const position = positions[i];\n       const resized = await sharp(imgPath)\n         .resize(position.width, position.height, {\n           fit: 'cover',              // Fill panel, crop if needed\n           withoutEnlargement: false\n         })\n         .toBuffer();\n\n       return {\n         input: resized,\n         left: position.x,\n         top: position.y\n       };\n     })\n   );\n   ```\n\n5. **Composite Panels Onto Canvas:**\n   ```typescript\n   let result = await canvas.composite(composites).png();\n   ```\n\n6. **Add Borders (Optional - if borderWidth > 0):**\n   - Use SVG overlay to draw rectangles around each panel\n   - Create SVG:\n     ```svg\n     <svg width=\"800\" height=\"1200\">\n       <!-- For each panel position -->\n       <rect x=\"10\" y=\"10\" width=\"390\" height=\"590\"\n             fill=\"none\" stroke=\"black\" stroke-width=\"2\" />\n     </svg>\n     ```\n   - Composite SVG overlay:\n     ```typescript\n     const borderSvg = this.generateBorderSvg(positions, config);\n     result = await result.composite([{\n       input: borderSvg,\n       top: 0,\n       left: 0\n     }]);\n     ```\n\n7. **Return ComposedLayout:**\n   ```typescript\n   const buffer = await result.toBuffer();\n   return {\n     buffer,\n     width: config.pageWidth,\n     height: config.pageHeight,\n     format: 'png',\n     panelPositions: positions\n   };\n   ```\n\n**Method: addSpeechBubbles() - Overlay Speech Bubbles**\n\n```typescript\nasync addSpeechBubbles(\n  layout: ComposedLayout,\n  bubbles: SpeechBubble[]\n): Promise<ComposedLayout>\n```\n\nImplementation:\n\n1. **For each speech bubble:**\n   - Get panel position from layout.panelPositions[bubble.panelIndex]\n   - Calculate bubble position within panel:\n     - 'top'  y = panel.y + 30\n     - 'middle'  y = panel.y + panel.height/2 - 30\n     - 'bottom'  y = panel.y + panel.height - 60\n\n2. **Create SVG speech bubble:**\n   ```typescript\n   const svg = this.generateSpeechBubbleSvg(bubble, position, style);\n   // Generates SVG with text, shape varies by style:\n   // 'rounded', 'cloud', 'spiked', 'rectangular'\n   ```\n\n3. **Composite all bubble SVGs:**\n   ```typescript\n   let result = sharp(layout.buffer);\n   const bubbleSvgs = bubbles.map((bubble, idx) =>\n     this.generateSpeechBubbleSvg(bubble, panelPositions[bubble.panelIndex])\n   );\n\n   result = await result.composite(\n     bubbleSvgs.map((svg, i) => ({ input: svg }))\n   );\n   ```\n\n4. **Return updated ComposedLayout**\n\n**Helper: generateBorderSvg()**\n```typescript\nprivate generateBorderSvg(\n  positions: PanelPosition[],\n  config: LayoutConfig\n): Buffer\n```\n\nGenerate SVG with rectangle borders around each panel:\n```svg\n<svg width=\"800\" height=\"1200\">\n  <rect x=\"10\" y=\"10\" width=\"390\" height=\"590\"\n        fill=\"none\" stroke=\"#000000\" stroke-width=\"2\" />\n  <!-- repeated for each panel -->\n</svg>\n```\n\nConvert to Buffer and return.\n\n**Helper: generateSpeechBubbleSvg()**\n```typescript\nprivate generateSpeechBubbleSvg(\n  bubble: SpeechBubble,\n  panelPosition: PanelPosition,\n  targetY: number  // top/middle/bottom\n): Buffer\n```\n\nGenerate SVG with speech bubble shape. Example for 'rounded':\n```svg\n<svg width=\"300\" height=\"100\">\n  <!-- Rounded rectangle -->\n  <path d=\"M 10,10 Q 10,10 20,10 L 270,10 Q 280,10 280,20 L 280,70 Q 280,80 270,80 L 30,80 Q 20,80 20,70 L 20,40 L 0,60 L 20,50 L 20,20 Q 20,10 10,10\"\n        fill=\"white\" stroke=\"black\" stroke-width=\"1\" />\n  <text x=\"20\" y=\"50\" font-family=\"Arial\" font-size=\"14\">Your text here</text>\n</svg>\n```\n\nReturn SVG as Buffer via:\n```typescript\nconst svgBuffer = Buffer.from(svgString, 'utf-8');\n```\n\n### ExportService (`backend/src/services/exportService.ts`) - NEW FILE\n\nImplement export to PNG, JPG, PDF formats.\n\n```typescript\nexport class ExportService {\n  async exportPNG(\n    layout: ComposedLayout,\n    filepath: string,\n    compression: 'low' | 'medium' | 'high'\n  ): Promise<void>\n\n  async exportJPG(\n    layout: ComposedLayout,\n    filepath: string,\n    quality: number  // 60-95\n  ): Promise<void>\n\n  async exportPDF(\n    layout: ComposedLayout,\n    filepath: string,\n    metadata: { title?: string; author?: string }\n  ): Promise<void>\n}\n```\n\n**exportPNG():**\n```typescript\nasync exportPNG(layout, filepath, compression) {\n  const compressionLevel = compression === 'high' ? 9 : compression === 'medium' ? 6 : 1;\n  await sharp(layout.buffer)\n    .png({ compressionLevel })\n    .toFile(filepath);\n}\n```\n\n**exportJPG():**\n```typescript\nasync exportJPG(layout, filepath, quality = 80) {\n  await sharp(layout.buffer)\n    .jpeg({ quality, mozjpeg: true })\n    .toFile(filepath);\n}\n```\n\n**exportPDF():**\nRequires pdfkit library:\n```typescript\nimport PDFDocument from 'pdfkit';\nimport { createWriteStream } from 'fs';\n\nasync exportPDF(layout, filepath, metadata = {}) {\n  const doc = new PDFDocument({\n    size: [layout.width, layout.height]\n  });\n\n  if (metadata.title) doc.title(metadata.title);\n  if (metadata.author) doc.author(metadata.author);\n\n  // Add image to PDF\n  doc.image(layout.buffer, 0, 0, {\n    width: layout.width,\n    height: layout.height\n  });\n\n  doc.pipe(createWriteStream(filepath));\n  doc.end();\n}\n```\n\n### Route Handler Integration\n\nImplement in `backend/src/routes/manga.ts`:\n\n**POST /api/manga/:projectId/layout**\n```typescript\nrouter.post('/:projectId/layout', async (req: Request, res: Response, next: NextFunction) => {\n  try {\n    const { projectId } = req.params;\n    const { speechBubbles } = req.body as GenerateLayoutRequest;\n\n    // Fetch project and panels from DB\n    const project = await getProject(projectId);\n    if (!project) throw new NotFoundError('Project');\n\n    // Get panel image paths\n    const panelPaths = project.panels\n      .sort((a, b) => a.panelIndex - b.panelIndex)\n      .map(p => p.imageFilePath)\n      .filter(path => path !== undefined);\n\n    // Compose layout\n    const layoutEngine = new LayoutEngine();\n    let layout = await layoutEngine.composePanels(panelPaths, project.layoutConfig);\n\n    // Add speech bubbles if provided\n    if (speechBubbles && speechBubbles.length > 0) {\n      layout = await layoutEngine.addSpeechBubbles(layout, speechBubbles);\n    }\n\n    // Save layout buffer to temporary file for preview\n    const layoutPath = path.join(CONFIG.STORAGE_PATH, projectId, 'layout.png');\n    await fs.writeFile(layoutPath, layout.buffer);\n\n    // Update project status\n    await updateProject(projectId, { status: 'complete' });\n\n    // Return layout info\n    res.json({\n      message: 'Layout composed successfully',\n      projectId,\n      layoutPath: `/uploads/${projectId}/layout.png`,\n      panelPositions: layout.panelPositions,\n      dimensions: { width: layout.width, height: layout.height }\n    });\n  } catch (err) {\n    next(err);\n  }\n});\n```\n\n**POST /api/manga/:projectId/export**\n```typescript\nrouter.post('/:projectId/export', async (req: Request, res: Response, next: NextFunction) => {\n  try {\n    const { projectId } = req.params;\n    const { format, compression, resolution, title, author } = req.body as ExportRequest;\n\n    // Fetch project layout\n    const layoutPath = path.join(CONFIG.STORAGE_PATH, projectId, 'layout.png');\n    if (!fs.existsSync(layoutPath)) {\n      throw new Error('Layout not yet generated. Call /layout endpoint first.');\n    }\n\n    const layoutBuffer = await fs.promises.readFile(layoutPath);\n    const layout: ComposedLayout = {\n      buffer: layoutBuffer,\n      width: 800,  // From project.layoutConfig\n      height: 1200,\n      format: 'png',\n      panelPositions: []  // Could fetch from DB if needed\n    };\n\n    // Export to requested format\n    const exportService = new ExportService();\n    const timestamp = Date.now();\n    const exportPath = path.join(CONFIG.STORAGE_PATH, projectId, `manga_${timestamp}.${format}`);\n\n    if (format === 'png') {\n      await exportService.exportPNG(layout, exportPath, compression as 'low' | 'medium' | 'high');\n    } else if (format === 'jpg') {\n      const qualityMap = { low: 60, medium: 80, high: 95 };\n      await exportService.exportJPG(layout, exportPath, qualityMap[compression]);\n    } else if (format === 'pdf') {\n      await exportService.exportPDF(layout, exportPath, { title, author });\n    }\n\n    // Update project status\n    await updateProject(projectId, { status: 'exported' });\n\n    res.json({\n      message: 'Export successful',\n      projectId,\n      format,\n      downloadUrl: `/uploads/${projectId}/manga_${timestamp}.${format}`,\n      filePath: exportPath\n    });\n  } catch (err) {\n    next(err);\n  }\n});\n```\n\n### Testing Requirements\n\n```bash\n# 1. Generate layout from Task 3 images\nPROJECT_ID=\"test-project-id\"\ncurl -X POST http://localhost:5000/api/manga/$PROJECT_ID/layout \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\n    \"speechBubbles\": [\n      {\n        \"panelIndex\": 0,\n        \"text\": \"Wow!\",\n        \"position\": \"top\",\n        \"style\": \"rounded\"\n      }\n    ]\n  }'\n\n# 2. View composed layout\nopen http://localhost:5000/uploads/$PROJECT_ID/layout.png\n\n# 3. Export to PNG\ncurl -X POST http://localhost:5000/api/manga/$PROJECT_ID/export \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\n    \"format\": \"png\",\n    \"compression\": \"medium\",\n    \"resolution\": \"web\",\n    \"title\": \"My Manga\"\n  }'\n\n# 4. Export to PDF\ncurl -X POST http://localhost:5000/api/manga/$PROJECT_ID/export \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\n    \"format\": \"pdf\",\n    \"compression\": \"medium\",\n    \"title\": \"My Manga\",\n    \"author\": \"AI Creator\"\n  }'\n\n# 5. Verify files exist\nls -lh uploads/$PROJECT_ID/\n```\n\n### Files This Task Provides to Other Agents\n\n- **Composed layout image** - Used by frontend for preview\n- **Export files** - PNG/JPG/PDF outputs for download\n- **Layout metadata** - Panel positions for debugging/display\n\n### Output Validation Checklist\n\n- [ ] calculateGrid() and calculatePanelPositions() methods work correctly\n- [ ] composePanels() successfully combines images with sharp\n- [ ] Borders render correctly around panels\n- [ ] Speech bubbles overlay without distortion\n- [ ] Multiple speech bubble styles work ('rounded', 'cloud', 'spiked', 'rectangular')\n- [ ] Layout PNG saved and readable\n- [ ] exportPNG() produces valid PNG files\n- [ ] exportJPG() produces valid JPG files with quality control\n- [ ] exportPDF() produces valid PDF with metadata\n- [ ] /layout endpoint returns correct panel positions\n- [ ] /export endpoint returns download URLs\n- [ ] Compression settings affect file size appropriately\n- [ ] No TypeScript compilation errors\n\n---\n\n## Task 5: React (Agent E)\n### Complete React UI with Component Implementation\n\n**Time Estimate:** 60-80 minutes\n**Difficulty:** Intermediate (React component patterns)\n**Dependencies:** Tasks 1-4 (backend API must be running)\n\n### Objective\nComplete all React components for the koma-fill frontend including image upload with drag-drop, story prompt editor, panel grid with drag-and-drop reordering, complete manga generation workflow orchestration, real-time SSE progress updates, and multi-format export options. Configure Tailwind CSS for styling.\n\n### Target Files to Create/Modify\n\n```\nfrontend/\n src/\n    components/\n       ImageUploader.tsx           [IMPLEMENT] Dropzone with position selector\n       StoryPromptEditor.tsx       [ENHANCE] Add sample prompts\n       PanelGrid.tsx               [IMPLEMENT] Drag-and-drop reordering\n       LayoutSelector.tsx          [VERIFY] Layout config UI\n       ExportOptions.tsx           [VERIFY] Export format selection\n       ProgressBar.tsx             [CREATE] Real-time progress display\n    hooks/\n       useMangaGeneration.ts       [IMPLEMENT] Full workflow orchestration\n    services/\n       apiClient.ts                [IMPLEMENT] API client with SSE support\n    pages/\n       CreateMangaPage.tsx         [IMPLEMENT] Main workflow page\n       PreviewPage.tsx             [IMPLEMENT] Result preview & download\n    App.tsx                         [UPDATE] Routing\n    main.tsx                        [VERIFY] Entry point\n    index.css                       [UPDATE] Tailwind directives\n tailwind.config.js                  [CREATE] Tailwind configuration\n postcss.config.js                   [CREATE] PostCSS configuration\n package.json                        [UPDATE] Add Tailwind dependencies\n tsconfig.json                       [VERIFY] TypeScript config\n```\n\n### TypeScript Interfaces (from `frontend/src/types/index.ts`)\n\nAlready defined - reference for component props.\n\n### Implementation Details\n\n#### 1. Tailwind CSS Setup\n\n**Install Dependencies:**\n```bash\ncd frontend\nnpm install -D tailwindcss postcss autoprefixer\nnpx tailwindcss init -p\n```\n\n**tailwind.config.js:**\n```javascript\nexport default {\n  content: [\n    './index.html',\n    './src/**/*.{js,ts,jsx,tsx}',\n  ],\n  theme: {\n    extend: {\n      colors: {\n        manga: {\n          dark: '#1a1a1a',\n          light: '#f5f5f5',\n        }\n      }\n    },\n  },\n  plugins: [],\n}\n```\n\n**postcss.config.js:**\n```javascript\nexport default {\n  plugins: {\n    tailwindcss: {},\n    autoprefixer: {},\n  },\n}\n```\n\n**frontend/src/index.css:**\n```css\n@tailwind base;\n@tailwind components;\n@tailwind utilities;\n\n@layer components {\n  .btn-primary {\n    @apply px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700 transition;\n  }\n  .btn-secondary {\n    @apply px-4 py-2 bg-gray-300 text-gray-800 rounded-lg hover:bg-gray-400 transition;\n  }\n  .input-field {\n    @apply w-full px-3 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500;\n  }\n}\n```\n\n#### 2. API Client (`frontend/src/services/apiClient.ts`)\n\n```typescript\nimport { MangaProject, Panel, GenerationProgress, ProgressEvent } from '../types';\n\nconst API_BASE = import.meta.env.VITE_API_URL || 'http://localhost:5000/api';\n\nexport class APIClient {\n  /**\n   * Create new manga project\n   */\n  async createProject(name: string, storyPrompt: string, layoutConfig?: any) {\n    const response = await fetch(`${API_BASE}/manga/create`, {\n      method: 'POST',\n      headers: { 'Content-Type': 'application/json' },\n      body: JSON.stringify({\n        projectName: name,\n        storyPrompt,\n        layoutConfig\n      })\n    });\n    if (!response.ok) throw new Error(await response.text());\n    return response.json() as Promise<MangaProject>;\n  }\n\n  /**\n   * Upload key images\n   */\n  async uploadImages(projectId: string, files: File[]) {\n    const formData = new FormData();\n    files.forEach(file => formData.append('images', file));\n\n    const response = await fetch(`${API_BASE}/manga/${projectId}/upload`, {\n      method: 'POST',\n      body: formData\n    });\n    if (!response.ok) throw new Error(await response.text());\n    return response.json();\n  }\n\n  /**\n   * Analyze images using Vision API\n   */\n  async analyzeImages(projectId: string, depth: 'quick' | 'detailed' = 'quick') {\n    const response = await fetch(`${API_BASE}/manga/${projectId}/analyze`, {\n      method: 'POST',\n      headers: { 'Content-Type': 'application/json' },\n      body: JSON.stringify({ analysisDepth: depth })\n    });\n    if (!response.ok) throw new Error(await response.text());\n    return response.json();\n  }\n\n  /**\n   * Generate panel prompts\n   */\n  async generatePrompts(projectId: string, storyPrompt: string, panelCount: number) {\n    const response = await fetch(`${API_BASE}/manga/${projectId}/generate-prompts`, {\n      method: 'POST',\n      headers: { 'Content-Type': 'application/json' },\n      body: JSON.stringify({\n        storyPrompt,\n        panelCount,\n        characterConsistency: true\n      })\n    });\n    if (!response.ok) throw new Error(await response.text());\n    return response.json() as Promise<Panel[]>;\n  }\n\n  /**\n   * Generate images via DALL-E 3 (SSE streaming)\n   */\n  streamImageGeneration(\n    projectId: string,\n    batchMode: 'sequential' | 'parallel',\n    onProgress: (event: ProgressEvent) => void,\n    onError: (error: Error) => void\n  ): () => void {\n    const eventSource = new EventSource(\n      `${API_BASE}/manga/${projectId}/generate-images?batchMode=${batchMode}`\n    );\n\n    eventSource.onmessage = (event) => {\n      try {\n        const data = JSON.parse(event.data);\n        onProgress(data);\n      } catch (e) {\n        console.error('Failed to parse SSE message:', e);\n      }\n    };\n\n    eventSource.onerror = () => {\n      onError(new Error('Generation failed or connection lost'));\n      eventSource.close();\n    };\n\n    // Return cleanup function\n    return () => eventSource.close();\n  }\n\n  /**\n   * Compose layout with speech bubbles\n   */\n  async composeLayout(projectId: string, speechBubbles?: any) {\n    const response = await fetch(`${API_BASE}/manga/${projectId}/layout`, {\n      method: 'POST',\n      headers: { 'Content-Type': 'application/json' },\n      body: JSON.stringify({ speechBubbles })\n    });\n    if (!response.ok) throw new Error(await response.text());\n    return response.json();\n  }\n\n  /**\n   * Export to PNG/JPG/PDF\n   */\n  async exportManga(\n    projectId: string,\n    format: 'png' | 'jpg' | 'pdf',\n    compression: 'low' | 'medium' | 'high' = 'medium',\n    title?: string,\n    author?: string\n  ) {\n    const response = await fetch(`${API_BASE}/manga/${projectId}/export`, {\n      method: 'POST',\n      headers: { 'Content-Type': 'application/json' },\n      body: JSON.stringify({\n        format,\n        compression,\n        resolution: 'web',\n        title,\n        author\n      })\n    });\n    if (!response.ok) throw new Error(await response.text());\n    return response.json();\n  }\n\n  /**\n   * Fetch project details\n   */\n  async getProject(projectId: string) {\n    const response = await fetch(`${API_BASE}/manga/${projectId}`);\n    if (!response.ok) throw new Error(await response.text());\n    return response.json() as Promise<MangaProject>;\n  }\n\n  /**\n   * Reorder panels\n   */\n  async reorderPanels(projectId: string, panelOrder: number[]) {\n    const response = await fetch(`${API_BASE}/manga/${projectId}/reorder`, {\n      method: 'PUT',\n      headers: { 'Content-Type': 'application/json' },\n      body: JSON.stringify({ panelOrder })\n    });\n    if (!response.ok) throw new Error(await response.text());\n    return response.json();\n  }\n}\n\nexport const apiClient = new APIClient();\n```\n\n#### 3. useMangaGeneration Hook (`frontend/src/hooks/useMangaGeneration.ts`)\n\n```typescript\nimport { useState, useCallback } from 'react';\nimport { apiClient } from '../services/apiClient';\nimport { MangaProject, GenerationProgress, UploadedImage } from '../types';\n\nexport function useMangaGeneration() {\n  const [project, setProject] = useState<MangaProject | null>(null);\n  const [progress, setProgress] = useState<GenerationProgress>({\n    stage: 'idle',\n    currentStep: 0,\n    totalSteps: 0,\n    percentage: 0,\n    message: ''\n  });\n  const [error, setError] = useState<string | null>(null);\n\n  /**\n   * Complete workflow: Create  Upload  Analyze  Generate Prompts  Generate Images  Layout\n   */\n  const generateManga = useCallback(async (\n    projectName: string,\n    storyPrompt: string,\n    uploadedImages: UploadedImage[],\n    layoutConfig: any,\n    generationSettings: any\n  ) => {\n    try {\n      setError(null);\n\n      // Stage 1: Create project\n      setProgress({\n        stage: 'uploading',\n        currentStep: 0,\n        totalSteps: 5,\n        percentage: 20,\n        message: 'Creating project...'\n      });\n      const newProject = await apiClient.createProject(projectName, storyPrompt, layoutConfig);\n      setProject(newProject);\n\n      // Stage 2: Upload images\n      setProgress({\n        stage: 'uploading',\n        currentStep: 1,\n        totalSteps: 5,\n        percentage: 40,\n        message: 'Uploading reference images...'\n      });\n      const files = uploadedImages.map(img => img.file);\n      await apiClient.uploadImages(newProject.id, files);\n\n      // Stage 3: Analyze images\n      setProgress({\n        stage: 'analyzing',\n        currentStep: 2,\n        totalSteps: 5,\n        percentage: 60,\n        message: 'Analyzing images with Vision API...'\n      });\n      await apiClient.analyzeImages(newProject.id, 'detailed');\n\n      // Stage 4: Generate prompts\n      setProgress({\n        stage: 'generating_prompts',\n        currentStep: 3,\n        totalSteps: 5,\n        percentage: 70,\n        message: 'Generating panel prompts...'\n      });\n      await apiClient.generatePrompts(\n        newProject.id,\n        storyPrompt,\n        layoutConfig.totalPanels\n      );\n\n      // Stage 5: Generate images (with SSE streaming)\n      setProgress({\n        stage: 'generating_images',\n        currentStep: 4,\n        totalSteps: 5,\n        percentage: 75,\n        message: 'Starting image generation...'\n      });\n\n      await new Promise<void>((resolve, reject) => {\n        const cleanup = apiClient.streamImageGeneration(\n          newProject.id,\n          'sequential',  // or 'parallel' based on user preference\n          (progressEvent) => {\n            if (progressEvent.type === 'complete') {\n              setProgress(prev => ({\n                ...prev,\n                percentage: 90,\n                message: 'Image generation complete!'\n              }));\n              resolve();\n            } else if (progressEvent.type === 'error') {\n              reject(new Error(progressEvent.error || 'Generation failed'));\n            } else {\n              setProgress({\n                stage: 'generating_images',\n                currentStep: 4 + (progressEvent.currentStep || 0) * 0.1,\n                totalSteps: 5,\n                percentage: 75 + (progressEvent.percentage || 0) * 0.15,\n                message: progressEvent.message,\n                currentPanelIndex: progressEvent.panelIndex\n              });\n            }\n          },\n          reject\n        );\n      });\n\n      // Stage 6: Compose layout\n      setProgress({\n        stage: 'composing_layout',\n        currentStep: 5,\n        totalSteps: 5,\n        percentage: 95,\n        message: 'Composing final layout...'\n      });\n      await apiClient.composeLayout(newProject.id);\n\n      // Complete\n      const finalProject = await apiClient.getProject(newProject.id);\n      setProject(finalProject);\n      setProgress({\n        stage: 'idle',\n        currentStep: 5,\n        totalSteps: 5,\n        percentage: 100,\n        message: 'Manga generation complete!'\n      });\n\n    } catch (err) {\n      const errorMsg = err instanceof Error ? err.message : 'Unknown error';\n      setError(errorMsg);\n      setProgress({\n        stage: 'idle',\n        currentStep: 0,\n        totalSteps: 0,\n        percentage: 0,\n        message: `Error: ${errorMsg}`\n      });\n    }\n  }, []);\n\n  const exportManga = useCallback(async (\n    projectId: string,\n    format: 'png' | 'jpg' | 'pdf',\n    compression: 'low' | 'medium' | 'high' = 'medium'\n  ) => {\n    try {\n      setError(null);\n      setProgress({\n        stage: 'exporting',\n        currentStep: 0,\n        totalSteps: 1,\n        percentage: 50,\n        message: `Exporting as ${format.toUpperCase()}...`\n      });\n\n      const result = await apiClient.exportManga(projectId, format, compression);\n\n      setProgress({\n        stage: 'idle',\n        currentStep: 1,\n        totalSteps: 1,\n        percentage: 100,\n        message: 'Export complete!'\n      });\n\n      return result;\n    } catch (err) {\n      const errorMsg = err instanceof Error ? err.message : 'Export failed';\n      setError(errorMsg);\n      throw err;\n    }\n  }, []);\n\n  return {\n    project,\n    progress,\n    error,\n    generateManga,\n    exportManga,\n    setError\n  };\n}\n```\n\n#### 4. Components\n\n**ImageUploader.tsx:**\n```typescript\nimport { useCallback, useState } from 'react';\nimport { UploadedImage, ImagePosition } from '../types';\n\ninterface ImageUploaderProps {\n  onImagesSelected: (images: UploadedImage[]) => void;\n}\n\nexport function ImageUploader({ onImagesSelected }: ImageUploaderProps) {\n  const [images, setImages] = useState<UploadedImage[]>([]);\n  const [selectedPosition, setSelectedPosition] = useState<ImagePosition>('start');\n\n  const handleDrop = useCallback((e: React.DragEvent) => {\n    e.preventDefault();\n    const files = Array.from(e.dataTransfer.files).filter(f => f.type.startsWith('image/'));\n    addImages(files);\n  }, []);\n\n  const handleFileInput = (e: React.ChangeEvent<HTMLInputElement>) => {\n    if (e.target.files) {\n      addImages(Array.from(e.target.files));\n    }\n  };\n\n  const addImages = (files: File[]) => {\n    const newImages = files.map(file => ({\n      file,\n      previewUrl: URL.createObjectURL(file),\n      position: selectedPosition\n    }));\n    setImages(prev => [...prev, ...newImages]);\n    onImagesSelected([...images, ...newImages]);\n  };\n\n  const removeImage = (index: number) => {\n    const updated = images.filter((_, i) => i !== index);\n    setImages(updated);\n    onImagesSelected(updated);\n  };\n\n  return (\n    <div className=\"w-full max-w-2xl\">\n      <div\n        onDrop={handleDrop}\n        onDragOver={e => e.preventDefault()}\n        className=\"border-2 border-dashed border-gray-300 rounded-lg p-8 text-center cursor-pointer hover:border-blue-500 transition\"\n      >\n        <p className=\"text-gray-600 mb-4\">Drag and drop images here or click to select</p>\n        <input\n          type=\"file\"\n          multiple\n          accept=\"image/*\"\n          onChange={handleFileInput}\n          className=\"hidden\"\n          id=\"image-input\"\n        />\n        <label htmlFor=\"image-input\" className=\"btn-primary cursor-pointer\">\n          Select Images\n        </label>\n      </div>\n\n      <div className=\"mt-4\">\n        <label className=\"block mb-2\">Position in Story:</label>\n        <select\n          value={selectedPosition}\n          onChange={e => setSelectedPosition(e.target.value as ImagePosition)}\n          className=\"input-field\"\n        >\n          <option value=\"start\">Start (Reference)</option>\n          <option value=\"end\">End (Reference)</option>\n          <option value={1}>Panel 1</option>\n          <option value={2}>Panel 2</option>\n        </select>\n      </div>\n\n      {images.length > 0 && (\n        <div className=\"mt-6 grid grid-cols-2 gap-4\">\n          {images.map((img, idx) => (\n            <div key={idx} className=\"relative\">\n              <img src={img.previewUrl} alt={`Preview ${idx}`} className=\"rounded-lg w-full h-48 object-cover\" />\n              <button\n                onClick={() => removeImage(idx)}\n                className=\"absolute top-2 right-2 bg-red-500 text-white rounded-full w-6 h-6 flex items-center justify-center hover:bg-red-600\"\n              >\n                \n              </button>\n            </div>\n          ))}\n        </div>\n      )}\n    </div>\n  );\n}\n```\n\n**StoryPromptEditor.tsx (Enhanced):**\n```typescript\nimport { useState } from 'react';\n\ninterface StoryPromptEditorProps {\n  value: string;\n  onChange: (value: string) => void;\n}\n\nconst SAMPLE_PROMPTS = [\n  'A young ninja discovers their hidden powers and must save their village from a mysterious threat.',\n  'Two rival chefs compete in a cooking tournament, discovering they have more in common than they thought.',\n  'A time traveler must prevent a catastrophic event by gathering clues from different eras.',\n];\n\nexport function StoryPromptEditor({ value, onChange }: StoryPromptEditorProps) {\n  const [isExpanded, setIsExpanded] = useState(false);\n\n  return (\n    <div className=\"w-full max-w-2xl\">\n      <label className=\"block text-lg font-semibold mb-2\">Your Story Prompt</label>\n\n      <textarea\n        value={value}\n        onChange={e => onChange(e.target.value)}\n        placeholder=\"Write your manga story here. Be descriptive about characters, setting, and plot...\"\n        className=\"input-field h-32 resize-none\"\n      />\n\n      <div className=\"mt-4\">\n        <button\n          onClick={() => setIsExpanded(!isExpanded)}\n          className=\"text-blue-600 hover:underline text-sm\"\n        >\n          {isExpanded ? 'Hide' : 'Show'} Sample Prompts\n        </button>\n\n        {isExpanded && (\n          <div className=\"mt-3 space-y-2\">\n            {SAMPLE_PROMPTS.map((prompt, idx) => (\n              <button\n                key={idx}\n                onClick={() => onChange(prompt)}\n                className=\"block w-full text-left p-3 bg-gray-100 hover:bg-gray-200 rounded-lg text-sm transition\"\n              >\n                {prompt}\n              </button>\n            ))}\n          </div>\n        )}\n      </div>\n    </div>\n  );\n}\n```\n\n**PanelGrid.tsx (with Drag-and-Drop):**\n```typescript\nimport { useState } from 'react';\nimport { Panel } from '../types';\nimport { DndContext, closestCenter, KeyboardSensor, PointerSensor, useSensor, useSensors } from '@dnd-kit/core';\nimport { SortableContext, sortableKeyboardCoordinates, verticalListSortingStrategy, useSortable } from '@dnd-kit/sortable';\nimport { CSS } from '@dnd-kit/utilities';\n\nfunction SortablePanel({ panel }: { panel: Panel }) {\n  const { attributes, listeners, setNodeRef, transform, transition } = useSortable({ id: panel.id });\n  const style = { transform: CSS.Transform.toString(transform), transition };\n\n  return (\n    <div ref={setNodeRef} style={style} {...attributes} {...listeners} className=\"p-4\">\n      <div className=\"bg-white rounded-lg shadow p-4 cursor-grab active:cursor-grabbing\">\n        <img\n          src={panel.imageUrl}\n          alt={`Panel ${panel.panelIndex}`}\n          className=\"w-full h-auto rounded mb-2\"\n        />\n        <p className=\"text-sm text-gray-600\">{panel.storyBeat}</p>\n        <span className={`inline-block mt-2 px-2 py-1 rounded text-xs text-white ${\n          panel.status === 'generated' ? 'bg-green-500' :\n          panel.status === 'pending' ? 'bg-blue-500' :\n          'bg-red-500'\n        }`}>\n          {panel.status}\n        </span>\n      </div>\n    </div>\n  );\n}\n\ninterface PanelGridProps {\n  panels: Panel[];\n  onReorder: (newOrder: Panel[]) => void;\n}\n\nexport function PanelGrid({ panels, onReorder }: PanelGridProps) {\n  const sensors = useSensors(\n    useSensor(PointerSensor),\n    useSensor(KeyboardSensor, { coordinateGetter: sortableKeyboardCoordinates })\n  );\n\n  const handleDragEnd = (event: any) => {\n    const { active, over } = event;\n    if (over && active.id !== over.id) {\n      const oldIndex = panels.findIndex(p => p.id === active.id);\n      const newIndex = panels.findIndex(p => p.id === over.id);\n      const newPanels = [...panels];\n      [newPanels[oldIndex], newPanels[newIndex]] = [newPanels[newIndex], newPanels[oldIndex]];\n      onReorder(newPanels);\n    }\n  };\n\n  return (\n    <DndContext sensors={sensors} collisionDetection={closestCenter} onDragEnd={handleDragEnd}>\n      <SortableContext items={panels.map(p => p.id)} strategy={verticalListSortingStrategy}>\n        <div className=\"grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-4\">\n          {panels.map(panel => (\n            <SortablePanel key={panel.id} panel={panel} />\n          ))}\n        </div>\n      </SortableContext>\n    </DndContext>\n  );\n}\n```\n\n**ProgressBar.tsx:**\n```typescript\nimport { GenerationProgress } from '../types';\n\nexport function ProgressBar({ progress }: { progress: GenerationProgress }) {\n  return (\n    <div className=\"w-full max-w-2xl\">\n      <div className=\"mb-2 flex justify-between\">\n        <span className=\"text-sm font-semibold\">{progress.message}</span>\n        <span className=\"text-sm text-gray-600\">{Math.round(progress.percentage)}%</span>\n      </div>\n      <div className=\"w-full h-3 bg-gray-200 rounded-full overflow-hidden\">\n        <div\n          className=\"h-full bg-blue-600 transition-all duration-300\"\n          style={{ width: `${progress.percentage}%` }}\n        />\n      </div>\n    </div>\n  );\n}\n```\n\n#### 5. Pages\n\n**CreateMangaPage.tsx:**\n```typescript\nimport { useState } from 'react';\nimport { ImageUploader } from '../components/ImageUploader';\nimport { StoryPromptEditor } from '../components/StoryPromptEditor';\nimport { LayoutSelector } from '../components/LayoutSelector';\nimport { ProgressBar } from '../components/ProgressBar';\nimport { useMangaGeneration } from '../hooks/useMangaGeneration';\nimport { UploadedImage, LayoutConfig } from '../types';\n\nexport function CreateMangaPage() {\n  const [projectName, setProjectName] = useState('');\n  const [storyPrompt, setStoryPrompt] = useState('');\n  const [uploadedImages, setUploadedImages] = useState<UploadedImage[]>([]);\n  const [layoutConfig, setLayoutConfig] = useState<LayoutConfig>({\n    totalPanels: 4,\n    format: 'vertical',\n    readingOrder: 'japanese',\n    gutterSize: 10,\n    borderWidth: 2,\n    borderColor: '#000000',\n    backgroundColor: '#FFFFFF',\n    pageWidth: 800,\n    pageHeight: 1200\n  });\n\n  const { progress, error, generateManga } = useMangaGeneration();\n\n  const handleStart = async () => {\n    if (!projectName || !storyPrompt) {\n      alert('Please enter project name and story prompt');\n      return;\n    }\n\n    await generateManga(projectName, storyPrompt, uploadedImages, layoutConfig, {\n      imageStyle: 'manga style',\n      aspectRatio: 'square',\n      qualityLevel: 'standard'\n    });\n  };\n\n  return (\n    <div className=\"min-h-screen bg-gray-50 py-12 px-4\">\n      <div className=\"max-w-4xl mx-auto space-y-8\">\n        <h1 className=\"text-4xl font-bold text-center mb-2\">koma-fill</h1>\n        <p className=\"text-center text-gray-600\">AI-Powered Manga Panel Generator</p>\n\n        {error && <div className=\"bg-red-100 border border-red-400 text-red-700 px-4 py-3 rounded\">{error}</div>}\n\n        {progress.stage === 'idle' ? (\n          <div className=\"space-y-8\">\n            <div className=\"bg-white p-6 rounded-lg shadow\">\n              <label className=\"block text-lg font-semibold mb-2\">Project Name</label>\n              <input\n                type=\"text\"\n                value={projectName}\n                onChange={e => setProjectName(e.target.value)}\n                className=\"input-field\"\n                placeholder=\"My Awesome Manga\"\n              />\n            </div>\n\n            <div className=\"bg-white p-6 rounded-lg shadow\">\n              <StoryPromptEditor value={storyPrompt} onChange={setStoryPrompt} />\n            </div>\n\n            <div className=\"bg-white p-6 rounded-lg shadow\">\n              <ImageUploader onImagesSelected={setUploadedImages} />\n            </div>\n\n            <div className=\"bg-white p-6 rounded-lg shadow\">\n              <LayoutSelector config={layoutConfig} onChange={setLayoutConfig} />\n            </div>\n\n            <button onClick={handleStart} className=\"btn-primary w-full text-lg py-3\">\n              Generate Manga\n            </button>\n          </div>\n        ) : (\n          <div className=\"bg-white p-6 rounded-lg shadow\">\n            <ProgressBar progress={progress} />\n          </div>\n        )}\n      </div>\n    </div>\n  );\n}\n```\n\n**PreviewPage.tsx:**\n```typescript\nimport { useParams, useNavigate } from 'react-router-dom';\nimport { useEffect, useState } from 'react';\nimport { apiClient } from '../services/apiClient';\nimport { PanelGrid } from '../components/PanelGrid';\nimport { ExportOptions } from '../components/ExportOptions';\nimport { MangaProject } from '../types';\n\nexport function PreviewPage() {\n  const { projectId } = useParams<{ projectId: string }>();\n  const navigate = useNavigate();\n  const [project, setProject] = useState<MangaProject | null>(null);\n  const [loading, setLoading] = useState(true);\n\n  useEffect(() => {\n    if (projectId) {\n      apiClient.getProject(projectId).then(setProject).finally(() => setLoading(false));\n    }\n  }, [projectId]);\n\n  if (loading) return <div className=\"flex justify-center py-12\">Loading...</div>;\n  if (!project) return <div className=\"text-center py-12\">Project not found</div>;\n\n  return (\n    <div className=\"min-h-screen bg-gray-50 py-12 px-4\">\n      <div className=\"max-w-6xl mx-auto\">\n        <button onClick={() => navigate('/')} className=\"btn-secondary mb-6\"> Back</button>\n\n        <h1 className=\"text-3xl font-bold mb-2\">{project.name}</h1>\n        <p className=\"text-gray-600 mb-6\">Project Status: {project.status}</p>\n\n        {project.panels.length > 0 && (\n          <div className=\"bg-white p-6 rounded-lg shadow mb-8\">\n            <h2 className=\"text-2xl font-semibold mb-4\">Panels</h2>\n            <PanelGrid panels={project.panels} onReorder={() => {}} />\n          </div>\n        )}\n\n        <div className=\"bg-white p-6 rounded-lg shadow\">\n          <h2 className=\"text-2xl font-semibold mb-4\">Export</h2>\n          <ExportOptions projectId={project.id} />\n        </div>\n      </div>\n    </div>\n  );\n}\n```\n\n#### 6. Update App.tsx\n\n```typescript\nimport { BrowserRouter as Router, Routes, Route, Navigate } from 'react-router-dom';\nimport { CreateMangaPage } from './pages/CreateMangaPage';\nimport { PreviewPage } from './pages/PreviewPage';\nimport './index.css';\n\nexport default function App() {\n  return (\n    <Router>\n      <Routes>\n        <Route path=\"/\" element={<CreateMangaPage />} />\n        <Route path=\"/project/:projectId\" element={<PreviewPage />} />\n        <Route path=\"*\" element={<Navigate to=\"/\" />} />\n      </Routes>\n    </Router>\n  );\n}\n```\n\n### package.json Updates\n\nAdd dependencies:\n```bash\nnpm install -D tailwindcss postcss autoprefixer\nnpm install react-router-dom @dnd-kit/core @dnd-kit/sortable @dnd-kit/utilities\n```\n\n### Testing Requirements\n\n```bash\n# 1. Start backend (from Task 1)\ncd backend && npm run dev\n\n# 2. In another terminal, start frontend\ncd frontend && npm run dev\n\n# 3. Open browser: http://localhost:3000\n\n# 4. Test workflow:\n# - Enter project name and story\n# - Upload reference images\n# - Configure layout\n# - Click \"Generate Manga\"\n# - Watch progress bar\n# - See panel grid with images\n# - Export to PNG/JPG/PDF\n```\n\n### Files This Task Uses from Other Agents\n\n- **API endpoints** from Task 1 (database & routes)\n- **Analysis data** from Task 2 (character consistency)\n- **Generated images** from Task 3 (panel images)\n- **Composed layouts** from Task 4 (final manga)\n\n### Output Validation Checklist\n\n- [ ] Tailwind CSS configured and working\n- [ ] ImageUploader component with drag-drop works\n- [ ] react-dropzone integration functional\n- [ ] StoryPromptEditor displays with sample prompts\n- [ ] Sample prompt insertion works\n- [ ] PanelGrid displays with drag-and-drop reordering\n- [ ] @dnd-kit integration functional\n- [ ] useMangaGeneration hook orchestrates full workflow\n- [ ] SSE progress streaming displays correctly\n- [ ] ProgressBar updates in real-time\n- [ ] apiClient makes correct API calls\n- [ ] All components have TypeScript types\n- [ ] CreateMangaPage workflow complete\n- [ ] PreviewPage shows generated manga\n- [ ] ExportOptions functional (PNG/JPG/PDF)\n- [ ] Routing works (create  preview)\n- [ ] Error handling displays user-friendly messages\n- [ ] npm run dev starts without errors\n- [ ] No TypeScript compilation errors\n\n---\n\n## Integration Testing (After All Tasks Complete)\n\nAfter all 5 agents finish their implementations, run the following integration tests:\n\n```bash\n# 1. Start backend\ncd /mnt/Projects/koma-fill/backend\nnpm install\nnpm run dev\n# Expected: \" koma-fill server running on http://localhost:5000\"\n\n# 2. Start frontend (new terminal)\ncd /mnt/Projects/koma-fill/frontend\nnpm install\nnpm run dev\n# Expected: \"VITE  ready in XXX ms\"\n\n# 3. Complete workflow test\n# Open http://localhost:3000 in browser\n# - Create project\n# - Upload 2 reference images\n# - Enter story prompt\n# - Select layout (4 panels)\n# - Click \"Generate Manga\"\n# - Wait for completion\n# - View generated panels\n# - Export to PNG\n# - Verify PNG file created in uploads/\n\n# 4. Verify database\nsqlite3 /mnt/Projects/koma-fill/data/koma-fill.db\n> SELECT COUNT(*) FROM projects;\n> SELECT COUNT(*) FROM panels;\n> SELECT COUNT(*) FROM keyImages;\n\n# 5. Check file structure\nls -la /mnt/Projects/koma-fill/uploads/\nls -la /mnt/Projects/koma-fill/data/\n\n# 6. API health check\ncurl http://localhost:5000/api/health\n# Expected: {\"status\":\"ok\",\"timestamp\":\"...\"}\n```\n\n### Known Integration Points to Verify\n\n- Task 1  Task 2: Panel prompts saved in DB, readable by frontend\n- Task 2  Task 3: Vision analysis influences character consistency in prompts\n- Task 3  Task 4: Generated images saved to disk, paths in database\n- Task 4  Task 5: Layout images served via `/uploads/` static directory\n- Task 5  All: Frontend calls all backend API endpoints successfully\n\n---\n\n## Success Criteria Summary\n\nAll 5 tasks completed when:\n\n1. **Backend (Task 1)**: Express server with SQLite database, all CRUD routes working\n2. **Vision & Prompts (Task 2)**: OpenAI Vision API analyzes images, GPT-4o generates DALL-E prompts\n3. **Image Generation (Task 3)**: DALL-E 3 generates 4+ images with retry logic, SSE progress works\n4. **Layout & Export (Task 4)**: Sharp composes panels into manga layout, exports PNG/JPG/PDF\n5. **Frontend (Task 5)**: React UI allows workflow from story  generated manga  export\n\n**Total Expected Time**: 4-5 hours per agent (can run in parallel)\n**Minimum Test Time**: 30 minutes for integration testing\n\nGood luck, KAMUI agents! \n\n---\n\n*Last Updated: 2025-02-12*\n*For issues or questions, refer to the specific task prompts above*",
        "tooltip": ": ClaudeCode2: # KAMUI-4D Parallel Task Prompts for koma-fill\n## Manga Generation AI System - Multi-Agent Implementation Guide\n\n**Version:** 1.0\n**Project:** koma-fill - AI-powered manga panel generation system\n**Target:** KAMUI-4D Editor (Multi-AI CLI parallel execution)\n\n---\n\n## How to Use These Prompts in KAMUI-4D\n\nThis document contains **5 independent task prompts** designed to run in parallel across multiple AI coding agents. Each prompt is self-contained and can be executed independently without blocking other tasks.\n\n### Setup Instructions\n\n1. **Install dependencies** (run once before starting tasks):\n   ```bash\n   cd /mnt/Projects/koma-fill/backend\n   npm install\n\n   cd /mnt/Projects/koma-fill/frontend\n   npm install\n   ```\n\n2. **Environment Configuration**:\n   Create `/mnt/Projects/koma-fill/.env`:\n   ```\n   NODE_ENV=development\n   PORT=5000\n   BASE_URL=http://localhost:5000\n   OPENAI_API_KEY=your_openai_api_key_here\n   OPENAI_ORG_ID=your_org_id_optional\n   DATABASE_PATH=./data/koma-fill.db\n   STORAGE_PATH=./uploads\n   MAX_IMAGE_SIZE_MB=20\n   DALLE_RATE_LIMIT_PER_MINUTE=5\n   VISION_RATE_LIMIT_PER_MINUTE=30\n   MAX_RETRIES_PER_PANEL=3\n   ALLOWED_ORIGINS=http://localhost:3000\n   ```\n\n3. **Execution Strategy**:\n   - Copy each task prompt below into a separate KAMUI-4D session/agent\n   - **Tasks 1-5 can ALL start simultaneously** (no blocking dependencies)\n   - Each task should run independently in its own AI CLI session\n   - Monitor each agent's progress via console output\n   - **Integration testing** should happen after all 5 tasks complete (see bottom of doc)\n\n4. **Task Dependencies**:\n   ```\n   Task 1 (Backend)  provides database & API contracts\n   Task 2 (Vision)  uses Task 1's API, reads backend/src/models/types.ts\n   Task 3 (Images)  uses Task 1's API, reads backend/src/models/types.ts\n   Task 4 (Layout)  uses Task 1's API, reads backend/src/models/types.ts\n   Task 5 (Frontend)  calls Tasks 1-4 via REST API\n   ```\n   **All tasks can start immediately** - they communicate via file system and API contracts.\n\n---\n\n## Task 1: Backend (Agent A)\n### Express Server, SQLite Database & CRUD Routes Foundation\n\n**Time Estimate:** 45-60 minutes\n**Difficulty:** Intermediate\n**Dependencies:** None (this is the foundation layer)\n\n### Objective\nSet up a fully functional Express.js backend with SQLite database, implement CRUD operations for manga projects and panels, configure file upload handling with multer, and provide a solid API foundation for other agents to build upon.\n\n### Target Files to Create/Modify\n\n```\nbackend/\n src/\n    database/\n       connection.ts          [NEW] SQLite connection & initialization\n       schema.ts              [NEW] Table schema definitions\n    index.ts                   [MODIFY] Add DB initialization\n    app.ts                     [COMPLETE] Already done - verify middleware\n    routes/\n       manga.ts               [IMPLEMENT] Route handlers with DB calls\n    middleware/\n        errorHandler.ts        [VERIFY] Already complete\n uploads/                        [CREATE] Directory for image storage\n data/                           [CREATE] Directory for SQLite DB\n```\n\n### TypeScript Interfaces (from `/mnt/Projects/koma-fill/backend/src/models/types.ts`)\n\nKey types you'll use:\n```typescript\n// Core entities\nMangaProject {\n  id: string;                    // UUID\n  name: string;\n  description?: string;\n  status: ProjectStatus;         // 'draft' | 'analyzing' | 'generating' | 'complete' | 'exported'\n  layoutConfig: LayoutConfig;\n  generationSettings: GenerationSettings;\n  panels: Panel[];\n  keyImages: KeyImage[];\n  totalCost: number;\n  createdAt: string;             // ISO datetime\n  updatedAt: string;\n}\n\nPanel {\n  id: string;                    // UUID\n  projectId: string;\n  panelIndex: number;            // 0-based\n  imageUrl?: string;\n  imageFilePath?: string;\n  prompt?: string;\n  storyBeat?: string;\n  speechBubbleText?: string;\n  status: PanelStatus;           // 'pending' | 'generated' | 'failed' | 'placeholder'\n  retryCount: number;\n  generatedAt?: string;\n  createdAt: string;\n}\n\nKeyImage {\n  id: string;                    // UUID\n  projectId: string;\n  imageFilePath: string;\n  position: ImagePosition;       // 'start' | 'end' | number\n  analysis?: ImageAnalysis;\n  createdAt: string;\n}\n\nLayoutConfig {\n  totalPanels: number;           // 4, 6, 8, etc.\n  format: LayoutFormat;          // 'vertical' | 'horizontal' | 'square'\n  readingOrder: ReadingOrder;    // 'japanese' | 'western'\n  gutterSize: number;            // px\n  borderWidth: number;           // px\n  borderColor: string;           // hex #RRGGBB\n  backgroundColor: string;       // hex\n  pageWidth: number;             // px\n  pageHeight: number;            // px\n}\n\nGenerationSettings {\n  imageStyle: string;            // e.g., \"manga style, black and white ink\"\n  aspectRatio: 'square' | 'wide' | 'tall';\n  qualityLevel: 'standard' | 'hd';\n  negativePrompt?: string;\n  seed?: number;\n}\n```\n\n### Implementation Checklist\n\n#### 1. Create Database Connection Module (`backend/src/database/connection.ts`)\n```typescript\n// Requirements:\n- Initialize better-sqlite3 connection\n- Create/open database at DATABASE_PATH from .env\n- Export initDatabase() async function\n- Enable foreign keys constraint\n- Handle database file creation if needed\n- Connection should be cached/singleton\n```\n\n#### 2. Create Database Schema Module (`backend/src/database/schema.ts`)\n```typescript\n// SQL Schema Requirements:\nCREATE TABLE projects (\n  id TEXT PRIMARY KEY,\n  name TEXT NOT NULL,\n  description TEXT,\n  status TEXT NOT NULL,\n  layoutConfig JSON NOT NULL,\n  generationSettings JSON NOT NULL,\n  totalCost REAL DEFAULT 0,\n  createdAt TEXT NOT NULL,\n  updatedAt TEXT NOT NULL\n);\n\nCREATE TABLE panels (\n  id TEXT PRIMARY KEY,\n  projectId TEXT NOT NULL,\n  panelIndex INTEGER NOT NULL,\n  imageUrl TEXT,\n  imageFilePath TEXT,\n  prompt TEXT,\n  storyBeat TEXT,\n  speechBubbleText TEXT,\n  status TEXT NOT NULL,\n  retryCount INTEGER DEFAULT 0,\n  generatedAt TEXT,\n  createdAt TEXT NOT NULL,\n  FOREIGN KEY (projectId) REFERENCES projects(id)\n);\n\nCREATE TABLE keyImages (\n  id TEXT PRIMARY KEY,\n  projectId TEXT NOT NULL,\n  imageFilePath TEXT NOT NULL,\n  position TEXT NOT NULL,\n  analysis JSON,\n  createdAt TEXT NOT NULL,\n  FOREIGN KEY (projectId) REFERENCES projects(id)\n);\n\nCREATE INDEX idx_project_status ON projects(status);\nCREATE INDEX idx_panel_project ON panels(projectId);\nCREATE INDEX idx_panel_status ON panels(status);\n```\n\n#### 3. Modify `backend/src/index.ts`\n```typescript\n// Add:\n- Import { initDatabase } from './database/connection'\n- Call await initDatabase() before app.listen()\n- Log database initialization success\n```\n\n#### 4. Create Repository Layer (`backend/src/repositories/`)\n```typescript\n// Create:\n- ProjectRepository with methods:\n  - createProject(data: CreateMangaRequest): Promise<MangaProject>\n  - getProject(id: string): Promise<MangaProject | null>\n  - listProjects(limit: number, offset: number): Promise<MangaProject[]>\n  - updateProject(id: string, updates: Partial<MangaProject>): Promise<MangaProject>\n  - deleteProject(id: string): Promise<void>\n\n- PanelRepository with methods:\n  - createPanel(projectId: string, data: Panel): Promise<Panel>\n  - getPanelsByProject(projectId: string): Promise<Panel[]>\n  - getPanel(panelId: string): Promise<Panel | null>\n  - updatePanel(panelId: string, updates: Partial<Panel>): Promise<Panel>\n  - updatePanelStatus(panelId: string, status: PanelStatus): Promise<void>\n\n- KeyImageRepository with methods:\n  - createKeyImage(projectId: string, data: KeyImage): Promise<KeyImage>\n  - getKeyImages(projectId: string): Promise<KeyImage[]>\n  - updateKeyImageAnalysis(imageId: string, analysis: ImageAnalysis): Promise<void>\n```\n\n#### 5. Implement Routes in `backend/src/routes/manga.ts`\nReplace TODO comments with actual implementations:\n\n- **POST /api/manga/create**\n  - Validate CreateMangaRequest using Joi\n  - Generate unique project ID (uuid)\n  - Create project in database with 'draft' status\n  - Create initial panel records (count = layoutConfig.totalPanels)\n  - Return created MangaProject with 201 status\n\n- **POST /api/manga/:projectId/upload**\n  - Files already handled by multer middleware\n  - Save KeyImage records to database with file paths\n  - Store position information\n  - Return array of KeyImage objects\n\n- **GET /api/manga/:projectId**\n  - Fetch project + panels + key images from database\n  - Return complete MangaProject object\n  - Throw NotFoundError if project doesn't exist\n\n- **GET /api/manga**\n  - Implement pagination (limit/offset query params)\n  - Return array of projects\n  - Include total count header\n\n- **PUT /api/manga/:projectId/reorder**\n  - Parse ReorderPanelsRequest body\n  - Update panelIndex for each panel based on new order\n  - Return updated panels array\n\n### Testing Requirements\n\nAfter implementation, verify:\n\n```bash\n# 1. Database initialization\nnpm run dev\n# Check console: \" configured\" for database\n\n# 2. Create project\ncurl -X POST http://localhost:5000/api/manga/create \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\n    \"projectName\": \"Test Manga\",\n    \"storyPrompt\": \"A hero on a quest\",\n    \"layoutConfig\": { \"totalPanels\": 4 }\n  }'\n\n# 3. Get project\ncurl http://localhost:5000/api/manga/{projectId}\n\n# 4. Upload images\ncurl -X POST http://localhost:5000/api/manga/{projectId}/upload \\\n  -F \"images=@test1.jpg\" \\\n  -F \"images=@test2.jpg\"\n\n# 5. Check database\nsqlite3 data/koma-fill.db \"SELECT * FROM projects; SELECT * FROM panels;\"\n```\n\n### Files This Task Provides to Other Agents\n\n- **Database schema** - Tasks 2, 3, 4, 5 will read/write to these tables\n- **API contracts** - manga.ts route signatures that Tasks 2-4 will call\n- **File storage structure** - uploads/ directory path that Task 3 will use\n- **Type definitions** - already in backend/src/models/types.ts (reference only)\n\n### Output Validation Checklist\n\n- [ ] Database file created at `data/koma-fill.db`\n- [ ] All 3 tables created with correct schema\n- [ ] Repositories implement CRUD operations\n- [ ] All route handlers work without TODO comments\n- [ ] multer uploads save files to `uploads/` directory\n- [ ] POST /create returns 201 with MangaProject object\n- [ ] GET /:projectId returns full project with panels\n- [ ] Error handler catches and responds appropriately\n- [ ] No TypeScript compilation errors\n- [ ] npm run dev starts without errors\n\n---\n\n## Task 2: + (Agent B)\n### Vision API Integration & DALL-E Prompt Generation\n\n**Time Estimate:** 50-60 minutes\n**Difficulty:** Intermediate\n**Dependencies:** Task 1 (needs database & API routes available)\n\n### Objective\nImplement OpenAI Vision API integration to analyze uploaded key images and extract character/style information. Then implement story-to-panel prompt generation using GPT-4o to create DALL-E 3 compatible prompts that maintain consistency across panels.\n\n### Target Files to Create/Modify\n\n```\nbackend/\n src/\n     services/\n         imageAnalysisService.ts      [IMPLEMENT] Vision API analysis\n         promptGenerationService.ts   [CREATE] Story  panel prompts\n```\n\n### System Prompts (Already Provided)\n\nBoth vision analysis prompts are defined in `imageAnalysisService.ts`:\n- `QUICK_ANALYSIS_PROMPT` - fast, ~500 tokens\n- `DETAILED_ANALYSIS_PROMPT` - thorough, ~2000 tokens\n\nThese guide the Vision API to return structured JSON matching the `ImageAnalysis` interface.\n\n### TypeScript Interfaces\n\n```typescript\n// Input: Key image file path (from Task 1)\n// Output: ImageAnalysis object\n\nImageAnalysis {\n  description: string;\n  characters: CharacterInfo[];\n  objects: string[];\n  colors: string[];\n  composition: string;\n  mood: string;\n  artStyle: string;\n  suggestedTransitions: string[];\n}\n\nCharacterInfo {\n  name?: string;\n  appearance: string;        // detailed physical description\n  emotion: string;\n  position: string;          // screen position (e.g., \"center-left\")\n}\n\n// Panel prompt generation\nPanelPrompt {\n  panelIndex: number;\n  dallePrompt: string;       // Full DALL-E 3 prompt (100-300 words)\n  storyBeat: string;         // What happens in this panel\n  visualFocus: string;       // Main visual element\n  transitionType: TransitionType;  // 'cut' | 'pan' | 'zoom_in' | 'zoom_out' | 'fade' | 'action'\n  suggestedDialogue?: string;\n}\n```\n\n### Implementation Details\n\n#### ImageAnalysisService (`backend/src/services/imageAnalysisService.ts`)\n\n**Constructor:**\n```typescript\nconstructor() {\n  this.openai = new OpenAI({\n    apiKey: CONFIG.OPENAI_API_KEY,\n    organization: CONFIG.OPENAI_ORG_ID\n  });\n}\n```\n\n**Method: analyzeImage(imageBase64: string, depth: 'quick' | 'detailed')**\n- Input: Base64-encoded image data from KeyImage file\n- Implementation:\n  1. Read image file and convert to Base64 (if not already)\n  2. Call `this.openai.chat.completions.create()`:\n     - model: CONFIG.VISION_MODEL ('gpt-4o')\n     - messages: [\n       { role: 'system', content: QUICK_ANALYSIS_PROMPT or DETAILED_ANALYSIS_PROMPT }\n       { role: 'user', content: [\n         { type: 'image_url', image_url: { url: `data:image/png;base64,${imageBase64}` } }\n       ]}\n     ]\n     - response_format: { type: 'json_object' }\n     - max_tokens: depth === 'quick' ? 500 : 2000\n  3. Parse response.choices[0].message.content as JSON\n  4. Validate against ImageAnalysis schema\n  5. Return ImageAnalysis object\n\n**Method: analyzeMultiple(images, depth)**\n- Input: Array of { base64, position } objects\n- Use Promise.all with rate limiting (max CONFIG.VISION_RATE_LIMIT_PER_MINUTE calls/min)\n- Implement backoff if rate limited\n- Return array of ImageAnalysis objects\n\n**Method: extractCharacters(analysis)**\n- Optional: Deep-dive character extraction\n- Can call another Vision API pass if needed for more detail\n\n#### PromptGenerationService (NEW FILE - `backend/src/services/promptGenerationService.ts`)\n\n**Constructor:**\n```typescript\nconstructor() {\n  this.openai = new OpenAI({ apiKey: CONFIG.OPENAI_API_KEY });\n}\n```\n\n**Method: generatePanelPrompts(request: GeneratePromptsRequest)**\n\nInput:\n```typescript\nGeneratePromptsRequest {\n  storyPrompt: string;           // User's story\n  panelCount: number;            // Total panels to generate\n  characterConsistency: boolean; // Whether to maintain character consistency\n}\n```\n\nImplementation:\n1. **Story Breakdown Phase:**\n   - Call GPT-4o to split story into N panel beats\n   - System prompt should guide structure like:\n   ```\n   \"You are a manga story expert. Break the provided story into exactly {panelCount}\n    distinct visual beats. Each beat should be 1-2 sentences describing what happens\n    visually in that panel. Format as JSON array of objects with 'panelIndex' and 'beat' fields.\"\n   ```\n\n2. **Character Consistency Analysis:**\n   - If characterConsistency=true and keyImages were analyzed:\n     - Retrieve stored ImageAnalysis for key images\n     - Create character consistency profile (appearance, emotion arcs, etc.)\n     - Include in subsequent prompts\n\n3. **DALL-E 3 Prompt Generation:**\n   - For each story beat, create detailed DALL-E 3 prompt\n   - System prompt pattern:\n   ```\n   \"You are a DALL-E 3 prompt expert specializing in manga panels.\n    Given a story beat, generate a detailed visual prompt (100-300 words) that:\n    - Specifies art style: {generationSettings.imageStyle}\n    - Maintains character consistency: {characterProfile}\n    - Follows manga composition principles\n    - Uses specific visual terms (angle, lighting, pose, emotion)\n    - Avoids abstract concepts; be concrete and visual\n    - Follows DALL-E 3 content policy\n\n    Return JSON with: { dallePrompt, visualFocus, transitionType, suggestedDialogue }\"\n   ```\n\n4. **Transition Logic:**\n   - Analyze flow between consecutive beats\n   - Suggest transition type ('cut', 'pan', 'zoom_in', etc.)\n   - Update imageUrl in previous panel to support transitions\n\n5. **Return Value:**\n   - Array of PanelPrompt objects, one per panel\n   - Each with populated dallePrompt, storyBeat, visualFocus, transitionType\n\n### Database Integration\n\nAfter generating prompts, save to Panel table:\n- Update each panel's `prompt` field with `dallePrompt`\n- Update `storyBeat` field\n- Update `status` to 'pending' (ready for image generation)\n\n### API Integration\n\nImplement route handlers in `backend/src/routes/manga.ts`:\n\n**POST /api/manga/:projectId/analyze**\n```typescript\n// 1. Fetch project and keyImages from DB\n// 2. Read image files and convert to Base64\n// 3. Call imageAnalysisService.analyzeMultiple()\n// 4. Store analysis results in DB (keyImages.analysis)\n// 5. Update project status to 'analyzing'  'complete'\n// 6. Return analysis results\n```\n\n**POST /api/manga/:projectId/generate-prompts**\n```typescript\n// 1. Validate GeneratePromptsRequest\n// 2. Fetch project and keyImages analyses from DB\n// 3. Call promptGenerationService.generatePanelPrompts()\n// 4. Update panel records with generated prompts\n// 5. Update project status to 'generating'\n// 6. Return array of PanelPrompt objects\n```\n\n### Testing Requirements\n\n```bash\n# 1. Prepare test image\n# (Use any PNG/JPG with a character or scene)\n\n# 2. Create project and upload image (Task 1)\nPROJECT_ID=$(curl -s -X POST http://localhost:5000/api/manga/create \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"projectName\":\"Test\",\"storyPrompt\":\"A hero finds treasure\"}' | jq -r '.id')\n\n# 3. Upload test image\ncurl -X POST http://localhost:5000/api/manga/$PROJECT_ID/upload \\\n  -F \"images=@test_image.jpg\"\n\n# 4. Analyze images\ncurl -X POST http://localhost:5000/api/manga/$PROJECT_ID/analyze \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"analysisDepth\":\"quick\"}'\n\n# 5. Generate prompts\ncurl -X POST http://localhost:5000/api/manga/$PROJECT_ID/generate-prompts \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\n    \"storyPrompt\": \"A hero finds treasure in a dark cave\",\n    \"panelCount\": 4,\n    \"characterConsistency\": true\n  }'\n\n# 6. Verify output\ncurl http://localhost:5000/api/manga/$PROJECT_ID | jq '.panels[].prompt'\n```\n\n### Files This Task Provides to Other Agents\n\n- **Panel prompt data** - Stored in DB panels table, used by Task 3 for image generation\n- **Character analysis** - Used by Task 5 frontend for display\n- **Art style consistency** - Guides Task 3's image generation\n\n### Output Validation Checklist\n\n- [ ] ImageAnalysisService.analyzeImage() calls Vision API successfully\n- [ ] Vision API responses parse correctly to ImageAnalysis\n- [ ] PromptGenerationService generates DALL-E-compatible prompts\n- [ ] Panel prompts maintain character consistency (if enabled)\n- [ ] Transition types are correctly assigned\n- [ ] All panel records updated in database with prompts\n- [ ] /analyze endpoint returns ImageAnalysis array\n- [ ] /generate-prompts endpoint returns PanelPrompt array\n- [ ] Error handling for API failures (rate limits, auth, etc.)\n- [ ] No TypeScript compilation errors\n\n---\n\n## Task 3: DALL-E 3 (Agent C)\n### Image Generation with Retry Logic & Progress Streaming\n\n**Time Estimate:** 50-70 minutes\n**Difficulty:** Intermediate-Advanced\n**Dependencies:** Task 1 (DB & API), Task 2 (panel prompts)\n\n### Objective\nImplement DALL-E 3 image generation with robust error handling, exponential backoff retry logic, local image storage, Server-Sent Events (SSE) streaming for real-time progress updates, and cost tracking per API call.\n\n### Target Files to Create/Modify\n\n```\nbackend/\n src/\n     services/\n         imageGenerationService.ts    [IMPLEMENT] DALL-E 3 API integration\n         (imageProcessor.ts)          [REFERENCE] Utility for image processing\n```\n\n### TypeScript Interfaces\n\n```typescript\nGeneratedPanel {\n  panelIndex: number;\n  imageUrl: string;              // DALL-E public URL (temporary)\n  localFilePath: string;         // /uploads/{projectId}/panel_{index}.png\n  prompt: string;                // Original prompt sent\n  revisedPrompt?: string;        // DALL-E 3's revised prompt (if modified)\n  costUsd: number;               // API call cost\n}\n\n// Request type\nGenerateImagesRequest {\n  panelIndices?: number[];       // undefined = all panels\n  batchMode: 'sequential' | 'parallel';\n}\n\n// Progress event (sent via SSE)\nProgressEvent {\n  type: 'progress' | 'complete' | 'error';\n  stage: string;                 // 'generating_images'\n  currentStep: number;           // Current panel index\n  totalSteps: number;            // Total panels\n  percentage: number;            // 0-100\n  message: string;               // Human-readable status\n  panelId?: string;\n  panelIndex?: number;\n  error?: string;                // Error message if type='error'\n}\n```\n\n### Implementation Details\n\n#### ImageGenerationService (`backend/src/services/imageGenerationService.ts`)\n\n**Constructor & Initialization:**\n```typescript\nconstructor() {\n  this.openai = new OpenAI({ apiKey: CONFIG.OPENAI_API_KEY });\n  this.uploadDir = path.resolve(CONFIG.STORAGE_PATH);\n}\n```\n\n**Method: generatePanel() - Single Panel Generation**\n\n```typescript\nasync generatePanel(\n  prompt: string,\n  panelIndex: number,\n  projectId: string,\n  settings?: GenerationSettings\n): Promise<GeneratedPanel>\n```\n\nImplementation:\n1. **Image Size Calculation:**\n   - Map aspectRatio to DALL-E 3 size:\n     - 'square'  '1024x1024'\n     - 'wide'  '1792x1024'\n     - 'tall'  '1024x1792'\n\n2. **API Call (with retry logic in wrapper):**\n   ```typescript\n   const response = await this.openai.images.generate({\n     model: CONFIG.DALLE_MODEL,           // 'dall-e-3'\n     prompt: prompt,\n     n: 1,\n     size: size,\n     quality: settings?.qualityLevel === 'hd' ? 'hd' : 'standard',\n     style: 'natural',                    // or 'vivid' for more dramatic\n   });\n   ```\n\n3. **Extract Response Data:**\n   - imageUrl = response.data[0].url\n   - revisedPrompt = response.data[0].revised_prompt\n   - Calculate cost based on settings.qualityLevel:\n     - standard: $0.040 per image\n     - hd: $0.080 per image\n\n4. **Download & Save Image:**\n   - Call this.downloadAndSave(imageUrl, projectId, panelIndex)\n   - Saves as PNG: `{STORAGE_PATH}/{projectId}/panel_{panelIndex}.png`\n   - Returns localFilePath\n\n5. **Return GeneratedPanel object**\n\n**Method: generateBatch() - Batch Generation with Mode Selection**\n\n```typescript\nasync generateBatch(\n  panelPrompts: PanelPrompt[],\n  projectId: string,\n  batchMode: 'sequential' | 'parallel',\n  settings?: GenerationSettings,\n  onProgress?: (event: ProgressEvent) => void\n): Promise<GeneratedPanel[]>\n```\n\nImplementation:\n1. Validate inputs\n2. Route to sequential or parallel handler\n3. Call onProgress callback with progress events\n4. Return array of GeneratedPanel\n\n**Method: generateSequential() - Rate-Limit Friendly**\n\n```typescript\nprivate async generateSequential(\n  panelPrompts: PanelPrompt[],\n  projectId: string,\n  settings?: GenerationSettings,\n  onProgress?: (event: ProgressEvent) => void\n): Promise<GeneratedPanel[]>\n```\n\nImplementation:\n1. Initialize results array\n2. For each panelPrompt (with index):\n   a. Call generatePanelWithRetry(panelPrompt, projectId, settings)\n   b. On success:\n      - Add to results array\n      - Call onProgress with percentage = (index + 1) / total * 100\n   c. On failure (after max retries):\n      - Update panel status to 'failed' in DB\n      - Log error\n      - Continue to next panel\n\n3. Return results array (may include failed panels with status='failed')\n\n**Method: generateParallel() - High Speed (Rate Limit Aware)**\n\n```typescript\nprivate async generateParallel(\n  panelPrompts: PanelPrompt[],\n  projectId: string,\n  settings?: GenerationSettings,\n  onProgress?: (event: ProgressEvent) => void\n): Promise<GeneratedPanel[]>\n```\n\nImplementation:\n1. **Batch Control:**\n   - Max concurrent = Math.floor(CONFIG.DALLE_RATE_LIMIT_PER_MINUTE / 2)\n   - Split panelPrompts into batches of max concurrent\n\n2. **For each batch:**\n   - Create Promise.allSettled() for batch\n   - Wait for all to settle\n   - Process results\n   - Send progress update to onProgress\n   - Delay before next batch (respect rate limits)\n\n3. **Failure Handling:**\n   - Collect failed panels\n   - Retry failed panels sequentially (exponential backoff)\n   - Update onProgress for retries\n\n4. **Return results array**\n\n**Method: generatePanelWithRetry() - Core Retry Logic**\n\n```typescript\nprivate async generatePanelWithRetry(\n  panelPrompt: PanelPrompt,\n  projectId: string,\n  settings?: GenerationSettings,\n  retryCount: number = 0\n): Promise<GeneratedPanel>\n```\n\nImplementation:\n1. Try to generate panel via generatePanel()\n2. On success: Return GeneratedPanel\n3. On failure:\n   - If retryCount < CONFIG.MAX_RETRIES_PER_PANEL:\n     - Calculate backoff delay: 2^retryCount * 1000ms (exponential)\n     - Wait for delay\n     - Recursively call with retryCount++\n   - If max retries exceeded:\n     - Throw error with panel index info\n\n**Exponential Backoff Formula:**\n```\ndelay(attempt) = base_delay * (2 ^ attempt) + random jitter\ndelay(0) = 1000ms (1 second)\ndelay(1) = 2000ms (2 seconds)\ndelay(2) = 4000ms (4 seconds)\n+ add random(0, 500ms) jitter to avoid thundering herd\n```\n\n**Method: downloadAndSave() - Store Images Locally**\n\n```typescript\nprivate async downloadAndSave(\n  imageUrl: string,\n  projectId: string,\n  panelIndex: number\n): Promise<string>\n```\n\nImplementation:\n1. Create project uploads directory if not exists: `{STORAGE_PATH}/{projectId}/`\n2. Fetch image from URL using axios or native fetch:\n   ```typescript\n   const response = await fetch(imageUrl);\n   const arrayBuffer = await response.arrayBuffer();\n   const buffer = Buffer.from(arrayBuffer);\n   ```\n3. Save to disk:\n   ```typescript\n   const filePath = path.join(this.uploadDir, projectId, `panel_${panelIndex}.png`);\n   await fs.writeFile(filePath, buffer);\n   ```\n4. Return relative or absolute path\n\n**Method: getImageSize() - Aspect Ratio to DALL-E Size**\n\n```typescript\nprivate getImageSize(\n  aspectRatio: string\n): '1024x1024' | '1792x1024' | '1024x1792'\n```\n\nSelf-explanatory mapping function.\n\n### Route Handler Integration\n\nImplement in `backend/src/routes/manga.ts`:\n\n**POST /api/manga/:projectId/generate-images - SSE Streaming**\n\n```typescript\nrouter.post('/:projectId/generate-images', async (req, res, next) => {\n  try {\n    const { projectId } = req.params;\n    const { panelIndices, batchMode } = req.body as GenerateImagesRequest;\n\n    // Set up SSE response\n    res.setHeader('Content-Type', 'text/event-stream');\n    res.setHeader('Cache-Control', 'no-cache');\n    res.setHeader('Connection', 'keep-alive');\n\n    // Fetch project and panels from DB\n    const project = await getProject(projectId);\n    if (!project) throw new NotFoundError('Project');\n\n    // Filter panels (all or specific indices)\n    const panelsToGenerate = project.panels.filter(\n      p => !panelIndices || panelIndices.includes(p.panelIndex)\n    );\n\n    // Generate prompts array\n    const panelPrompts: PanelPrompt[] = panelsToGenerate.map(p => ({\n      panelIndex: p.panelIndex,\n      dallePrompt: p.prompt!,\n      storyBeat: p.storyBeat!,\n      visualFocus: 'main subject',  // Extract from context if available\n      transitionType: 'cut',        // Default, could be from DB\n    }));\n\n    // Call imageGenerationService\n    imageGenService.generateBatch(\n      panelPrompts,\n      projectId,\n      batchMode,\n      project.generationSettings,\n      (progressEvent) => {\n        // Send progress as SSE\n        res.write(`data: ${JSON.stringify(progressEvent)}\\n\\n`);\n      }\n    ).then(generatedPanels => {\n      // Update database with generated images\n      for (const panel of generatedPanels) {\n        updatePanelImage(panel.panelIndex, {\n          imageUrl: panel.imageUrl,\n          imageFilePath: panel.localFilePath,\n          revisedPrompt: panel.revisedPrompt,\n          status: panel.revisedPrompt ? 'generated' : 'generated',\n        });\n      }\n\n      // Send completion event\n      res.write(`data: ${JSON.stringify({\n        type: 'complete',\n        message: 'Image generation complete',\n        totalCost: generatedPanels.reduce((sum, p) => sum + p.costUsd, 0),\n      })}\\n\\n`);\n\n      res.end();\n    }).catch(err => {\n      res.write(`data: ${JSON.stringify({\n        type: 'error',\n        message: err.message,\n      })}\\n\\n`);\n      res.end();\n    });\n  } catch (err) {\n    next(err);\n  }\n});\n```\n\n### Cost Tracking\n\n**Implementation:**\n- Track cost per API call in GeneratedPanel.costUsd\n- Sum across all panels: `totalCost = sum(generatedPanels.map(p => p.costUsd))`\n- Update project.totalCost in DB: `project.totalCost += generatedPanels totalCost`\n- Log costs for each call (useful for budget monitoring)\n\n**Cost Constants (from types.ts):**\n```typescript\nAPI_COSTS = {\n  VISION_PER_CALL: 0.025,    // GPT-4V\n  DALLE3_STANDARD: 0.040,    // per image\n  DALLE3_HD: 0.080,          // per image\n}\n```\n\n### Testing Requirements\n\n```bash\n# 1. Set up test project (with prompts from Task 2)\nPROJECT_ID=\"test-project-id\"\n# Or use output from Task 2 test\n\n# 2. Generate images (sequential mode)\ncurl -X POST http://localhost:5000/api/manga/$PROJECT_ID/generate-images \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"batchMode\": \"sequential\"}' \\\n  -H \"Accept: text/event-stream\"\n\n# 3. Verify local image files created\nls -la uploads/$PROJECT_ID/\n\n# 4. Check database for updated image URLs\nsqlite3 data/koma-fill.db \"SELECT panelIndex, imageFilePath, status FROM panels WHERE projectId='$PROJECT_ID';\"\n\n# 5. Verify cost tracking\ncurl http://localhost:5000/api/manga/$PROJECT_ID | jq '.totalCost'\n```\n\n### Files This Task Provides to Other Agents\n\n- **Generated panel images** - Stored in uploads/{projectId}/, used by Task 4\n- **Image file paths** - Updated in DB, used by Task 4 for layout composition\n- **Cost tracking** - Used by frontend for budget display\n\n### Output Validation Checklist\n\n- [ ] DALL-E 3 API calls succeed with valid prompts\n- [ ] Retry logic works with exponential backoff\n- [ ] Images download and save to {STORAGE_PATH}/{projectId}/\n- [ ] SSE streaming sends progress events correctly\n- [ ] onProgress callback fires with accurate percentage\n- [ ] Cost calculation correct (0.04 standard, 0.08 HD)\n- [ ] Panel records updated with imageUrl and imageFilePath\n- [ ] Sequential and parallel modes both work\n- [ ] Rate limiting respected (max 5 calls/min by default)\n- [ ] Error handling for network issues, API failures\n- [ ] No TypeScript compilation errors\n\n---\n\n## Task 4: + (Agent D)\n### Manga Layout Composition & Multi-Format Export\n\n**Time Estimate:** 45-60 minutes\n**Difficulty:** Intermediate (Sharp library learning curve)\n**Dependencies:** Task 1 (DB), Task 3 (generated images)\n\n### Objective\nImplement Sharp-based manga layout composition with grid calculation, panel resizing and positioning, border/gutter rendering, speech bubble overlay, and PNG/JPG/PDF export functionality.\n\n### Target Files to Create/Modify\n\n```\nbackend/\n src/\n     services/\n        layoutEngine.ts          [IMPLEMENT] Panel composition & layout\n        exportService.ts         [CREATE] PNG/JPG/PDF export\n     utils/\n         imageProcessor.ts        [HELPER] Image processing utilities\n```\n\n### TypeScript Interfaces\n\n```typescript\n// Layout composition result\nComposedLayout {\n  buffer: Buffer;                    // PNG image buffer\n  width: number;                     // Page width (px)\n  height: number;                    // Page height (px)\n  format: 'png';\n  panelPositions: PanelPosition[];   // Position data for each panel\n}\n\nPanelPosition {\n  panelIndex: number;\n  x: number;                         // Offset from top-left (px)\n  y: number;\n  width: number;                     // Panel width (px)\n  height: number;                    // Panel height (px)\n}\n\n// Input to layout engine\nLayoutConfig {\n  totalPanels: number;               // 4, 6, 8, etc.\n  format: LayoutFormat;              // 'vertical' | 'horizontal' | 'square'\n  readingOrder: ReadingOrder;        // 'japanese' | 'western'\n  gutterSize: number;                // Space between panels (px)\n  borderWidth: number;               // Panel border thickness (px)\n  borderColor: string;               // Hex color\n  backgroundColor: string;           // Hex color\n  pageWidth: number;                 // Canvas width (px)\n  pageHeight: number;                // Canvas height (px)\n}\n```\n\n### Implementation Details\n\n#### LayoutEngine (`backend/src/services/layoutEngine.ts`)\n\n**Method: composePanels() - Main Composition Function**\n\n```typescript\nasync composePanels(\n  panelImagePaths: string[],\n  config: LayoutConfig = DEFAULT_LAYOUT_CONFIG\n): Promise<ComposedLayout>\n```\n\nImplementation Steps:\n\n1. **Calculate Grid:**\n   ```typescript\n   const grid = this.calculateGrid(panelImagePaths.length, config);\n   // Returns { cols: number, rows: number }\n   ```\n   Already implemented - use it.\n\n2. **Calculate Panel Positions:**\n   ```typescript\n   const positions = this.calculatePanelPositions(grid, config);\n   // Returns: PanelPosition[] with x, y, width, height for each panel\n   ```\n   Already implemented - use it.\n\n3. **Create Background Canvas:**\n   ```typescript\n   import sharp from 'sharp';\n\n   let canvas = sharp({\n     create: {\n       width: config.pageWidth,\n       height: config.pageHeight,\n       channels: 4,                    // RGBA\n       background: config.backgroundColor,  // Parsed from hex\n     }\n   });\n   ```\n\n4. **Load & Resize Panel Images:**\n   ```typescript\n   const composites = await Promise.all(\n     panelImagePaths.map(async (imgPath, i) => {\n       if (!fs.existsSync(imgPath)) {\n         throw new Error(`Panel image not found: ${imgPath}`);\n       }\n\n       const position = positions[i];\n       const resized = await sharp(imgPath)\n         .resize(position.width, position.height, {\n           fit: 'cover',              // Fill panel, crop if needed\n           withoutEnlargement: false\n         })\n         .toBuffer();\n\n       return {\n         input: resized,\n         left: position.x,\n         top: position.y\n       };\n     })\n   );\n   ```\n\n5. **Composite Panels Onto Canvas:**\n   ```typescript\n   let result = await canvas.composite(composites).png();\n   ```\n\n6. **Add Borders (Optional - if borderWidth > 0):**\n   - Use SVG overlay to draw rectangles around each panel\n   - Create SVG:\n     ```svg\n     <svg width=\"800\" height=\"1200\">\n       <!-- For each panel position -->\n       <rect x=\"10\" y=\"10\" width=\"390\" height=\"590\"\n             fill=\"none\" stroke=\"black\" stroke-width=\"2\" />\n     </svg>\n     ```\n   - Composite SVG overlay:\n     ```typescript\n     const borderSvg = this.generateBorderSvg(positions, config);\n     result = await result.composite([{\n       input: borderSvg,\n       top: 0,\n       left: 0\n     }]);\n     ```\n\n7. **Return ComposedLayout:**\n   ```typescript\n   const buffer = await result.toBuffer();\n   return {\n     buffer,\n     width: config.pageWidth,\n     height: config.pageHeight,\n     format: 'png',\n     panelPositions: positions\n   };\n   ```\n\n**Method: addSpeechBubbles() - Overlay Speech Bubbles**\n\n```typescript\nasync addSpeechBubbles(\n  layout: ComposedLayout,\n  bubbles: SpeechBubble[]\n): Promise<ComposedLayout>\n```\n\nImplementation:\n\n1. **For each speech bubble:**\n   - Get panel position from layout.panelPositions[bubble.panelIndex]\n   - Calculate bubble position within panel:\n     - 'top'  y = panel.y + 30\n     - 'middle'  y = panel.y + panel.height/2 - 30\n     - 'bottom'  y = panel.y + panel.height - 60\n\n2. **Create SVG speech bubble:**\n   ```typescript\n   const svg = this.generateSpeechBubbleSvg(bubble, position, style);\n   // Generates SVG with text, shape varies by style:\n   // 'rounded', 'cloud', 'spiked', 'rectangular'\n   ```\n\n3. **Composite all bubble SVGs:**\n   ```typescript\n   let result = sharp(layout.buffer);\n   const bubbleSvgs = bubbles.map((bubble, idx) =>\n     this.generateSpeechBubbleSvg(bubble, panelPositions[bubble.panelIndex])\n   );\n\n   result = await result.composite(\n     bubbleSvgs.map((svg, i) => ({ input: svg }))\n   );\n   ```\n\n4. **Return updated ComposedLayout**\n\n**Helper: generateBorderSvg()**\n```typescript\nprivate generateBorderSvg(\n  positions: PanelPosition[],\n  config: LayoutConfig\n): Buffer\n```\n\nGenerate SVG with rectangle borders around each panel:\n```svg\n<svg width=\"800\" height=\"1200\">\n  <rect x=\"10\" y=\"10\" width=\"390\" height=\"590\"\n        fill=\"none\" stroke=\"#000000\" stroke-width=\"2\" />\n  <!-- repeated for each panel -->\n</svg>\n```\n\nConvert to Buffer and return.\n\n**Helper: generateSpeechBubbleSvg()**\n```typescript\nprivate generateSpeechBubbleSvg(\n  bubble: SpeechBubble,\n  panelPosition: PanelPosition,\n  targetY: number  // top/middle/bottom\n): Buffer\n```\n\nGenerate SVG with speech bubble shape. Example for 'rounded':\n```svg\n<svg width=\"300\" height=\"100\">\n  <!-- Rounded rectangle -->\n  <path d=\"M 10,10 Q 10,10 20,10 L 270,10 Q 280,10 280,20 L 280,70 Q 280,80 270,80 L 30,80 Q 20,80 20,70 L 20,40 L 0,60 L 20,50 L 20,20 Q 20,10 10,10\"\n        fill=\"white\" stroke=\"black\" stroke-width=\"1\" />\n  <text x=\"20\" y=\"50\" font-family=\"Arial\" font-size=\"14\">Your text here</text>\n</svg>\n```\n\nReturn SVG as Buffer via:\n```typescript\nconst svgBuffer = Buffer.from(svgString, 'utf-8');\n```\n\n### ExportService (`backend/src/services/exportService.ts`) - NEW FILE\n\nImplement export to PNG, JPG, PDF formats.\n\n```typescript\nexport class ExportService {\n  async exportPNG(\n    layout: ComposedLayout,\n    filepath: string,\n    compression: 'low' | 'medium' | 'high'\n  ): Promise<void>\n\n  async exportJPG(\n    layout: ComposedLayout,\n    filepath: string,\n    quality: number  // 60-95\n  ): Promise<void>\n\n  async exportPDF(\n    layout: ComposedLayout,\n    filepath: string,\n    metadata: { title?: string; author?: string }\n  ): Promise<void>\n}\n```\n\n**exportPNG():**\n```typescript\nasync exportPNG(layout, filepath, compression) {\n  const compressionLevel = compression === 'high' ? 9 : compression === 'medium' ? 6 : 1;\n  await sharp(layout.buffer)\n    .png({ compressionLevel })\n    .toFile(filepath);\n}\n```\n\n**exportJPG():**\n```typescript\nasync exportJPG(layout, filepath, quality = 80) {\n  await sharp(layout.buffer)\n    .jpeg({ quality, mozjpeg: true })\n    .toFile(filepath);\n}\n```\n\n**exportPDF():**\nRequires pdfkit library:\n```typescript\nimport PDFDocument from 'pdfkit';\nimport { createWriteStream } from 'fs';\n\nasync exportPDF(layout, filepath, metadata = {}) {\n  const doc = new PDFDocument({\n    size: [layout.width, layout.height]\n  });\n\n  if (metadata.title) doc.title(metadata.title);\n  if (metadata.author) doc.author(metadata.author);\n\n  // Add image to PDF\n  doc.image(layout.buffer, 0, 0, {\n    width: layout.width,\n    height: layout.height\n  });\n\n  doc.pipe(createWriteStream(filepath));\n  doc.end();\n}\n```\n\n### Route Handler Integration\n\nImplement in `backend/src/routes/manga.ts`:\n\n**POST /api/manga/:projectId/layout**\n```typescript\nrouter.post('/:projectId/layout', async (req: Request, res: Response, next: NextFunction) => {\n  try {\n    const { projectId } = req.params;\n    const { speechBubbles } = req.body as GenerateLayoutRequest;\n\n    // Fetch project and panels from DB\n    const project = await getProject(projectId);\n    if (!project) throw new NotFoundError('Project');\n\n    // Get panel image paths\n    const panelPaths = project.panels\n      .sort((a, b) => a.panelIndex - b.panelIndex)\n      .map(p => p.imageFilePath)\n      .filter(path => path !== undefined);\n\n    // Compose layout\n    const layoutEngine = new LayoutEngine();\n    let layout = await layoutEngine.composePanels(panelPaths, project.layoutConfig);\n\n    // Add speech bubbles if provided\n    if (speechBubbles && speechBubbles.length > 0) {\n      layout = await layoutEngine.addSpeechBubbles(layout, speechBubbles);\n    }\n\n    // Save layout buffer to temporary file for preview\n    const layoutPath = path.join(CONFIG.STORAGE_PATH, projectId, 'layout.png');\n    await fs.writeFile(layoutPath, layout.buffer);\n\n    // Update project status\n    await updateProject(projectId, { status: 'complete' });\n\n    // Return layout info\n    res.json({\n      message: 'Layout composed successfully',\n      projectId,\n      layoutPath: `/uploads/${projectId}/layout.png`,\n      panelPositions: layout.panelPositions,\n      dimensions: { width: layout.width, height: layout.height }\n    });\n  } catch (err) {\n    next(err);\n  }\n});\n```\n\n**POST /api/manga/:projectId/export**\n```typescript\nrouter.post('/:projectId/export', async (req: Request, res: Response, next: NextFunction) => {\n  try {\n    const { projectId } = req.params;\n    const { format, compression, resolution, title, author } = req.body as ExportRequest;\n\n    // Fetch project layout\n    const layoutPath = path.join(CONFIG.STORAGE_PATH, projectId, 'layout.png');\n    if (!fs.existsSync(layoutPath)) {\n      throw new Error('Layout not yet generated. Call /layout endpoint first.');\n    }\n\n    const layoutBuffer = await fs.promises.readFile(layoutPath);\n    const layout: ComposedLayout = {\n      buffer: layoutBuffer,\n      width: 800,  // From project.layoutConfig\n      height: 1200,\n      format: 'png',\n      panelPositions: []  // Could fetch from DB if needed\n    };\n\n    // Export to requested format\n    const exportService = new ExportService();\n    const timestamp = Date.now();\n    const exportPath = path.join(CONFIG.STORAGE_PATH, projectId, `manga_${timestamp}.${format}`);\n\n    if (format === 'png') {\n      await exportService.exportPNG(layout, exportPath, compression as 'low' | 'medium' | 'high');\n    } else if (format === 'jpg') {\n      const qualityMap = { low: 60, medium: 80, high: 95 };\n      await exportService.exportJPG(layout, exportPath, qualityMap[compression]);\n    } else if (format === 'pdf') {\n      await exportService.exportPDF(layout, exportPath, { title, author });\n    }\n\n    // Update project status\n    await updateProject(projectId, { status: 'exported' });\n\n    res.json({\n      message: 'Export successful',\n      projectId,\n      format,\n      downloadUrl: `/uploads/${projectId}/manga_${timestamp}.${format}`,\n      filePath: exportPath\n    });\n  } catch (err) {\n    next(err);\n  }\n});\n```\n\n### Testing Requirements\n\n```bash\n# 1. Generate layout from Task 3 images\nPROJECT_ID=\"test-project-id\"\ncurl -X POST http://localhost:5000/api/manga/$PROJECT_ID/layout \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\n    \"speechBubbles\": [\n      {\n        \"panelIndex\": 0,\n        \"text\": \"Wow!\",\n        \"position\": \"top\",\n        \"style\": \"rounded\"\n      }\n    ]\n  }'\n\n# 2. View composed layout\nopen http://localhost:5000/uploads/$PROJECT_ID/layout.png\n\n# 3. Export to PNG\ncurl -X POST http://localhost:5000/api/manga/$PROJECT_ID/export \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\n    \"format\": \"png\",\n    \"compression\": \"medium\",\n    \"resolution\": \"web\",\n    \"title\": \"My Manga\"\n  }'\n\n# 4. Export to PDF\ncurl -X POST http://localhost:5000/api/manga/$PROJECT_ID/export \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\n    \"format\": \"pdf\",\n    \"compression\": \"medium\",\n    \"title\": \"My Manga\",\n    \"author\": \"AI Creator\"\n  }'\n\n# 5. Verify files exist\nls -lh uploads/$PROJECT_ID/\n```\n\n### Files This Task Provides to Other Agents\n\n- **Composed layout image** - Used by frontend for preview\n- **Export files** - PNG/JPG/PDF outputs for download\n- **Layout metadata** - Panel positions for debugging/display\n\n### Output Validation Checklist\n\n- [ ] calculateGrid() and calculatePanelPositions() methods work correctly\n- [ ] composePanels() successfully combines images with sharp\n- [ ] Borders render correctly around panels\n- [ ] Speech bubbles overlay without distortion\n- [ ] Multiple speech bubble styles work ('rounded', 'cloud', 'spiked', 'rectangular')\n- [ ] Layout PNG saved and readable\n- [ ] exportPNG() produces valid PNG files\n- [ ] exportJPG() produces valid JPG files with quality control\n- [ ] exportPDF() produces valid PDF with metadata\n- [ ] /layout endpoint returns correct panel positions\n- [ ] /export endpoint returns download URLs\n- [ ] Compression settings affect file size appropriately\n- [ ] No TypeScript compilation errors\n\n---\n\n## Task 5: React (Agent E)\n### Complete React UI with Component Implementation\n\n**Time Estimate:** 60-80 minutes\n**Difficulty:** Intermediate (React component patterns)\n**Dependencies:** Tasks 1-4 (backend API must be running)\n\n### Objective\nComplete all React components for the koma-fill frontend including image upload with drag-drop, story prompt editor, panel grid with drag-and-drop reordering, complete manga generation workflow orchestration, real-time SSE progress updates, and multi-format export options. Configure Tailwind CSS for styling.\n\n### Target Files to Create/Modify\n\n```\nfrontend/\n src/\n    components/\n       ImageUploader.tsx           [IMPLEMENT] Dropzone with position selector\n       StoryPromptEditor.tsx       [ENHANCE] Add sample prompts\n       PanelGrid.tsx               [IMPLEMENT] Drag-and-drop reordering\n       LayoutSelector.tsx          [VERIFY] Layout config UI\n       ExportOptions.tsx           [VERIFY] Export format selection\n       ProgressBar.tsx             [CREATE] Real-time progress display\n    hooks/\n       useMangaGeneration.ts       [IMPLEMENT] Full workflow orchestration\n    services/\n       apiClient.ts                [IMPLEMENT] API client with SSE support\n    pages/\n       CreateMangaPage.tsx         [IMPLEMENT] Main workflow page\n       PreviewPage.tsx             [IMPLEMENT] Result preview & download\n    App.tsx                         [UPDATE] Routing\n    main.tsx                        [VERIFY] Entry point\n    index.css                       [UPDATE] Tailwind directives\n tailwind.config.js                  [CREATE] Tailwind configuration\n postcss.config.js                   [CREATE] PostCSS configuration\n package.json                        [UPDATE] Add Tailwind dependencies\n tsconfig.json                       [VERIFY] TypeScript config\n```\n\n### TypeScript Interfaces (from `frontend/src/types/index.ts`)\n\nAlready defined - reference for component props.\n\n### Implementation Details\n\n#### 1. Tailwind CSS Setup\n\n**Install Dependencies:**\n```bash\ncd frontend\nnpm install -D tailwindcss postcss autoprefixer\nnpx tailwindcss init -p\n```\n\n**tailwind.config.js:**\n```javascript\nexport default {\n  content: [\n    './index.html',\n    './src/**/*.{js,ts,jsx,tsx}',\n  ],\n  theme: {\n    extend: {\n      colors: {\n        manga: {\n          dark: '#1a1a1a',\n          light: '#f5f5f5',\n        }\n      }\n    },\n  },\n  plugins: [],\n}\n```\n\n**postcss.config.js:**\n```javascript\nexport default {\n  plugins: {\n    tailwindcss: {},\n    autoprefixer: {},\n  },\n}\n```\n\n**frontend/src/index.css:**\n```css\n@tailwind base;\n@tailwind components;\n@tailwind utilities;\n\n@layer components {\n  .btn-primary {\n    @apply px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700 transition;\n  }\n  .btn-secondary {\n    @apply px-4 py-2 bg-gray-300 text-gray-800 rounded-lg hover:bg-gray-400 transition;\n  }\n  .input-field {\n    @apply w-full px-3 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500;\n  }\n}\n```\n\n#### 2. API Client (`frontend/src/services/apiClient.ts`)\n\n```typescript\nimport { MangaProject, Panel, GenerationProgress, ProgressEvent } from '../types';\n\nconst API_BASE = import.meta.env.VITE_API_URL || 'http://localhost:5000/api';\n\nexport class APIClient {\n  /**\n   * Create new manga project\n   */\n  async createProject(name: string, storyPrompt: string, layoutConfig?: any) {\n    const response = await fetch(`${API_BASE}/manga/create`, {\n      method: 'POST',\n      headers: { 'Content-Type': 'application/json' },\n      body: JSON.stringify({\n        projectName: name,\n        storyPrompt,\n        layoutConfig\n      })\n    });\n    if (!response.ok) throw new Error(await response.text());\n    return response.json() as Promise<MangaProject>;\n  }\n\n  /**\n   * Upload key images\n   */\n  async uploadImages(projectId: string, files: File[]) {\n    const formData = new FormData();\n    files.forEach(file => formData.append('images', file));\n\n    const response = await fetch(`${API_BASE}/manga/${projectId}/upload`, {\n      method: 'POST',\n      body: formData\n    });\n    if (!response.ok) throw new Error(await response.text());\n    return response.json();\n  }\n\n  /**\n   * Analyze images using Vision API\n   */\n  async analyzeImages(projectId: string, depth: 'quick' | 'detailed' = 'quick') {\n    const response = await fetch(`${API_BASE}/manga/${projectId}/analyze`, {\n      method: 'POST',\n      headers: { 'Content-Type': 'application/json' },\n      body: JSON.stringify({ analysisDepth: depth })\n    });\n    if (!response.ok) throw new Error(await response.text());\n    return response.json();\n  }\n\n  /**\n   * Generate panel prompts\n   */\n  async generatePrompts(projectId: string, storyPrompt: string, panelCount: number) {\n    const response = await fetch(`${API_BASE}/manga/${projectId}/generate-prompts`, {\n      method: 'POST',\n      headers: { 'Content-Type': 'application/json' },\n      body: JSON.stringify({\n        storyPrompt,\n        panelCount,\n        characterConsistency: true\n      })\n    });\n    if (!response.ok) throw new Error(await response.text());\n    return response.json() as Promise<Panel[]>;\n  }\n\n  /**\n   * Generate images via DALL-E 3 (SSE streaming)\n   */\n  streamImageGeneration(\n    projectId: string,\n    batchMode: 'sequential' | 'parallel',\n    onProgress: (event: ProgressEvent) => void,\n    onError: (error: Error) => void\n  ): () => void {\n    const eventSource = new EventSource(\n      `${API_BASE}/manga/${projectId}/generate-images?batchMode=${batchMode}`\n    );\n\n    eventSource.onmessage = (event) => {\n      try {\n        const data = JSON.parse(event.data);\n        onProgress(data);\n      } catch (e) {\n        console.error('Failed to parse SSE message:', e);\n      }\n    };\n\n    eventSource.onerror = () => {\n      onError(new Error('Generation failed or connection lost'));\n      eventSource.close();\n    };\n\n    // Return cleanup function\n    return () => eventSource.close();\n  }\n\n  /**\n   * Compose layout with speech bubbles\n   */\n  async composeLayout(projectId: string, speechBubbles?: any) {\n    const response = await fetch(`${API_BASE}/manga/${projectId}/layout`, {\n      method: 'POST',\n      headers: { 'Content-Type': 'application/json' },\n      body: JSON.stringify({ speechBubbles })\n    });\n    if (!response.ok) throw new Error(await response.text());\n    return response.json();\n  }\n\n  /**\n   * Export to PNG/JPG/PDF\n   */\n  async exportManga(\n    projectId: string,\n    format: 'png' | 'jpg' | 'pdf',\n    compression: 'low' | 'medium' | 'high' = 'medium',\n    title?: string,\n    author?: string\n  ) {\n    const response = await fetch(`${API_BASE}/manga/${projectId}/export`, {\n      method: 'POST',\n      headers: { 'Content-Type': 'application/json' },\n      body: JSON.stringify({\n        format,\n        compression,\n        resolution: 'web',\n        title,\n        author\n      })\n    });\n    if (!response.ok) throw new Error(await response.text());\n    return response.json();\n  }\n\n  /**\n   * Fetch project details\n   */\n  async getProject(projectId: string) {\n    const response = await fetch(`${API_BASE}/manga/${projectId}`);\n    if (!response.ok) throw new Error(await response.text());\n    return response.json() as Promise<MangaProject>;\n  }\n\n  /**\n   * Reorder panels\n   */\n  async reorderPanels(projectId: string, panelOrder: number[]) {\n    const response = await fetch(`${API_BASE}/manga/${projectId}/reorder`, {\n      method: 'PUT',\n      headers: { 'Content-Type': 'application/json' },\n      body: JSON.stringify({ panelOrder })\n    });\n    if (!response.ok) throw new Error(await response.text());\n    return response.json();\n  }\n}\n\nexport const apiClient = new APIClient();\n```\n\n#### 3. useMangaGeneration Hook (`frontend/src/hooks/useMangaGeneration.ts`)\n\n```typescript\nimport { useState, useCallback } from 'react';\nimport { apiClient } from '../services/apiClient';\nimport { MangaProject, GenerationProgress, UploadedImage } from '../types';\n\nexport function useMangaGeneration() {\n  const [project, setProject] = useState<MangaProject | null>(null);\n  const [progress, setProgress] = useState<GenerationProgress>({\n    stage: 'idle',\n    currentStep: 0,\n    totalSteps: 0,\n    percentage: 0,\n    message: ''\n  });\n  const [error, setError] = useState<string | null>(null);\n\n  /**\n   * Complete workflow: Create  Upload  Analyze  Generate Prompts  Generate Images  Layout\n   */\n  const generateManga = useCallback(async (\n    projectName: string,\n    storyPrompt: string,\n    uploadedImages: UploadedImage[],\n    layoutConfig: any,\n    generationSettings: any\n  ) => {\n    try {\n      setError(null);\n\n      // Stage 1: Create project\n      setProgress({\n        stage: 'uploading',\n        currentStep: 0,\n        totalSteps: 5,\n        percentage: 20,\n        message: 'Creating project...'\n      });\n      const newProject = await apiClient.createProject(projectName, storyPrompt, layoutConfig);\n      setProject(newProject);\n\n      // Stage 2: Upload images\n      setProgress({\n        stage: 'uploading',\n        currentStep: 1,\n        totalSteps: 5,\n        percentage: 40,\n        message: 'Uploading reference images...'\n      });\n      const files = uploadedImages.map(img => img.file);\n      await apiClient.uploadImages(newProject.id, files);\n\n      // Stage 3: Analyze images\n      setProgress({\n        stage: 'analyzing',\n        currentStep: 2,\n        totalSteps: 5,\n        percentage: 60,\n        message: 'Analyzing images with Vision API...'\n      });\n      await apiClient.analyzeImages(newProject.id, 'detailed');\n\n      // Stage 4: Generate prompts\n      setProgress({\n        stage: 'generating_prompts',\n        currentStep: 3,\n        totalSteps: 5,\n        percentage: 70,\n        message: 'Generating panel prompts...'\n      });\n      await apiClient.generatePrompts(\n        newProject.id,\n        storyPrompt,\n        layoutConfig.totalPanels\n      );\n\n      // Stage 5: Generate images (with SSE streaming)\n      setProgress({\n        stage: 'generating_images',\n        currentStep: 4,\n        totalSteps: 5,\n        percentage: 75,\n        message: 'Starting image generation...'\n      });\n\n      await new Promise<void>((resolve, reject) => {\n        const cleanup = apiClient.streamImageGeneration(\n          newProject.id,\n          'sequential',  // or 'parallel' based on user preference\n          (progressEvent) => {\n            if (progressEvent.type === 'complete') {\n              setProgress(prev => ({\n                ...prev,\n                percentage: 90,\n                message: 'Image generation complete!'\n              }));\n              resolve();\n            } else if (progressEvent.type === 'error') {\n              reject(new Error(progressEvent.error || 'Generation failed'));\n            } else {\n              setProgress({\n                stage: 'generating_images',\n                currentStep: 4 + (progressEvent.currentStep || 0) * 0.1,\n                totalSteps: 5,\n                percentage: 75 + (progressEvent.percentage || 0) * 0.15,\n                message: progressEvent.message,\n                currentPanelIndex: progressEvent.panelIndex\n              });\n            }\n          },\n          reject\n        );\n      });\n\n      // Stage 6: Compose layout\n      setProgress({\n        stage: 'composing_layout',\n        currentStep: 5,\n        totalSteps: 5,\n        percentage: 95,\n        message: 'Composing final layout...'\n      });\n      await apiClient.composeLayout(newProject.id);\n\n      // Complete\n      const finalProject = await apiClient.getProject(newProject.id);\n      setProject(finalProject);\n      setProgress({\n        stage: 'idle',\n        currentStep: 5,\n        totalSteps: 5,\n        percentage: 100,\n        message: 'Manga generation complete!'\n      });\n\n    } catch (err) {\n      const errorMsg = err instanceof Error ? err.message : 'Unknown error';\n      setError(errorMsg);\n      setProgress({\n        stage: 'idle',\n        currentStep: 0,\n        totalSteps: 0,\n        percentage: 0,\n        message: `Error: ${errorMsg}`\n      });\n    }\n  }, []);\n\n  const exportManga = useCallback(async (\n    projectId: string,\n    format: 'png' | 'jpg' | 'pdf',\n    compression: 'low' | 'medium' | 'high' = 'medium'\n  ) => {\n    try {\n      setError(null);\n      setProgress({\n        stage: 'exporting',\n        currentStep: 0,\n        totalSteps: 1,\n        percentage: 50,\n        message: `Exporting as ${format.toUpperCase()}...`\n      });\n\n      const result = await apiClient.exportManga(projectId, format, compression);\n\n      setProgress({\n        stage: 'idle',\n        currentStep: 1,\n        totalSteps: 1,\n        percentage: 100,\n        message: 'Export complete!'\n      });\n\n      return result;\n    } catch (err) {\n      const errorMsg = err instanceof Error ? err.message : 'Export failed';\n      setError(errorMsg);\n      throw err;\n    }\n  }, []);\n\n  return {\n    project,\n    progress,\n    error,\n    generateManga,\n    exportManga,\n    setError\n  };\n}\n```\n\n#### 4. Components\n\n**ImageUploader.tsx:**\n```typescript\nimport { useCallback, useState } from 'react';\nimport { UploadedImage, ImagePosition } from '../types';\n\ninterface ImageUploaderProps {\n  onImagesSelected: (images: UploadedImage[]) => void;\n}\n\nexport function ImageUploader({ onImagesSelected }: ImageUploaderProps) {\n  const [images, setImages] = useState<UploadedImage[]>([]);\n  const [selectedPosition, setSelectedPosition] = useState<ImagePosition>('start');\n\n  const handleDrop = useCallback((e: React.DragEvent) => {\n    e.preventDefault();\n    const files = Array.from(e.dataTransfer.files).filter(f => f.type.startsWith('image/'));\n    addImages(files);\n  }, []);\n\n  const handleFileInput = (e: React.ChangeEvent<HTMLInputElement>) => {\n    if (e.target.files) {\n      addImages(Array.from(e.target.files));\n    }\n  };\n\n  const addImages = (files: File[]) => {\n    const newImages = files.map(file => ({\n      file,\n      previewUrl: URL.createObjectURL(file),\n      position: selectedPosition\n    }));\n    setImages(prev => [...prev, ...newImages]);\n    onImagesSelected([...images, ...newImages]);\n  };\n\n  const removeImage = (index: number) => {\n    const updated = images.filter((_, i) => i !== index);\n    setImages(updated);\n    onImagesSelected(updated);\n  };\n\n  return (\n    <div className=\"w-full max-w-2xl\">\n      <div\n        onDrop={handleDrop}\n        onDragOver={e => e.preventDefault()}\n        className=\"border-2 border-dashed border-gray-300 rounded-lg p-8 text-center cursor-pointer hover:border-blue-500 transition\"\n      >\n        <p className=\"text-gray-600 mb-4\">Drag and drop images here or click to select</p>\n        <input\n          type=\"file\"\n          multiple\n          accept=\"image/*\"\n          onChange={handleFileInput}\n          className=\"hidden\"\n          id=\"image-input\"\n        />\n        <label htmlFor=\"image-input\" className=\"btn-primary cursor-pointer\">\n          Select Images\n        </label>\n      </div>\n\n      <div className=\"mt-4\">\n        <label className=\"block mb-2\">Position in Story:</label>\n        <select\n          value={selectedPosition}\n          onChange={e => setSelectedPosition(e.target.value as ImagePosition)}\n          className=\"input-field\"\n        >\n          <option value=\"start\">Start (Reference)</option>\n          <option value=\"end\">End (Reference)</option>\n          <option value={1}>Panel 1</option>\n          <option value={2}>Panel 2</option>\n        </select>\n      </div>\n\n      {images.length > 0 && (\n        <div className=\"mt-6 grid grid-cols-2 gap-4\">\n          {images.map((img, idx) => (\n            <div key={idx} className=\"relative\">\n              <img src={img.previewUrl} alt={`Preview ${idx}`} className=\"rounded-lg w-full h-48 object-cover\" />\n              <button\n                onClick={() => removeImage(idx)}\n                className=\"absolute top-2 right-2 bg-red-500 text-white rounded-full w-6 h-6 flex items-center justify-center hover:bg-red-600\"\n              >\n                \n              </button>\n            </div>\n          ))}\n        </div>\n      )}\n    </div>\n  );\n}\n```\n\n**StoryPromptEditor.tsx (Enhanced):**\n```typescript\nimport { useState } from 'react';\n\ninterface StoryPromptEditorProps {\n  value: string;\n  onChange: (value: string) => void;\n}\n\nconst SAMPLE_PROMPTS = [\n  'A young ninja discovers their hidden powers and must save their village from a mysterious threat.',\n  'Two rival chefs compete in a cooking tournament, discovering they have more in common than they thought.',\n  'A time traveler must prevent a catastrophic event by gathering clues from different eras.',\n];\n\nexport function StoryPromptEditor({ value, onChange }: StoryPromptEditorProps) {\n  const [isExpanded, setIsExpanded] = useState(false);\n\n  return (\n    <div className=\"w-full max-w-2xl\">\n      <label className=\"block text-lg font-semibold mb-2\">Your Story Prompt</label>\n\n      <textarea\n        value={value}\n        onChange={e => onChange(e.target.value)}\n        placeholder=\"Write your manga story here. Be descriptive about characters, setting, and plot...\"\n        className=\"input-field h-32 resize-none\"\n      />\n\n      <div className=\"mt-4\">\n        <button\n          onClick={() => setIsExpanded(!isExpanded)}\n          className=\"text-blue-600 hover:underline text-sm\"\n        >\n          {isExpanded ? 'Hide' : 'Show'} Sample Prompts\n        </button>\n\n        {isExpanded && (\n          <div className=\"mt-3 space-y-2\">\n            {SAMPLE_PROMPTS.map((prompt, idx) => (\n              <button\n                key={idx}\n                onClick={() => onChange(prompt)}\n                className=\"block w-full text-left p-3 bg-gray-100 hover:bg-gray-200 rounded-lg text-sm transition\"\n              >\n                {prompt}\n              </button>\n            ))}\n          </div>\n        )}\n      </div>\n    </div>\n  );\n}\n```\n\n**PanelGrid.tsx (with Drag-and-Drop):**\n```typescript\nimport { useState } from 'react';\nimport { Panel } from '../types';\nimport { DndContext, closestCenter, KeyboardSensor, PointerSensor, useSensor, useSensors } from '@dnd-kit/core';\nimport { SortableContext, sortableKeyboardCoordinates, verticalListSortingStrategy, useSortable } from '@dnd-kit/sortable';\nimport { CSS } from '@dnd-kit/utilities';\n\nfunction SortablePanel({ panel }: { panel: Panel }) {\n  const { attributes, listeners, setNodeRef, transform, transition } = useSortable({ id: panel.id });\n  const style = { transform: CSS.Transform.toString(transform), transition };\n\n  return (\n    <div ref={setNodeRef} style={style} {...attributes} {...listeners} className=\"p-4\">\n      <div className=\"bg-white rounded-lg shadow p-4 cursor-grab active:cursor-grabbing\">\n        <img\n          src={panel.imageUrl}\n          alt={`Panel ${panel.panelIndex}`}\n          className=\"w-full h-auto rounded mb-2\"\n        />\n        <p className=\"text-sm text-gray-600\">{panel.storyBeat}</p>\n        <span className={`inline-block mt-2 px-2 py-1 rounded text-xs text-white ${\n          panel.status === 'generated' ? 'bg-green-500' :\n          panel.status === 'pending' ? 'bg-blue-500' :\n          'bg-red-500'\n        }`}>\n          {panel.status}\n        </span>\n      </div>\n    </div>\n  );\n}\n\ninterface PanelGridProps {\n  panels: Panel[];\n  onReorder: (newOrder: Panel[]) => void;\n}\n\nexport function PanelGrid({ panels, onReorder }: PanelGridProps) {\n  const sensors = useSensors(\n    useSensor(PointerSensor),\n    useSensor(KeyboardSensor, { coordinateGetter: sortableKeyboardCoordinates })\n  );\n\n  const handleDragEnd = (event: any) => {\n    const { active, over } = event;\n    if (over && active.id !== over.id) {\n      const oldIndex = panels.findIndex(p => p.id === active.id);\n      const newIndex = panels.findIndex(p => p.id === over.id);\n      const newPanels = [...panels];\n      [newPanels[oldIndex], newPanels[newIndex]] = [newPanels[newIndex], newPanels[oldIndex]];\n      onReorder(newPanels);\n    }\n  };\n\n  return (\n    <DndContext sensors={sensors} collisionDetection={closestCenter} onDragEnd={handleDragEnd}>\n      <SortableContext items={panels.map(p => p.id)} strategy={verticalListSortingStrategy}>\n        <div className=\"grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-4\">\n          {panels.map(panel => (\n            <SortablePanel key={panel.id} panel={panel} />\n          ))}\n        </div>\n      </SortableContext>\n    </DndContext>\n  );\n}\n```\n\n**ProgressBar.tsx:**\n```typescript\nimport { GenerationProgress } from '../types';\n\nexport function ProgressBar({ progress }: { progress: GenerationProgress }) {\n  return (\n    <div className=\"w-full max-w-2xl\">\n      <div className=\"mb-2 flex justify-between\">\n        <span className=\"text-sm font-semibold\">{progress.message}</span>\n        <span className=\"text-sm text-gray-600\">{Math.round(progress.percentage)}%</span>\n      </div>\n      <div className=\"w-full h-3 bg-gray-200 rounded-full overflow-hidden\">\n        <div\n          className=\"h-full bg-blue-600 transition-all duration-300\"\n          style={{ width: `${progress.percentage}%` }}\n        />\n      </div>\n    </div>\n  );\n}\n```\n\n#### 5. Pages\n\n**CreateMangaPage.tsx:**\n```typescript\nimport { useState } from 'react';\nimport { ImageUploader } from '../components/ImageUploader';\nimport { StoryPromptEditor } from '../components/StoryPromptEditor';\nimport { LayoutSelector } from '../components/LayoutSelector';\nimport { ProgressBar } from '../components/ProgressBar';\nimport { useMangaGeneration } from '../hooks/useMangaGeneration';\nimport { UploadedImage, LayoutConfig } from '../types';\n\nexport function CreateMangaPage() {\n  const [projectName, setProjectName] = useState('');\n  const [storyPrompt, setStoryPrompt] = useState('');\n  const [uploadedImages, setUploadedImages] = useState<UploadedImage[]>([]);\n  const [layoutConfig, setLayoutConfig] = useState<LayoutConfig>({\n    totalPanels: 4,\n    format: 'vertical',\n    readingOrder: 'japanese',\n    gutterSize: 10,\n    borderWidth: 2,\n    borderColor: '#000000',\n    backgroundColor: '#FFFFFF',\n    pageWidth: 800,\n    pageHeight: 1200\n  });\n\n  const { progress, error, generateManga } = useMangaGeneration();\n\n  const handleStart = async () => {\n    if (!projectName || !storyPrompt) {\n      alert('Please enter project name and story prompt');\n      return;\n    }\n\n    await generateManga(projectName, storyPrompt, uploadedImages, layoutConfig, {\n      imageStyle: 'manga style',\n      aspectRatio: 'square',\n      qualityLevel: 'standard'\n    });\n  };\n\n  return (\n    <div className=\"min-h-screen bg-gray-50 py-12 px-4\">\n      <div className=\"max-w-4xl mx-auto space-y-8\">\n        <h1 className=\"text-4xl font-bold text-center mb-2\">koma-fill</h1>\n        <p className=\"text-center text-gray-600\">AI-Powered Manga Panel Generator</p>\n\n        {error && <div className=\"bg-red-100 border border-red-400 text-red-700 px-4 py-3 rounded\">{error}</div>}\n\n        {progress.stage === 'idle' ? (\n          <div className=\"space-y-8\">\n            <div className=\"bg-white p-6 rounded-lg shadow\">\n              <label className=\"block text-lg font-semibold mb-2\">Project Name</label>\n              <input\n                type=\"text\"\n                value={projectName}\n                onChange={e => setProjectName(e.target.value)}\n                className=\"input-field\"\n                placeholder=\"My Awesome Manga\"\n              />\n            </div>\n\n            <div className=\"bg-white p-6 rounded-lg shadow\">\n              <StoryPromptEditor value={storyPrompt} onChange={setStoryPrompt} />\n            </div>\n\n            <div className=\"bg-white p-6 rounded-lg shadow\">\n              <ImageUploader onImagesSelected={setUploadedImages} />\n            </div>\n\n            <div className=\"bg-white p-6 rounded-lg shadow\">\n              <LayoutSelector config={layoutConfig} onChange={setLayoutConfig} />\n            </div>\n\n            <button onClick={handleStart} className=\"btn-primary w-full text-lg py-3\">\n              Generate Manga\n            </button>\n          </div>\n        ) : (\n          <div className=\"bg-white p-6 rounded-lg shadow\">\n            <ProgressBar progress={progress} />\n          </div>\n        )}\n      </div>\n    </div>\n  );\n}\n```\n\n**PreviewPage.tsx:**\n```typescript\nimport { useParams, useNavigate } from 'react-router-dom';\nimport { useEffect, useState } from 'react';\nimport { apiClient } from '../services/apiClient';\nimport { PanelGrid } from '../components/PanelGrid';\nimport { ExportOptions } from '../components/ExportOptions';\nimport { MangaProject } from '../types';\n\nexport function PreviewPage() {\n  const { projectId } = useParams<{ projectId: string }>();\n  const navigate = useNavigate();\n  const [project, setProject] = useState<MangaProject | null>(null);\n  const [loading, setLoading] = useState(true);\n\n  useEffect(() => {\n    if (projectId) {\n      apiClient.getProject(projectId).then(setProject).finally(() => setLoading(false));\n    }\n  }, [projectId]);\n\n  if (loading) return <div className=\"flex justify-center py-12\">Loading...</div>;\n  if (!project) return <div className=\"text-center py-12\">Project not found</div>;\n\n  return (\n    <div className=\"min-h-screen bg-gray-50 py-12 px-4\">\n      <div className=\"max-w-6xl mx-auto\">\n        <button onClick={() => navigate('/')} className=\"btn-secondary mb-6\"> Back</button>\n\n        <h1 className=\"text-3xl font-bold mb-2\">{project.name}</h1>\n        <p className=\"text-gray-600 mb-6\">Project Status: {project.status}</p>\n\n        {project.panels.length > 0 && (\n          <div className=\"bg-white p-6 rounded-lg shadow mb-8\">\n            <h2 className=\"text-2xl font-semibold mb-4\">Panels</h2>\n            <PanelGrid panels={project.panels} onReorder={() => {}} />\n          </div>\n        )}\n\n        <div className=\"bg-white p-6 rounded-lg shadow\">\n          <h2 className=\"text-2xl font-semibold mb-4\">Export</h2>\n          <ExportOptions projectId={project.id} />\n        </div>\n      </div>\n    </div>\n  );\n}\n```\n\n#### 6. Update App.tsx\n\n```typescript\nimport { BrowserRouter as Router, Routes, Route, Navigate } from 'react-router-dom';\nimport { CreateMangaPage } from './pages/CreateMangaPage';\nimport { PreviewPage } from './pages/PreviewPage';\nimport './index.css';\n\nexport default function App() {\n  return (\n    <Router>\n      <Routes>\n        <Route path=\"/\" element={<CreateMangaPage />} />\n        <Route path=\"/project/:projectId\" element={<PreviewPage />} />\n        <Route path=\"*\" element={<Navigate to=\"/\" />} />\n      </Routes>\n    </Router>\n  );\n}\n```\n\n### package.json Updates\n\nAdd dependencies:\n```bash\nnpm install -D tailwindcss postcss autoprefixer\nnpm install react-router-dom @dnd-kit/core @dnd-kit/sortable @dnd-kit/utilities\n```\n\n### Testing Requirements\n\n```bash\n# 1. Start backend (from Task 1)\ncd backend && npm run dev\n\n# 2. In another terminal, start frontend\ncd frontend && npm run dev\n\n# 3. Open browser: http://localhost:3000\n\n# 4. Test workflow:\n# - Enter project name and story\n# - Upload reference images\n# - Configure layout\n# - Click \"Generate Manga\"\n# - Watch progress bar\n# - See panel grid with images\n# - Export to PNG/JPG/PDF\n```\n\n### Files This Task Uses from Other Agents\n\n- **API endpoints** from Task 1 (database & routes)\n- **Analysis data** from Task 2 (character consistency)\n- **Generated images** from Task 3 (panel images)\n- **Composed layouts** from Task 4 (final manga)\n\n### Output Validation Checklist\n\n- [ ] Tailwind CSS configured and working\n- [ ] ImageUploader component with drag-drop works\n- [ ] react-dropzone integration functional\n- [ ] StoryPromptEditor displays with sample prompts\n- [ ] Sample prompt insertion works\n- [ ] PanelGrid displays with drag-and-drop reordering\n- [ ] @dnd-kit integration functional\n- [ ] useMangaGeneration hook orchestrates full workflow\n- [ ] SSE progress streaming displays correctly\n- [ ] ProgressBar updates in real-time\n- [ ] apiClient makes correct API calls\n- [ ] All components have TypeScript types\n- [ ] CreateMangaPage workflow complete\n- [ ] PreviewPage shows generated manga\n- [ ] ExportOptions functional (PNG/JPG/PDF)\n- [ ] Routing works (create  preview)\n- [ ] Error handling displays user-friendly messages\n- [ ] npm run dev starts without errors\n- [ ] No TypeScript compilation errors\n\n---\n\n## Integration Testing (After All Tasks Complete)\n\nAfter all 5 agents finish their implementations, run the following integration tests:\n\n```bash\n# 1. Start backend\ncd /mnt/Projects/koma-fill/backend\nnpm install\nnpm run dev\n# Expected: \" koma-fill server running on http://localhost:5000\"\n\n# 2. Start frontend (new terminal)\ncd /mnt/Projects/koma-fill/frontend\nnpm install\nnpm run dev\n# Expected: \"VITE  ready in XXX ms\"\n\n# 3. Complete workflow test\n# Open http://localhost:3000 in browser\n# - Create project\n# - Upload 2 reference images\n# - Enter story prompt\n# - Select layout (4 panels)\n# - Click \"Generate Manga\"\n# - Wait for completion\n# - View generated panels\n# - Export to PNG\n# - Verify PNG file created in uploads/\n\n# 4. Verify database\nsqlite3 /mnt/Projects/koma-fill/data/koma-fill.db\n> SELECT COUNT(*) FROM projects;\n> SELECT COUNT(*) FROM panels;\n> SELECT COUNT(*) FROM keyImages;\n\n# 5. Check file structure\nls -la /mnt/Projects/koma-fill/uploads/\nls -la /mnt/Projects/koma-fill/data/\n\n# 6. API health check\ncurl http://localhost:5000/api/health\n# Expected: {\"status\":\"ok\",\"timestamp\":\"...\"}\n```\n\n### Known Integration Points to Verify\n\n- Task 1  Task 2: Panel prompts saved in DB, readable by frontend\n- Task 2  Task 3: Vision analysis influences character consistency in prompts\n- Task 3  Task 4: Generated images saved to disk, paths in database\n- Task 4  Task 5: Layout images served via `/uploads/` static directory\n- Task 5  All: Frontend calls all backend API endpoints successfully\n\n---\n\n## Success Criteria Summary\n\nAll 5 tasks completed when:\n\n1. **Backend (Task 1)**: Express server with SQLite database, all CRUD routes working\n2. **Vision & Prompts (Task 2)**: OpenAI Vision API analyzes images, GPT-4o generates DALL-E prompts\n3. **Image Generation (Task 3)**: DALL-E 3 generates 4+ images with retry logic, SSE progress works\n4. **Layout & Export (Task 4)**: Sharp composes panels into manga layout, exports PNG/JPG/PDF\n5. **Frontend (Task 5)**: React UI allows workflow from story  generated manga  export\n\n**Total Expected Time**: 4-5 hours per agent (can run in parallel)\n**Minimum Test Time**: 30 minutes for integration testing\n\nGood luck, KAMUI agents! \n\n---\n\n*Last Updated: 2025-02-12*\n*For issues or questions, refer to the specific task prompts above*\n: \nID: task-1770909069061-f69cf1\nBranch: task/task-1770909069061-f69cf1\nWorktree: Users/yuyafujita/Projects/koma-fill/.worktrees/task-1770909069061-f69cf1",
        "branchColor": "#e8e84f",
        "index": 27
      },
      {
        "type": "anchor",
        "label": "[] ClaudeCode3: # KAMUI-4D Parallel",
        "branch": "task/task-1770909069269-afb680",
        "worktreePath": "/Users/yuyafujita/Projects/koma-fill/.worktrees/task-1770909069269-afb680",
        "parentCommitHash": "1515fedca072442ad0656037229bce50b2e341f3",
        "lane": 13,
        "isMerged": false,
        "mergeCommitHash": null,
        "statusChildren": [],
        "isDefaultWorktree": false,
        "renderMode": "node",
        "shouldHide": false,
        "tagLabel": "task/task-1770909069269-afb680",
        "taskId": "task-1770909069269-afb680",
        "taskStatus": "working",
        "taskStatusLabel": "",
        "taskName": "ClaudeCode3: # KAMUI-4D Parallel Task Prompts for koma-fill\n## Manga Generation AI System - Multi-Agent Implementation Guide\n\n**Version:** 1.0\n**Project:** koma-fill - AI-powered manga panel generation system\n**Target:** KAMUI-4D Editor (Multi-AI CLI parallel execution)\n\n---\n\n## How to Use These Prompts in KAMUI-4D\n\nThis document contains **5 independent task prompts** designed to run in parallel across multiple AI coding agents. Each prompt is self-contained and can be executed independently without blocking other tasks.\n\n### Setup Instructions\n\n1. **Install dependencies** (run once before starting tasks):\n   ```bash\n   cd /mnt/Projects/koma-fill/backend\n   npm install\n\n   cd /mnt/Projects/koma-fill/frontend\n   npm install\n   ```\n\n2. **Environment Configuration**:\n   Create `/mnt/Projects/koma-fill/.env`:\n   ```\n   NODE_ENV=development\n   PORT=5000\n   BASE_URL=http://localhost:5000\n   OPENAI_API_KEY=your_openai_api_key_here\n   OPENAI_ORG_ID=your_org_id_optional\n   DATABASE_PATH=./data/koma-fill.db\n   STORAGE_PATH=./uploads\n   MAX_IMAGE_SIZE_MB=20\n   DALLE_RATE_LIMIT_PER_MINUTE=5\n   VISION_RATE_LIMIT_PER_MINUTE=30\n   MAX_RETRIES_PER_PANEL=3\n   ALLOWED_ORIGINS=http://localhost:3000\n   ```\n\n3. **Execution Strategy**:\n   - Copy each task prompt below into a separate KAMUI-4D session/agent\n   - **Tasks 1-5 can ALL start simultaneously** (no blocking dependencies)\n   - Each task should run independently in its own AI CLI session\n   - Monitor each agent's progress via console output\n   - **Integration testing** should happen after all 5 tasks complete (see bottom of doc)\n\n4. **Task Dependencies**:\n   ```\n   Task 1 (Backend)  provides database & API contracts\n   Task 2 (Vision)  uses Task 1's API, reads backend/src/models/types.ts\n   Task 3 (Images)  uses Task 1's API, reads backend/src/models/types.ts\n   Task 4 (Layout)  uses Task 1's API, reads backend/src/models/types.ts\n   Task 5 (Frontend)  calls Tasks 1-4 via REST API\n   ```\n   **All tasks can start immediately** - they communicate via file system and API contracts.\n\n---\n\n## Task 1: Backend (Agent A)\n### Express Server, SQLite Database & CRUD Routes Foundation\n\n**Time Estimate:** 45-60 minutes\n**Difficulty:** Intermediate\n**Dependencies:** None (this is the foundation layer)\n\n### Objective\nSet up a fully functional Express.js backend with SQLite database, implement CRUD operations for manga projects and panels, configure file upload handling with multer, and provide a solid API foundation for other agents to build upon.\n\n### Target Files to Create/Modify\n\n```\nbackend/\n src/\n    database/\n       connection.ts          [NEW] SQLite connection & initialization\n       schema.ts              [NEW] Table schema definitions\n    index.ts                   [MODIFY] Add DB initialization\n    app.ts                     [COMPLETE] Already done - verify middleware\n    routes/\n       manga.ts               [IMPLEMENT] Route handlers with DB calls\n    middleware/\n        errorHandler.ts        [VERIFY] Already complete\n uploads/                        [CREATE] Directory for image storage\n data/                           [CREATE] Directory for SQLite DB\n```\n\n### TypeScript Interfaces (from `/mnt/Projects/koma-fill/backend/src/models/types.ts`)\n\nKey types you'll use:\n```typescript\n// Core entities\nMangaProject {\n  id: string;                    // UUID\n  name: string;\n  description?: string;\n  status: ProjectStatus;         // 'draft' | 'analyzing' | 'generating' | 'complete' | 'exported'\n  layoutConfig: LayoutConfig;\n  generationSettings: GenerationSettings;\n  panels: Panel[];\n  keyImages: KeyImage[];\n  totalCost: number;\n  createdAt: string;             // ISO datetime\n  updatedAt: string;\n}\n\nPanel {\n  id: string;                    // UUID\n  projectId: string;\n  panelIndex: number;            // 0-based\n  imageUrl?: string;\n  imageFilePath?: string;\n  prompt?: string;\n  storyBeat?: string;\n  speechBubbleText?: string;\n  status: PanelStatus;           // 'pending' | 'generated' | 'failed' | 'placeholder'\n  retryCount: number;\n  generatedAt?: string;\n  createdAt: string;\n}\n\nKeyImage {\n  id: string;                    // UUID\n  projectId: string;\n  imageFilePath: string;\n  position: ImagePosition;       // 'start' | 'end' | number\n  analysis?: ImageAnalysis;\n  createdAt: string;\n}\n\nLayoutConfig {\n  totalPanels: number;           // 4, 6, 8, etc.\n  format: LayoutFormat;          // 'vertical' | 'horizontal' | 'square'\n  readingOrder: ReadingOrder;    // 'japanese' | 'western'\n  gutterSize: number;            // px\n  borderWidth: number;           // px\n  borderColor: string;           // hex #RRGGBB\n  backgroundColor: string;       // hex\n  pageWidth: number;             // px\n  pageHeight: number;            // px\n}\n\nGenerationSettings {\n  imageStyle: string;            // e.g., \"manga style, black and white ink\"\n  aspectRatio: 'square' | 'wide' | 'tall';\n  qualityLevel: 'standard' | 'hd';\n  negativePrompt?: string;\n  seed?: number;\n}\n```\n\n### Implementation Checklist\n\n#### 1. Create Database Connection Module (`backend/src/database/connection.ts`)\n```typescript\n// Requirements:\n- Initialize better-sqlite3 connection\n- Create/open database at DATABASE_PATH from .env\n- Export initDatabase() async function\n- Enable foreign keys constraint\n- Handle database file creation if needed\n- Connection should be cached/singleton\n```\n\n#### 2. Create Database Schema Module (`backend/src/database/schema.ts`)\n```typescript\n// SQL Schema Requirements:\nCREATE TABLE projects (\n  id TEXT PRIMARY KEY,\n  name TEXT NOT NULL,\n  description TEXT,\n  status TEXT NOT NULL,\n  layoutConfig JSON NOT NULL,\n  generationSettings JSON NOT NULL,\n  totalCost REAL DEFAULT 0,\n  createdAt TEXT NOT NULL,\n  updatedAt TEXT NOT NULL\n);\n\nCREATE TABLE panels (\n  id TEXT PRIMARY KEY,\n  projectId TEXT NOT NULL,\n  panelIndex INTEGER NOT NULL,\n  imageUrl TEXT,\n  imageFilePath TEXT,\n  prompt TEXT,\n  storyBeat TEXT,\n  speechBubbleText TEXT,\n  status TEXT NOT NULL,\n  retryCount INTEGER DEFAULT 0,\n  generatedAt TEXT,\n  createdAt TEXT NOT NULL,\n  FOREIGN KEY (projectId) REFERENCES projects(id)\n);\n\nCREATE TABLE keyImages (\n  id TEXT PRIMARY KEY,\n  projectId TEXT NOT NULL,\n  imageFilePath TEXT NOT NULL,\n  position TEXT NOT NULL,\n  analysis JSON,\n  createdAt TEXT NOT NULL,\n  FOREIGN KEY (projectId) REFERENCES projects(id)\n);\n\nCREATE INDEX idx_project_status ON projects(status);\nCREATE INDEX idx_panel_project ON panels(projectId);\nCREATE INDEX idx_panel_status ON panels(status);\n```\n\n#### 3. Modify `backend/src/index.ts`\n```typescript\n// Add:\n- Import { initDatabase } from './database/connection'\n- Call await initDatabase() before app.listen()\n- Log database initialization success\n```\n\n#### 4. Create Repository Layer (`backend/src/repositories/`)\n```typescript\n// Create:\n- ProjectRepository with methods:\n  - createProject(data: CreateMangaRequest): Promise<MangaProject>\n  - getProject(id: string): Promise<MangaProject | null>\n  - listProjects(limit: number, offset: number): Promise<MangaProject[]>\n  - updateProject(id: string, updates: Partial<MangaProject>): Promise<MangaProject>\n  - deleteProject(id: string): Promise<void>\n\n- PanelRepository with methods:\n  - createPanel(projectId: string, data: Panel): Promise<Panel>\n  - getPanelsByProject(projectId: string): Promise<Panel[]>\n  - getPanel(panelId: string): Promise<Panel | null>\n  - updatePanel(panelId: string, updates: Partial<Panel>): Promise<Panel>\n  - updatePanelStatus(panelId: string, status: PanelStatus): Promise<void>\n\n- KeyImageRepository with methods:\n  - createKeyImage(projectId: string, data: KeyImage): Promise<KeyImage>\n  - getKeyImages(projectId: string): Promise<KeyImage[]>\n  - updateKeyImageAnalysis(imageId: string, analysis: ImageAnalysis): Promise<void>\n```\n\n#### 5. Implement Routes in `backend/src/routes/manga.ts`\nReplace TODO comments with actual implementations:\n\n- **POST /api/manga/create**\n  - Validate CreateMangaRequest using Joi\n  - Generate unique project ID (uuid)\n  - Create project in database with 'draft' status\n  - Create initial panel records (count = layoutConfig.totalPanels)\n  - Return created MangaProject with 201 status\n\n- **POST /api/manga/:projectId/upload**\n  - Files already handled by multer middleware\n  - Save KeyImage records to database with file paths\n  - Store position information\n  - Return array of KeyImage objects\n\n- **GET /api/manga/:projectId**\n  - Fetch project + panels + key images from database\n  - Return complete MangaProject object\n  - Throw NotFoundError if project doesn't exist\n\n- **GET /api/manga**\n  - Implement pagination (limit/offset query params)\n  - Return array of projects\n  - Include total count header\n\n- **PUT /api/manga/:projectId/reorder**\n  - Parse ReorderPanelsRequest body\n  - Update panelIndex for each panel based on new order\n  - Return updated panels array\n\n### Testing Requirements\n\nAfter implementation, verify:\n\n```bash\n# 1. Database initialization\nnpm run dev\n# Check console: \" configured\" for database\n\n# 2. Create project\ncurl -X POST http://localhost:5000/api/manga/create \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\n    \"projectName\": \"Test Manga\",\n    \"storyPrompt\": \"A hero on a quest\",\n    \"layoutConfig\": { \"totalPanels\": 4 }\n  }'\n\n# 3. Get project\ncurl http://localhost:5000/api/manga/{projectId}\n\n# 4. Upload images\ncurl -X POST http://localhost:5000/api/manga/{projectId}/upload \\\n  -F \"images=@test1.jpg\" \\\n  -F \"images=@test2.jpg\"\n\n# 5. Check database\nsqlite3 data/koma-fill.db \"SELECT * FROM projects; SELECT * FROM panels;\"\n```\n\n### Files This Task Provides to Other Agents\n\n- **Database schema** - Tasks 2, 3, 4, 5 will read/write to these tables\n- **API contracts** - manga.ts route signatures that Tasks 2-4 will call\n- **File storage structure** - uploads/ directory path that Task 3 will use\n- **Type definitions** - already in backend/src/models/types.ts (reference only)\n\n### Output Validation Checklist\n\n- [ ] Database file created at `data/koma-fill.db`\n- [ ] All 3 tables created with correct schema\n- [ ] Repositories implement CRUD operations\n- [ ] All route handlers work without TODO comments\n- [ ] multer uploads save files to `uploads/` directory\n- [ ] POST /create returns 201 with MangaProject object\n- [ ] GET /:projectId returns full project with panels\n- [ ] Error handler catches and responds appropriately\n- [ ] No TypeScript compilation errors\n- [ ] npm run dev starts without errors\n\n---\n\n## Task 2: + (Agent B)\n### Vision API Integration & DALL-E Prompt Generation\n\n**Time Estimate:** 50-60 minutes\n**Difficulty:** Intermediate\n**Dependencies:** Task 1 (needs database & API routes available)\n\n### Objective\nImplement OpenAI Vision API integration to analyze uploaded key images and extract character/style information. Then implement story-to-panel prompt generation using GPT-4o to create DALL-E 3 compatible prompts that maintain consistency across panels.\n\n### Target Files to Create/Modify\n\n```\nbackend/\n src/\n     services/\n         imageAnalysisService.ts      [IMPLEMENT] Vision API analysis\n         promptGenerationService.ts   [CREATE] Story  panel prompts\n```\n\n### System Prompts (Already Provided)\n\nBoth vision analysis prompts are defined in `imageAnalysisService.ts`:\n- `QUICK_ANALYSIS_PROMPT` - fast, ~500 tokens\n- `DETAILED_ANALYSIS_PROMPT` - thorough, ~2000 tokens\n\nThese guide the Vision API to return structured JSON matching the `ImageAnalysis` interface.\n\n### TypeScript Interfaces\n\n```typescript\n// Input: Key image file path (from Task 1)\n// Output: ImageAnalysis object\n\nImageAnalysis {\n  description: string;\n  characters: CharacterInfo[];\n  objects: string[];\n  colors: string[];\n  composition: string;\n  mood: string;\n  artStyle: string;\n  suggestedTransitions: string[];\n}\n\nCharacterInfo {\n  name?: string;\n  appearance: string;        // detailed physical description\n  emotion: string;\n  position: string;          // screen position (e.g., \"center-left\")\n}\n\n// Panel prompt generation\nPanelPrompt {\n  panelIndex: number;\n  dallePrompt: string;       // Full DALL-E 3 prompt (100-300 words)\n  storyBeat: string;         // What happens in this panel\n  visualFocus: string;       // Main visual element\n  transitionType: TransitionType;  // 'cut' | 'pan' | 'zoom_in' | 'zoom_out' | 'fade' | 'action'\n  suggestedDialogue?: string;\n}\n```\n\n### Implementation Details\n\n#### ImageAnalysisService (`backend/src/services/imageAnalysisService.ts`)\n\n**Constructor:**\n```typescript\nconstructor() {\n  this.openai = new OpenAI({\n    apiKey: CONFIG.OPENAI_API_KEY,\n    organization: CONFIG.OPENAI_ORG_ID\n  });\n}\n```\n\n**Method: analyzeImage(imageBase64: string, depth: 'quick' | 'detailed')**\n- Input: Base64-encoded image data from KeyImage file\n- Implementation:\n  1. Read image file and convert to Base64 (if not already)\n  2. Call `this.openai.chat.completions.create()`:\n     - model: CONFIG.VISION_MODEL ('gpt-4o')\n     - messages: [\n       { role: 'system', content: QUICK_ANALYSIS_PROMPT or DETAILED_ANALYSIS_PROMPT }\n       { role: 'user', content: [\n         { type: 'image_url', image_url: { url: `data:image/png;base64,${imageBase64}` } }\n       ]}\n     ]\n     - response_format: { type: 'json_object' }\n     - max_tokens: depth === 'quick' ? 500 : 2000\n  3. Parse response.choices[0].message.content as JSON\n  4. Validate against ImageAnalysis schema\n  5. Return ImageAnalysis object\n\n**Method: analyzeMultiple(images, depth)**\n- Input: Array of { base64, position } objects\n- Use Promise.all with rate limiting (max CONFIG.VISION_RATE_LIMIT_PER_MINUTE calls/min)\n- Implement backoff if rate limited\n- Return array of ImageAnalysis objects\n\n**Method: extractCharacters(analysis)**\n- Optional: Deep-dive character extraction\n- Can call another Vision API pass if needed for more detail\n\n#### PromptGenerationService (NEW FILE - `backend/src/services/promptGenerationService.ts`)\n\n**Constructor:**\n```typescript\nconstructor() {\n  this.openai = new OpenAI({ apiKey: CONFIG.OPENAI_API_KEY });\n}\n```\n\n**Method: generatePanelPrompts(request: GeneratePromptsRequest)**\n\nInput:\n```typescript\nGeneratePromptsRequest {\n  storyPrompt: string;           // User's story\n  panelCount: number;            // Total panels to generate\n  characterConsistency: boolean; // Whether to maintain character consistency\n}\n```\n\nImplementation:\n1. **Story Breakdown Phase:**\n   - Call GPT-4o to split story into N panel beats\n   - System prompt should guide structure like:\n   ```\n   \"You are a manga story expert. Break the provided story into exactly {panelCount}\n    distinct visual beats. Each beat should be 1-2 sentences describing what happens\n    visually in that panel. Format as JSON array of objects with 'panelIndex' and 'beat' fields.\"\n   ```\n\n2. **Character Consistency Analysis:**\n   - If characterConsistency=true and keyImages were analyzed:\n     - Retrieve stored ImageAnalysis for key images\n     - Create character consistency profile (appearance, emotion arcs, etc.)\n     - Include in subsequent prompts\n\n3. **DALL-E 3 Prompt Generation:**\n   - For each story beat, create detailed DALL-E 3 prompt\n   - System prompt pattern:\n   ```\n   \"You are a DALL-E 3 prompt expert specializing in manga panels.\n    Given a story beat, generate a detailed visual prompt (100-300 words) that:\n    - Specifies art style: {generationSettings.imageStyle}\n    - Maintains character consistency: {characterProfile}\n    - Follows manga composition principles\n    - Uses specific visual terms (angle, lighting, pose, emotion)\n    - Avoids abstract concepts; be concrete and visual\n    - Follows DALL-E 3 content policy\n\n    Return JSON with: { dallePrompt, visualFocus, transitionType, suggestedDialogue }\"\n   ```\n\n4. **Transition Logic:**\n   - Analyze flow between consecutive beats\n   - Suggest transition type ('cut', 'pan', 'zoom_in', etc.)\n   - Update imageUrl in previous panel to support transitions\n\n5. **Return Value:**\n   - Array of PanelPrompt objects, one per panel\n   - Each with populated dallePrompt, storyBeat, visualFocus, transitionType\n\n### Database Integration\n\nAfter generating prompts, save to Panel table:\n- Update each panel's `prompt` field with `dallePrompt`\n- Update `storyBeat` field\n- Update `status` to 'pending' (ready for image generation)\n\n### API Integration\n\nImplement route handlers in `backend/src/routes/manga.ts`:\n\n**POST /api/manga/:projectId/analyze**\n```typescript\n// 1. Fetch project and keyImages from DB\n// 2. Read image files and convert to Base64\n// 3. Call imageAnalysisService.analyzeMultiple()\n// 4. Store analysis results in DB (keyImages.analysis)\n// 5. Update project status to 'analyzing'  'complete'\n// 6. Return analysis results\n```\n\n**POST /api/manga/:projectId/generate-prompts**\n```typescript\n// 1. Validate GeneratePromptsRequest\n// 2. Fetch project and keyImages analyses from DB\n// 3. Call promptGenerationService.generatePanelPrompts()\n// 4. Update panel records with generated prompts\n// 5. Update project status to 'generating'\n// 6. Return array of PanelPrompt objects\n```\n\n### Testing Requirements\n\n```bash\n# 1. Prepare test image\n# (Use any PNG/JPG with a character or scene)\n\n# 2. Create project and upload image (Task 1)\nPROJECT_ID=$(curl -s -X POST http://localhost:5000/api/manga/create \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"projectName\":\"Test\",\"storyPrompt\":\"A hero finds treasure\"}' | jq -r '.id')\n\n# 3. Upload test image\ncurl -X POST http://localhost:5000/api/manga/$PROJECT_ID/upload \\\n  -F \"images=@test_image.jpg\"\n\n# 4. Analyze images\ncurl -X POST http://localhost:5000/api/manga/$PROJECT_ID/analyze \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"analysisDepth\":\"quick\"}'\n\n# 5. Generate prompts\ncurl -X POST http://localhost:5000/api/manga/$PROJECT_ID/generate-prompts \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\n    \"storyPrompt\": \"A hero finds treasure in a dark cave\",\n    \"panelCount\": 4,\n    \"characterConsistency\": true\n  }'\n\n# 6. Verify output\ncurl http://localhost:5000/api/manga/$PROJECT_ID | jq '.panels[].prompt'\n```\n\n### Files This Task Provides to Other Agents\n\n- **Panel prompt data** - Stored in DB panels table, used by Task 3 for image generation\n- **Character analysis** - Used by Task 5 frontend for display\n- **Art style consistency** - Guides Task 3's image generation\n\n### Output Validation Checklist\n\n- [ ] ImageAnalysisService.analyzeImage() calls Vision API successfully\n- [ ] Vision API responses parse correctly to ImageAnalysis\n- [ ] PromptGenerationService generates DALL-E-compatible prompts\n- [ ] Panel prompts maintain character consistency (if enabled)\n- [ ] Transition types are correctly assigned\n- [ ] All panel records updated in database with prompts\n- [ ] /analyze endpoint returns ImageAnalysis array\n- [ ] /generate-prompts endpoint returns PanelPrompt array\n- [ ] Error handling for API failures (rate limits, auth, etc.)\n- [ ] No TypeScript compilation errors\n\n---\n\n## Task 3: DALL-E 3 (Agent C)\n### Image Generation with Retry Logic & Progress Streaming\n\n**Time Estimate:** 50-70 minutes\n**Difficulty:** Intermediate-Advanced\n**Dependencies:** Task 1 (DB & API), Task 2 (panel prompts)\n\n### Objective\nImplement DALL-E 3 image generation with robust error handling, exponential backoff retry logic, local image storage, Server-Sent Events (SSE) streaming for real-time progress updates, and cost tracking per API call.\n\n### Target Files to Create/Modify\n\n```\nbackend/\n src/\n     services/\n         imageGenerationService.ts    [IMPLEMENT] DALL-E 3 API integration\n         (imageProcessor.ts)          [REFERENCE] Utility for image processing\n```\n\n### TypeScript Interfaces\n\n```typescript\nGeneratedPanel {\n  panelIndex: number;\n  imageUrl: string;              // DALL-E public URL (temporary)\n  localFilePath: string;         // /uploads/{projectId}/panel_{index}.png\n  prompt: string;                // Original prompt sent\n  revisedPrompt?: string;        // DALL-E 3's revised prompt (if modified)\n  costUsd: number;               // API call cost\n}\n\n// Request type\nGenerateImagesRequest {\n  panelIndices?: number[];       // undefined = all panels\n  batchMode: 'sequential' | 'parallel';\n}\n\n// Progress event (sent via SSE)\nProgressEvent {\n  type: 'progress' | 'complete' | 'error';\n  stage: string;                 // 'generating_images'\n  currentStep: number;           // Current panel index\n  totalSteps: number;            // Total panels\n  percentage: number;            // 0-100\n  message: string;               // Human-readable status\n  panelId?: string;\n  panelIndex?: number;\n  error?: string;                // Error message if type='error'\n}\n```\n\n### Implementation Details\n\n#### ImageGenerationService (`backend/src/services/imageGenerationService.ts`)\n\n**Constructor & Initialization:**\n```typescript\nconstructor() {\n  this.openai = new OpenAI({ apiKey: CONFIG.OPENAI_API_KEY });\n  this.uploadDir = path.resolve(CONFIG.STORAGE_PATH);\n}\n```\n\n**Method: generatePanel() - Single Panel Generation**\n\n```typescript\nasync generatePanel(\n  prompt: string,\n  panelIndex: number,\n  projectId: string,\n  settings?: GenerationSettings\n): Promise<GeneratedPanel>\n```\n\nImplementation:\n1. **Image Size Calculation:**\n   - Map aspectRatio to DALL-E 3 size:\n     - 'square'  '1024x1024'\n     - 'wide'  '1792x1024'\n     - 'tall'  '1024x1792'\n\n2. **API Call (with retry logic in wrapper):**\n   ```typescript\n   const response = await this.openai.images.generate({\n     model: CONFIG.DALLE_MODEL,           // 'dall-e-3'\n     prompt: prompt,\n     n: 1,\n     size: size,\n     quality: settings?.qualityLevel === 'hd' ? 'hd' : 'standard',\n     style: 'natural',                    // or 'vivid' for more dramatic\n   });\n   ```\n\n3. **Extract Response Data:**\n   - imageUrl = response.data[0].url\n   - revisedPrompt = response.data[0].revised_prompt\n   - Calculate cost based on settings.qualityLevel:\n     - standard: $0.040 per image\n     - hd: $0.080 per image\n\n4. **Download & Save Image:**\n   - Call this.downloadAndSave(imageUrl, projectId, panelIndex)\n   - Saves as PNG: `{STORAGE_PATH}/{projectId}/panel_{panelIndex}.png`\n   - Returns localFilePath\n\n5. **Return GeneratedPanel object**\n\n**Method: generateBatch() - Batch Generation with Mode Selection**\n\n```typescript\nasync generateBatch(\n  panelPrompts: PanelPrompt[],\n  projectId: string,\n  batchMode: 'sequential' | 'parallel',\n  settings?: GenerationSettings,\n  onProgress?: (event: ProgressEvent) => void\n): Promise<GeneratedPanel[]>\n```\n\nImplementation:\n1. Validate inputs\n2. Route to sequential or parallel handler\n3. Call onProgress callback with progress events\n4. Return array of GeneratedPanel\n\n**Method: generateSequential() - Rate-Limit Friendly**\n\n```typescript\nprivate async generateSequential(\n  panelPrompts: PanelPrompt[],\n  projectId: string,\n  settings?: GenerationSettings,\n  onProgress?: (event: ProgressEvent) => void\n): Promise<GeneratedPanel[]>\n```\n\nImplementation:\n1. Initialize results array\n2. For each panelPrompt (with index):\n   a. Call generatePanelWithRetry(panelPrompt, projectId, settings)\n   b. On success:\n      - Add to results array\n      - Call onProgress with percentage = (index + 1) / total * 100\n   c. On failure (after max retries):\n      - Update panel status to 'failed' in DB\n      - Log error\n      - Continue to next panel\n\n3. Return results array (may include failed panels with status='failed')\n\n**Method: generateParallel() - High Speed (Rate Limit Aware)**\n\n```typescript\nprivate async generateParallel(\n  panelPrompts: PanelPrompt[],\n  projectId: string,\n  settings?: GenerationSettings,\n  onProgress?: (event: ProgressEvent) => void\n): Promise<GeneratedPanel[]>\n```\n\nImplementation:\n1. **Batch Control:**\n   - Max concurrent = Math.floor(CONFIG.DALLE_RATE_LIMIT_PER_MINUTE / 2)\n   - Split panelPrompts into batches of max concurrent\n\n2. **For each batch:**\n   - Create Promise.allSettled() for batch\n   - Wait for all to settle\n   - Process results\n   - Send progress update to onProgress\n   - Delay before next batch (respect rate limits)\n\n3. **Failure Handling:**\n   - Collect failed panels\n   - Retry failed panels sequentially (exponential backoff)\n   - Update onProgress for retries\n\n4. **Return results array**\n\n**Method: generatePanelWithRetry() - Core Retry Logic**\n\n```typescript\nprivate async generatePanelWithRetry(\n  panelPrompt: PanelPrompt,\n  projectId: string,\n  settings?: GenerationSettings,\n  retryCount: number = 0\n): Promise<GeneratedPanel>\n```\n\nImplementation:\n1. Try to generate panel via generatePanel()\n2. On success: Return GeneratedPanel\n3. On failure:\n   - If retryCount < CONFIG.MAX_RETRIES_PER_PANEL:\n     - Calculate backoff delay: 2^retryCount * 1000ms (exponential)\n     - Wait for delay\n     - Recursively call with retryCount++\n   - If max retries exceeded:\n     - Throw error with panel index info\n\n**Exponential Backoff Formula:**\n```\ndelay(attempt) = base_delay * (2 ^ attempt) + random jitter\ndelay(0) = 1000ms (1 second)\ndelay(1) = 2000ms (2 seconds)\ndelay(2) = 4000ms (4 seconds)\n+ add random(0, 500ms) jitter to avoid thundering herd\n```\n\n**Method: downloadAndSave() - Store Images Locally**\n\n```typescript\nprivate async downloadAndSave(\n  imageUrl: string,\n  projectId: string,\n  panelIndex: number\n): Promise<string>\n```\n\nImplementation:\n1. Create project uploads directory if not exists: `{STORAGE_PATH}/{projectId}/`\n2. Fetch image from URL using axios or native fetch:\n   ```typescript\n   const response = await fetch(imageUrl);\n   const arrayBuffer = await response.arrayBuffer();\n   const buffer = Buffer.from(arrayBuffer);\n   ```\n3. Save to disk:\n   ```typescript\n   const filePath = path.join(this.uploadDir, projectId, `panel_${panelIndex}.png`);\n   await fs.writeFile(filePath, buffer);\n   ```\n4. Return relative or absolute path\n\n**Method: getImageSize() - Aspect Ratio to DALL-E Size**\n\n```typescript\nprivate getImageSize(\n  aspectRatio: string\n): '1024x1024' | '1792x1024' | '1024x1792'\n```\n\nSelf-explanatory mapping function.\n\n### Route Handler Integration\n\nImplement in `backend/src/routes/manga.ts`:\n\n**POST /api/manga/:projectId/generate-images - SSE Streaming**\n\n```typescript\nrouter.post('/:projectId/generate-images', async (req, res, next) => {\n  try {\n    const { projectId } = req.params;\n    const { panelIndices, batchMode } = req.body as GenerateImagesRequest;\n\n    // Set up SSE response\n    res.setHeader('Content-Type', 'text/event-stream');\n    res.setHeader('Cache-Control', 'no-cache');\n    res.setHeader('Connection', 'keep-alive');\n\n    // Fetch project and panels from DB\n    const project = await getProject(projectId);\n    if (!project) throw new NotFoundError('Project');\n\n    // Filter panels (all or specific indices)\n    const panelsToGenerate = project.panels.filter(\n      p => !panelIndices || panelIndices.includes(p.panelIndex)\n    );\n\n    // Generate prompts array\n    const panelPrompts: PanelPrompt[] = panelsToGenerate.map(p => ({\n      panelIndex: p.panelIndex,\n      dallePrompt: p.prompt!,\n      storyBeat: p.storyBeat!,\n      visualFocus: 'main subject',  // Extract from context if available\n      transitionType: 'cut',        // Default, could be from DB\n    }));\n\n    // Call imageGenerationService\n    imageGenService.generateBatch(\n      panelPrompts,\n      projectId,\n      batchMode,\n      project.generationSettings,\n      (progressEvent) => {\n        // Send progress as SSE\n        res.write(`data: ${JSON.stringify(progressEvent)}\\n\\n`);\n      }\n    ).then(generatedPanels => {\n      // Update database with generated images\n      for (const panel of generatedPanels) {\n        updatePanelImage(panel.panelIndex, {\n          imageUrl: panel.imageUrl,\n          imageFilePath: panel.localFilePath,\n          revisedPrompt: panel.revisedPrompt,\n          status: panel.revisedPrompt ? 'generated' : 'generated',\n        });\n      }\n\n      // Send completion event\n      res.write(`data: ${JSON.stringify({\n        type: 'complete',\n        message: 'Image generation complete',\n        totalCost: generatedPanels.reduce((sum, p) => sum + p.costUsd, 0),\n      })}\\n\\n`);\n\n      res.end();\n    }).catch(err => {\n      res.write(`data: ${JSON.stringify({\n        type: 'error',\n        message: err.message,\n      })}\\n\\n`);\n      res.end();\n    });\n  } catch (err) {\n    next(err);\n  }\n});\n```\n\n### Cost Tracking\n\n**Implementation:**\n- Track cost per API call in GeneratedPanel.costUsd\n- Sum across all panels: `totalCost = sum(generatedPanels.map(p => p.costUsd))`\n- Update project.totalCost in DB: `project.totalCost += generatedPanels totalCost`\n- Log costs for each call (useful for budget monitoring)\n\n**Cost Constants (from types.ts):**\n```typescript\nAPI_COSTS = {\n  VISION_PER_CALL: 0.025,    // GPT-4V\n  DALLE3_STANDARD: 0.040,    // per image\n  DALLE3_HD: 0.080,          // per image\n}\n```\n\n### Testing Requirements\n\n```bash\n# 1. Set up test project (with prompts from Task 2)\nPROJECT_ID=\"test-project-id\"\n# Or use output from Task 2 test\n\n# 2. Generate images (sequential mode)\ncurl -X POST http://localhost:5000/api/manga/$PROJECT_ID/generate-images \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"batchMode\": \"sequential\"}' \\\n  -H \"Accept: text/event-stream\"\n\n# 3. Verify local image files created\nls -la uploads/$PROJECT_ID/\n\n# 4. Check database for updated image URLs\nsqlite3 data/koma-fill.db \"SELECT panelIndex, imageFilePath, status FROM panels WHERE projectId='$PROJECT_ID';\"\n\n# 5. Verify cost tracking\ncurl http://localhost:5000/api/manga/$PROJECT_ID | jq '.totalCost'\n```\n\n### Files This Task Provides to Other Agents\n\n- **Generated panel images** - Stored in uploads/{projectId}/, used by Task 4\n- **Image file paths** - Updated in DB, used by Task 4 for layout composition\n- **Cost tracking** - Used by frontend for budget display\n\n### Output Validation Checklist\n\n- [ ] DALL-E 3 API calls succeed with valid prompts\n- [ ] Retry logic works with exponential backoff\n- [ ] Images download and save to {STORAGE_PATH}/{projectId}/\n- [ ] SSE streaming sends progress events correctly\n- [ ] onProgress callback fires with accurate percentage\n- [ ] Cost calculation correct (0.04 standard, 0.08 HD)\n- [ ] Panel records updated with imageUrl and imageFilePath\n- [ ] Sequential and parallel modes both work\n- [ ] Rate limiting respected (max 5 calls/min by default)\n- [ ] Error handling for network issues, API failures\n- [ ] No TypeScript compilation errors\n\n---\n\n## Task 4: + (Agent D)\n### Manga Layout Composition & Multi-Format Export\n\n**Time Estimate:** 45-60 minutes\n**Difficulty:** Intermediate (Sharp library learning curve)\n**Dependencies:** Task 1 (DB), Task 3 (generated images)\n\n### Objective\nImplement Sharp-based manga layout composition with grid calculation, panel resizing and positioning, border/gutter rendering, speech bubble overlay, and PNG/JPG/PDF export functionality.\n\n### Target Files to Create/Modify\n\n```\nbackend/\n src/\n     services/\n        layoutEngine.ts          [IMPLEMENT] Panel composition & layout\n        exportService.ts         [CREATE] PNG/JPG/PDF export\n     utils/\n         imageProcessor.ts        [HELPER] Image processing utilities\n```\n\n### TypeScript Interfaces\n\n```typescript\n// Layout composition result\nComposedLayout {\n  buffer: Buffer;                    // PNG image buffer\n  width: number;                     // Page width (px)\n  height: number;                    // Page height (px)\n  format: 'png';\n  panelPositions: PanelPosition[];   // Position data for each panel\n}\n\nPanelPosition {\n  panelIndex: number;\n  x: number;                         // Offset from top-left (px)\n  y: number;\n  width: number;                     // Panel width (px)\n  height: number;                    // Panel height (px)\n}\n\n// Input to layout engine\nLayoutConfig {\n  totalPanels: number;               // 4, 6, 8, etc.\n  format: LayoutFormat;              // 'vertical' | 'horizontal' | 'square'\n  readingOrder: ReadingOrder;        // 'japanese' | 'western'\n  gutterSize: number;                // Space between panels (px)\n  borderWidth: number;               // Panel border thickness (px)\n  borderColor: string;               // Hex color\n  backgroundColor: string;           // Hex color\n  pageWidth: number;                 // Canvas width (px)\n  pageHeight: number;                // Canvas height (px)\n}\n```\n\n### Implementation Details\n\n#### LayoutEngine (`backend/src/services/layoutEngine.ts`)\n\n**Method: composePanels() - Main Composition Function**\n\n```typescript\nasync composePanels(\n  panelImagePaths: string[],\n  config: LayoutConfig = DEFAULT_LAYOUT_CONFIG\n): Promise<ComposedLayout>\n```\n\nImplementation Steps:\n\n1. **Calculate Grid:**\n   ```typescript\n   const grid = this.calculateGrid(panelImagePaths.length, config);\n   // Returns { cols: number, rows: number }\n   ```\n   Already implemented - use it.\n\n2. **Calculate Panel Positions:**\n   ```typescript\n   const positions = this.calculatePanelPositions(grid, config);\n   // Returns: PanelPosition[] with x, y, width, height for each panel\n   ```\n   Already implemented - use it.\n\n3. **Create Background Canvas:**\n   ```typescript\n   import sharp from 'sharp';\n\n   let canvas = sharp({\n     create: {\n       width: config.pageWidth,\n       height: config.pageHeight,\n       channels: 4,                    // RGBA\n       background: config.backgroundColor,  // Parsed from hex\n     }\n   });\n   ```\n\n4. **Load & Resize Panel Images:**\n   ```typescript\n   const composites = await Promise.all(\n     panelImagePaths.map(async (imgPath, i) => {\n       if (!fs.existsSync(imgPath)) {\n         throw new Error(`Panel image not found: ${imgPath}`);\n       }\n\n       const position = positions[i];\n       const resized = await sharp(imgPath)\n         .resize(position.width, position.height, {\n           fit: 'cover',              // Fill panel, crop if needed\n           withoutEnlargement: false\n         })\n         .toBuffer();\n\n       return {\n         input: resized,\n         left: position.x,\n         top: position.y\n       };\n     })\n   );\n   ```\n\n5. **Composite Panels Onto Canvas:**\n   ```typescript\n   let result = await canvas.composite(composites).png();\n   ```\n\n6. **Add Borders (Optional - if borderWidth > 0):**\n   - Use SVG overlay to draw rectangles around each panel\n   - Create SVG:\n     ```svg\n     <svg width=\"800\" height=\"1200\">\n       <!-- For each panel position -->\n       <rect x=\"10\" y=\"10\" width=\"390\" height=\"590\"\n             fill=\"none\" stroke=\"black\" stroke-width=\"2\" />\n     </svg>\n     ```\n   - Composite SVG overlay:\n     ```typescript\n     const borderSvg = this.generateBorderSvg(positions, config);\n     result = await result.composite([{\n       input: borderSvg,\n       top: 0,\n       left: 0\n     }]);\n     ```\n\n7. **Return ComposedLayout:**\n   ```typescript\n   const buffer = await result.toBuffer();\n   return {\n     buffer,\n     width: config.pageWidth,\n     height: config.pageHeight,\n     format: 'png',\n     panelPositions: positions\n   };\n   ```\n\n**Method: addSpeechBubbles() - Overlay Speech Bubbles**\n\n```typescript\nasync addSpeechBubbles(\n  layout: ComposedLayout,\n  bubbles: SpeechBubble[]\n): Promise<ComposedLayout>\n```\n\nImplementation:\n\n1. **For each speech bubble:**\n   - Get panel position from layout.panelPositions[bubble.panelIndex]\n   - Calculate bubble position within panel:\n     - 'top'  y = panel.y + 30\n     - 'middle'  y = panel.y + panel.height/2 - 30\n     - 'bottom'  y = panel.y + panel.height - 60\n\n2. **Create SVG speech bubble:**\n   ```typescript\n   const svg = this.generateSpeechBubbleSvg(bubble, position, style);\n   // Generates SVG with text, shape varies by style:\n   // 'rounded', 'cloud', 'spiked', 'rectangular'\n   ```\n\n3. **Composite all bubble SVGs:**\n   ```typescript\n   let result = sharp(layout.buffer);\n   const bubbleSvgs = bubbles.map((bubble, idx) =>\n     this.generateSpeechBubbleSvg(bubble, panelPositions[bubble.panelIndex])\n   );\n\n   result = await result.composite(\n     bubbleSvgs.map((svg, i) => ({ input: svg }))\n   );\n   ```\n\n4. **Return updated ComposedLayout**\n\n**Helper: generateBorderSvg()**\n```typescript\nprivate generateBorderSvg(\n  positions: PanelPosition[],\n  config: LayoutConfig\n): Buffer\n```\n\nGenerate SVG with rectangle borders around each panel:\n```svg\n<svg width=\"800\" height=\"1200\">\n  <rect x=\"10\" y=\"10\" width=\"390\" height=\"590\"\n        fill=\"none\" stroke=\"#000000\" stroke-width=\"2\" />\n  <!-- repeated for each panel -->\n</svg>\n```\n\nConvert to Buffer and return.\n\n**Helper: generateSpeechBubbleSvg()**\n```typescript\nprivate generateSpeechBubbleSvg(\n  bubble: SpeechBubble,\n  panelPosition: PanelPosition,\n  targetY: number  // top/middle/bottom\n): Buffer\n```\n\nGenerate SVG with speech bubble shape. Example for 'rounded':\n```svg\n<svg width=\"300\" height=\"100\">\n  <!-- Rounded rectangle -->\n  <path d=\"M 10,10 Q 10,10 20,10 L 270,10 Q 280,10 280,20 L 280,70 Q 280,80 270,80 L 30,80 Q 20,80 20,70 L 20,40 L 0,60 L 20,50 L 20,20 Q 20,10 10,10\"\n        fill=\"white\" stroke=\"black\" stroke-width=\"1\" />\n  <text x=\"20\" y=\"50\" font-family=\"Arial\" font-size=\"14\">Your text here</text>\n</svg>\n```\n\nReturn SVG as Buffer via:\n```typescript\nconst svgBuffer = Buffer.from(svgString, 'utf-8');\n```\n\n### ExportService (`backend/src/services/exportService.ts`) - NEW FILE\n\nImplement export to PNG, JPG, PDF formats.\n\n```typescript\nexport class ExportService {\n  async exportPNG(\n    layout: ComposedLayout,\n    filepath: string,\n    compression: 'low' | 'medium' | 'high'\n  ): Promise<void>\n\n  async exportJPG(\n    layout: ComposedLayout,\n    filepath: string,\n    quality: number  // 60-95\n  ): Promise<void>\n\n  async exportPDF(\n    layout: ComposedLayout,\n    filepath: string,\n    metadata: { title?: string; author?: string }\n  ): Promise<void>\n}\n```\n\n**exportPNG():**\n```typescript\nasync exportPNG(layout, filepath, compression) {\n  const compressionLevel = compression === 'high' ? 9 : compression === 'medium' ? 6 : 1;\n  await sharp(layout.buffer)\n    .png({ compressionLevel })\n    .toFile(filepath);\n}\n```\n\n**exportJPG():**\n```typescript\nasync exportJPG(layout, filepath, quality = 80) {\n  await sharp(layout.buffer)\n    .jpeg({ quality, mozjpeg: true })\n    .toFile(filepath);\n}\n```\n\n**exportPDF():**\nRequires pdfkit library:\n```typescript\nimport PDFDocument from 'pdfkit';\nimport { createWriteStream } from 'fs';\n\nasync exportPDF(layout, filepath, metadata = {}) {\n  const doc = new PDFDocument({\n    size: [layout.width, layout.height]\n  });\n\n  if (metadata.title) doc.title(metadata.title);\n  if (metadata.author) doc.author(metadata.author);\n\n  // Add image to PDF\n  doc.image(layout.buffer, 0, 0, {\n    width: layout.width,\n    height: layout.height\n  });\n\n  doc.pipe(createWriteStream(filepath));\n  doc.end();\n}\n```\n\n### Route Handler Integration\n\nImplement in `backend/src/routes/manga.ts`:\n\n**POST /api/manga/:projectId/layout**\n```typescript\nrouter.post('/:projectId/layout', async (req: Request, res: Response, next: NextFunction) => {\n  try {\n    const { projectId } = req.params;\n    const { speechBubbles } = req.body as GenerateLayoutRequest;\n\n    // Fetch project and panels from DB\n    const project = await getProject(projectId);\n    if (!project) throw new NotFoundError('Project');\n\n    // Get panel image paths\n    const panelPaths = project.panels\n      .sort((a, b) => a.panelIndex - b.panelIndex)\n      .map(p => p.imageFilePath)\n      .filter(path => path !== undefined);\n\n    // Compose layout\n    const layoutEngine = new LayoutEngine();\n    let layout = await layoutEngine.composePanels(panelPaths, project.layoutConfig);\n\n    // Add speech bubbles if provided\n    if (speechBubbles && speechBubbles.length > 0) {\n      layout = await layoutEngine.addSpeechBubbles(layout, speechBubbles);\n    }\n\n    // Save layout buffer to temporary file for preview\n    const layoutPath = path.join(CONFIG.STORAGE_PATH, projectId, 'layout.png');\n    await fs.writeFile(layoutPath, layout.buffer);\n\n    // Update project status\n    await updateProject(projectId, { status: 'complete' });\n\n    // Return layout info\n    res.json({\n      message: 'Layout composed successfully',\n      projectId,\n      layoutPath: `/uploads/${projectId}/layout.png`,\n      panelPositions: layout.panelPositions,\n      dimensions: { width: layout.width, height: layout.height }\n    });\n  } catch (err) {\n    next(err);\n  }\n});\n```\n\n**POST /api/manga/:projectId/export**\n```typescript\nrouter.post('/:projectId/export', async (req: Request, res: Response, next: NextFunction) => {\n  try {\n    const { projectId } = req.params;\n    const { format, compression, resolution, title, author } = req.body as ExportRequest;\n\n    // Fetch project layout\n    const layoutPath = path.join(CONFIG.STORAGE_PATH, projectId, 'layout.png');\n    if (!fs.existsSync(layoutPath)) {\n      throw new Error('Layout not yet generated. Call /layout endpoint first.');\n    }\n\n    const layoutBuffer = await fs.promises.readFile(layoutPath);\n    const layout: ComposedLayout = {\n      buffer: layoutBuffer,\n      width: 800,  // From project.layoutConfig\n      height: 1200,\n      format: 'png',\n      panelPositions: []  // Could fetch from DB if needed\n    };\n\n    // Export to requested format\n    const exportService = new ExportService();\n    const timestamp = Date.now();\n    const exportPath = path.join(CONFIG.STORAGE_PATH, projectId, `manga_${timestamp}.${format}`);\n\n    if (format === 'png') {\n      await exportService.exportPNG(layout, exportPath, compression as 'low' | 'medium' | 'high');\n    } else if (format === 'jpg') {\n      const qualityMap = { low: 60, medium: 80, high: 95 };\n      await exportService.exportJPG(layout, exportPath, qualityMap[compression]);\n    } else if (format === 'pdf') {\n      await exportService.exportPDF(layout, exportPath, { title, author });\n    }\n\n    // Update project status\n    await updateProject(projectId, { status: 'exported' });\n\n    res.json({\n      message: 'Export successful',\n      projectId,\n      format,\n      downloadUrl: `/uploads/${projectId}/manga_${timestamp}.${format}`,\n      filePath: exportPath\n    });\n  } catch (err) {\n    next(err);\n  }\n});\n```\n\n### Testing Requirements\n\n```bash\n# 1. Generate layout from Task 3 images\nPROJECT_ID=\"test-project-id\"\ncurl -X POST http://localhost:5000/api/manga/$PROJECT_ID/layout \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\n    \"speechBubbles\": [\n      {\n        \"panelIndex\": 0,\n        \"text\": \"Wow!\",\n        \"position\": \"top\",\n        \"style\": \"rounded\"\n      }\n    ]\n  }'\n\n# 2. View composed layout\nopen http://localhost:5000/uploads/$PROJECT_ID/layout.png\n\n# 3. Export to PNG\ncurl -X POST http://localhost:5000/api/manga/$PROJECT_ID/export \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\n    \"format\": \"png\",\n    \"compression\": \"medium\",\n    \"resolution\": \"web\",\n    \"title\": \"My Manga\"\n  }'\n\n# 4. Export to PDF\ncurl -X POST http://localhost:5000/api/manga/$PROJECT_ID/export \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\n    \"format\": \"pdf\",\n    \"compression\": \"medium\",\n    \"title\": \"My Manga\",\n    \"author\": \"AI Creator\"\n  }'\n\n# 5. Verify files exist\nls -lh uploads/$PROJECT_ID/\n```\n\n### Files This Task Provides to Other Agents\n\n- **Composed layout image** - Used by frontend for preview\n- **Export files** - PNG/JPG/PDF outputs for download\n- **Layout metadata** - Panel positions for debugging/display\n\n### Output Validation Checklist\n\n- [ ] calculateGrid() and calculatePanelPositions() methods work correctly\n- [ ] composePanels() successfully combines images with sharp\n- [ ] Borders render correctly around panels\n- [ ] Speech bubbles overlay without distortion\n- [ ] Multiple speech bubble styles work ('rounded', 'cloud', 'spiked', 'rectangular')\n- [ ] Layout PNG saved and readable\n- [ ] exportPNG() produces valid PNG files\n- [ ] exportJPG() produces valid JPG files with quality control\n- [ ] exportPDF() produces valid PDF with metadata\n- [ ] /layout endpoint returns correct panel positions\n- [ ] /export endpoint returns download URLs\n- [ ] Compression settings affect file size appropriately\n- [ ] No TypeScript compilation errors\n\n---\n\n## Task 5: React (Agent E)\n### Complete React UI with Component Implementation\n\n**Time Estimate:** 60-80 minutes\n**Difficulty:** Intermediate (React component patterns)\n**Dependencies:** Tasks 1-4 (backend API must be running)\n\n### Objective\nComplete all React components for the koma-fill frontend including image upload with drag-drop, story prompt editor, panel grid with drag-and-drop reordering, complete manga generation workflow orchestration, real-time SSE progress updates, and multi-format export options. Configure Tailwind CSS for styling.\n\n### Target Files to Create/Modify\n\n```\nfrontend/\n src/\n    components/\n       ImageUploader.tsx           [IMPLEMENT] Dropzone with position selector\n       StoryPromptEditor.tsx       [ENHANCE] Add sample prompts\n       PanelGrid.tsx               [IMPLEMENT] Drag-and-drop reordering\n       LayoutSelector.tsx          [VERIFY] Layout config UI\n       ExportOptions.tsx           [VERIFY] Export format selection\n       ProgressBar.tsx             [CREATE] Real-time progress display\n    hooks/\n       useMangaGeneration.ts       [IMPLEMENT] Full workflow orchestration\n    services/\n       apiClient.ts                [IMPLEMENT] API client with SSE support\n    pages/\n       CreateMangaPage.tsx         [IMPLEMENT] Main workflow page\n       PreviewPage.tsx             [IMPLEMENT] Result preview & download\n    App.tsx                         [UPDATE] Routing\n    main.tsx                        [VERIFY] Entry point\n    index.css                       [UPDATE] Tailwind directives\n tailwind.config.js                  [CREATE] Tailwind configuration\n postcss.config.js                   [CREATE] PostCSS configuration\n package.json                        [UPDATE] Add Tailwind dependencies\n tsconfig.json                       [VERIFY] TypeScript config\n```\n\n### TypeScript Interfaces (from `frontend/src/types/index.ts`)\n\nAlready defined - reference for component props.\n\n### Implementation Details\n\n#### 1. Tailwind CSS Setup\n\n**Install Dependencies:**\n```bash\ncd frontend\nnpm install -D tailwindcss postcss autoprefixer\nnpx tailwindcss init -p\n```\n\n**tailwind.config.js:**\n```javascript\nexport default {\n  content: [\n    './index.html',\n    './src/**/*.{js,ts,jsx,tsx}',\n  ],\n  theme: {\n    extend: {\n      colors: {\n        manga: {\n          dark: '#1a1a1a',\n          light: '#f5f5f5',\n        }\n      }\n    },\n  },\n  plugins: [],\n}\n```\n\n**postcss.config.js:**\n```javascript\nexport default {\n  plugins: {\n    tailwindcss: {},\n    autoprefixer: {},\n  },\n}\n```\n\n**frontend/src/index.css:**\n```css\n@tailwind base;\n@tailwind components;\n@tailwind utilities;\n\n@layer components {\n  .btn-primary {\n    @apply px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700 transition;\n  }\n  .btn-secondary {\n    @apply px-4 py-2 bg-gray-300 text-gray-800 rounded-lg hover:bg-gray-400 transition;\n  }\n  .input-field {\n    @apply w-full px-3 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500;\n  }\n}\n```\n\n#### 2. API Client (`frontend/src/services/apiClient.ts`)\n\n```typescript\nimport { MangaProject, Panel, GenerationProgress, ProgressEvent } from '../types';\n\nconst API_BASE = import.meta.env.VITE_API_URL || 'http://localhost:5000/api';\n\nexport class APIClient {\n  /**\n   * Create new manga project\n   */\n  async createProject(name: string, storyPrompt: string, layoutConfig?: any) {\n    const response = await fetch(`${API_BASE}/manga/create`, {\n      method: 'POST',\n      headers: { 'Content-Type': 'application/json' },\n      body: JSON.stringify({\n        projectName: name,\n        storyPrompt,\n        layoutConfig\n      })\n    });\n    if (!response.ok) throw new Error(await response.text());\n    return response.json() as Promise<MangaProject>;\n  }\n\n  /**\n   * Upload key images\n   */\n  async uploadImages(projectId: string, files: File[]) {\n    const formData = new FormData();\n    files.forEach(file => formData.append('images', file));\n\n    const response = await fetch(`${API_BASE}/manga/${projectId}/upload`, {\n      method: 'POST',\n      body: formData\n    });\n    if (!response.ok) throw new Error(await response.text());\n    return response.json();\n  }\n\n  /**\n   * Analyze images using Vision API\n   */\n  async analyzeImages(projectId: string, depth: 'quick' | 'detailed' = 'quick') {\n    const response = await fetch(`${API_BASE}/manga/${projectId}/analyze`, {\n      method: 'POST',\n      headers: { 'Content-Type': 'application/json' },\n      body: JSON.stringify({ analysisDepth: depth })\n    });\n    if (!response.ok) throw new Error(await response.text());\n    return response.json();\n  }\n\n  /**\n   * Generate panel prompts\n   */\n  async generatePrompts(projectId: string, storyPrompt: string, panelCount: number) {\n    const response = await fetch(`${API_BASE}/manga/${projectId}/generate-prompts`, {\n      method: 'POST',\n      headers: { 'Content-Type': 'application/json' },\n      body: JSON.stringify({\n        storyPrompt,\n        panelCount,\n        characterConsistency: true\n      })\n    });\n    if (!response.ok) throw new Error(await response.text());\n    return response.json() as Promise<Panel[]>;\n  }\n\n  /**\n   * Generate images via DALL-E 3 (SSE streaming)\n   */\n  streamImageGeneration(\n    projectId: string,\n    batchMode: 'sequential' | 'parallel',\n    onProgress: (event: ProgressEvent) => void,\n    onError: (error: Error) => void\n  ): () => void {\n    const eventSource = new EventSource(\n      `${API_BASE}/manga/${projectId}/generate-images?batchMode=${batchMode}`\n    );\n\n    eventSource.onmessage = (event) => {\n      try {\n        const data = JSON.parse(event.data);\n        onProgress(data);\n      } catch (e) {\n        console.error('Failed to parse SSE message:', e);\n      }\n    };\n\n    eventSource.onerror = () => {\n      onError(new Error('Generation failed or connection lost'));\n      eventSource.close();\n    };\n\n    // Return cleanup function\n    return () => eventSource.close();\n  }\n\n  /**\n   * Compose layout with speech bubbles\n   */\n  async composeLayout(projectId: string, speechBubbles?: any) {\n    const response = await fetch(`${API_BASE}/manga/${projectId}/layout`, {\n      method: 'POST',\n      headers: { 'Content-Type': 'application/json' },\n      body: JSON.stringify({ speechBubbles })\n    });\n    if (!response.ok) throw new Error(await response.text());\n    return response.json();\n  }\n\n  /**\n   * Export to PNG/JPG/PDF\n   */\n  async exportManga(\n    projectId: string,\n    format: 'png' | 'jpg' | 'pdf',\n    compression: 'low' | 'medium' | 'high' = 'medium',\n    title?: string,\n    author?: string\n  ) {\n    const response = await fetch(`${API_BASE}/manga/${projectId}/export`, {\n      method: 'POST',\n      headers: { 'Content-Type': 'application/json' },\n      body: JSON.stringify({\n        format,\n        compression,\n        resolution: 'web',\n        title,\n        author\n      })\n    });\n    if (!response.ok) throw new Error(await response.text());\n    return response.json();\n  }\n\n  /**\n   * Fetch project details\n   */\n  async getProject(projectId: string) {\n    const response = await fetch(`${API_BASE}/manga/${projectId}`);\n    if (!response.ok) throw new Error(await response.text());\n    return response.json() as Promise<MangaProject>;\n  }\n\n  /**\n   * Reorder panels\n   */\n  async reorderPanels(projectId: string, panelOrder: number[]) {\n    const response = await fetch(`${API_BASE}/manga/${projectId}/reorder`, {\n      method: 'PUT',\n      headers: { 'Content-Type': 'application/json' },\n      body: JSON.stringify({ panelOrder })\n    });\n    if (!response.ok) throw new Error(await response.text());\n    return response.json();\n  }\n}\n\nexport const apiClient = new APIClient();\n```\n\n#### 3. useMangaGeneration Hook (`frontend/src/hooks/useMangaGeneration.ts`)\n\n```typescript\nimport { useState, useCallback } from 'react';\nimport { apiClient } from '../services/apiClient';\nimport { MangaProject, GenerationProgress, UploadedImage } from '../types';\n\nexport function useMangaGeneration() {\n  const [project, setProject] = useState<MangaProject | null>(null);\n  const [progress, setProgress] = useState<GenerationProgress>({\n    stage: 'idle',\n    currentStep: 0,\n    totalSteps: 0,\n    percentage: 0,\n    message: ''\n  });\n  const [error, setError] = useState<string | null>(null);\n\n  /**\n   * Complete workflow: Create  Upload  Analyze  Generate Prompts  Generate Images  Layout\n   */\n  const generateManga = useCallback(async (\n    projectName: string,\n    storyPrompt: string,\n    uploadedImages: UploadedImage[],\n    layoutConfig: any,\n    generationSettings: any\n  ) => {\n    try {\n      setError(null);\n\n      // Stage 1: Create project\n      setProgress({\n        stage: 'uploading',\n        currentStep: 0,\n        totalSteps: 5,\n        percentage: 20,\n        message: 'Creating project...'\n      });\n      const newProject = await apiClient.createProject(projectName, storyPrompt, layoutConfig);\n      setProject(newProject);\n\n      // Stage 2: Upload images\n      setProgress({\n        stage: 'uploading',\n        currentStep: 1,\n        totalSteps: 5,\n        percentage: 40,\n        message: 'Uploading reference images...'\n      });\n      const files = uploadedImages.map(img => img.file);\n      await apiClient.uploadImages(newProject.id, files);\n\n      // Stage 3: Analyze images\n      setProgress({\n        stage: 'analyzing',\n        currentStep: 2,\n        totalSteps: 5,\n        percentage: 60,\n        message: 'Analyzing images with Vision API...'\n      });\n      await apiClient.analyzeImages(newProject.id, 'detailed');\n\n      // Stage 4: Generate prompts\n      setProgress({\n        stage: 'generating_prompts',\n        currentStep: 3,\n        totalSteps: 5,\n        percentage: 70,\n        message: 'Generating panel prompts...'\n      });\n      await apiClient.generatePrompts(\n        newProject.id,\n        storyPrompt,\n        layoutConfig.totalPanels\n      );\n\n      // Stage 5: Generate images (with SSE streaming)\n      setProgress({\n        stage: 'generating_images',\n        currentStep: 4,\n        totalSteps: 5,\n        percentage: 75,\n        message: 'Starting image generation...'\n      });\n\n      await new Promise<void>((resolve, reject) => {\n        const cleanup = apiClient.streamImageGeneration(\n          newProject.id,\n          'sequential',  // or 'parallel' based on user preference\n          (progressEvent) => {\n            if (progressEvent.type === 'complete') {\n              setProgress(prev => ({\n                ...prev,\n                percentage: 90,\n                message: 'Image generation complete!'\n              }));\n              resolve();\n            } else if (progressEvent.type === 'error') {\n              reject(new Error(progressEvent.error || 'Generation failed'));\n            } else {\n              setProgress({\n                stage: 'generating_images',\n                currentStep: 4 + (progressEvent.currentStep || 0) * 0.1,\n                totalSteps: 5,\n                percentage: 75 + (progressEvent.percentage || 0) * 0.15,\n                message: progressEvent.message,\n                currentPanelIndex: progressEvent.panelIndex\n              });\n            }\n          },\n          reject\n        );\n      });\n\n      // Stage 6: Compose layout\n      setProgress({\n        stage: 'composing_layout',\n        currentStep: 5,\n        totalSteps: 5,\n        percentage: 95,\n        message: 'Composing final layout...'\n      });\n      await apiClient.composeLayout(newProject.id);\n\n      // Complete\n      const finalProject = await apiClient.getProject(newProject.id);\n      setProject(finalProject);\n      setProgress({\n        stage: 'idle',\n        currentStep: 5,\n        totalSteps: 5,\n        percentage: 100,\n        message: 'Manga generation complete!'\n      });\n\n    } catch (err) {\n      const errorMsg = err instanceof Error ? err.message : 'Unknown error';\n      setError(errorMsg);\n      setProgress({\n        stage: 'idle',\n        currentStep: 0,\n        totalSteps: 0,\n        percentage: 0,\n        message: `Error: ${errorMsg}`\n      });\n    }\n  }, []);\n\n  const exportManga = useCallback(async (\n    projectId: string,\n    format: 'png' | 'jpg' | 'pdf',\n    compression: 'low' | 'medium' | 'high' = 'medium'\n  ) => {\n    try {\n      setError(null);\n      setProgress({\n        stage: 'exporting',\n        currentStep: 0,\n        totalSteps: 1,\n        percentage: 50,\n        message: `Exporting as ${format.toUpperCase()}...`\n      });\n\n      const result = await apiClient.exportManga(projectId, format, compression);\n\n      setProgress({\n        stage: 'idle',\n        currentStep: 1,\n        totalSteps: 1,\n        percentage: 100,\n        message: 'Export complete!'\n      });\n\n      return result;\n    } catch (err) {\n      const errorMsg = err instanceof Error ? err.message : 'Export failed';\n      setError(errorMsg);\n      throw err;\n    }\n  }, []);\n\n  return {\n    project,\n    progress,\n    error,\n    generateManga,\n    exportManga,\n    setError\n  };\n}\n```\n\n#### 4. Components\n\n**ImageUploader.tsx:**\n```typescript\nimport { useCallback, useState } from 'react';\nimport { UploadedImage, ImagePosition } from '../types';\n\ninterface ImageUploaderProps {\n  onImagesSelected: (images: UploadedImage[]) => void;\n}\n\nexport function ImageUploader({ onImagesSelected }: ImageUploaderProps) {\n  const [images, setImages] = useState<UploadedImage[]>([]);\n  const [selectedPosition, setSelectedPosition] = useState<ImagePosition>('start');\n\n  const handleDrop = useCallback((e: React.DragEvent) => {\n    e.preventDefault();\n    const files = Array.from(e.dataTransfer.files).filter(f => f.type.startsWith('image/'));\n    addImages(files);\n  }, []);\n\n  const handleFileInput = (e: React.ChangeEvent<HTMLInputElement>) => {\n    if (e.target.files) {\n      addImages(Array.from(e.target.files));\n    }\n  };\n\n  const addImages = (files: File[]) => {\n    const newImages = files.map(file => ({\n      file,\n      previewUrl: URL.createObjectURL(file),\n      position: selectedPosition\n    }));\n    setImages(prev => [...prev, ...newImages]);\n    onImagesSelected([...images, ...newImages]);\n  };\n\n  const removeImage = (index: number) => {\n    const updated = images.filter((_, i) => i !== index);\n    setImages(updated);\n    onImagesSelected(updated);\n  };\n\n  return (\n    <div className=\"w-full max-w-2xl\">\n      <div\n        onDrop={handleDrop}\n        onDragOver={e => e.preventDefault()}\n        className=\"border-2 border-dashed border-gray-300 rounded-lg p-8 text-center cursor-pointer hover:border-blue-500 transition\"\n      >\n        <p className=\"text-gray-600 mb-4\">Drag and drop images here or click to select</p>\n        <input\n          type=\"file\"\n          multiple\n          accept=\"image/*\"\n          onChange={handleFileInput}\n          className=\"hidden\"\n          id=\"image-input\"\n        />\n        <label htmlFor=\"image-input\" className=\"btn-primary cursor-pointer\">\n          Select Images\n        </label>\n      </div>\n\n      <div className=\"mt-4\">\n        <label className=\"block mb-2\">Position in Story:</label>\n        <select\n          value={selectedPosition}\n          onChange={e => setSelectedPosition(e.target.value as ImagePosition)}\n          className=\"input-field\"\n        >\n          <option value=\"start\">Start (Reference)</option>\n          <option value=\"end\">End (Reference)</option>\n          <option value={1}>Panel 1</option>\n          <option value={2}>Panel 2</option>\n        </select>\n      </div>\n\n      {images.length > 0 && (\n        <div className=\"mt-6 grid grid-cols-2 gap-4\">\n          {images.map((img, idx) => (\n            <div key={idx} className=\"relative\">\n              <img src={img.previewUrl} alt={`Preview ${idx}`} className=\"rounded-lg w-full h-48 object-cover\" />\n              <button\n                onClick={() => removeImage(idx)}\n                className=\"absolute top-2 right-2 bg-red-500 text-white rounded-full w-6 h-6 flex items-center justify-center hover:bg-red-600\"\n              >\n                \n              </button>\n            </div>\n          ))}\n        </div>\n      )}\n    </div>\n  );\n}\n```\n\n**StoryPromptEditor.tsx (Enhanced):**\n```typescript\nimport { useState } from 'react';\n\ninterface StoryPromptEditorProps {\n  value: string;\n  onChange: (value: string) => void;\n}\n\nconst SAMPLE_PROMPTS = [\n  'A young ninja discovers their hidden powers and must save their village from a mysterious threat.',\n  'Two rival chefs compete in a cooking tournament, discovering they have more in common than they thought.',\n  'A time traveler must prevent a catastrophic event by gathering clues from different eras.',\n];\n\nexport function StoryPromptEditor({ value, onChange }: StoryPromptEditorProps) {\n  const [isExpanded, setIsExpanded] = useState(false);\n\n  return (\n    <div className=\"w-full max-w-2xl\">\n      <label className=\"block text-lg font-semibold mb-2\">Your Story Prompt</label>\n\n      <textarea\n        value={value}\n        onChange={e => onChange(e.target.value)}\n        placeholder=\"Write your manga story here. Be descriptive about characters, setting, and plot...\"\n        className=\"input-field h-32 resize-none\"\n      />\n\n      <div className=\"mt-4\">\n        <button\n          onClick={() => setIsExpanded(!isExpanded)}\n          className=\"text-blue-600 hover:underline text-sm\"\n        >\n          {isExpanded ? 'Hide' : 'Show'} Sample Prompts\n        </button>\n\n        {isExpanded && (\n          <div className=\"mt-3 space-y-2\">\n            {SAMPLE_PROMPTS.map((prompt, idx) => (\n              <button\n                key={idx}\n                onClick={() => onChange(prompt)}\n                className=\"block w-full text-left p-3 bg-gray-100 hover:bg-gray-200 rounded-lg text-sm transition\"\n              >\n                {prompt}\n              </button>\n            ))}\n          </div>\n        )}\n      </div>\n    </div>\n  );\n}\n```\n\n**PanelGrid.tsx (with Drag-and-Drop):**\n```typescript\nimport { useState } from 'react';\nimport { Panel } from '../types';\nimport { DndContext, closestCenter, KeyboardSensor, PointerSensor, useSensor, useSensors } from '@dnd-kit/core';\nimport { SortableContext, sortableKeyboardCoordinates, verticalListSortingStrategy, useSortable } from '@dnd-kit/sortable';\nimport { CSS } from '@dnd-kit/utilities';\n\nfunction SortablePanel({ panel }: { panel: Panel }) {\n  const { attributes, listeners, setNodeRef, transform, transition } = useSortable({ id: panel.id });\n  const style = { transform: CSS.Transform.toString(transform), transition };\n\n  return (\n    <div ref={setNodeRef} style={style} {...attributes} {...listeners} className=\"p-4\">\n      <div className=\"bg-white rounded-lg shadow p-4 cursor-grab active:cursor-grabbing\">\n        <img\n          src={panel.imageUrl}\n          alt={`Panel ${panel.panelIndex}`}\n          className=\"w-full h-auto rounded mb-2\"\n        />\n        <p className=\"text-sm text-gray-600\">{panel.storyBeat}</p>\n        <span className={`inline-block mt-2 px-2 py-1 rounded text-xs text-white ${\n          panel.status === 'generated' ? 'bg-green-500' :\n          panel.status === 'pending' ? 'bg-blue-500' :\n          'bg-red-500'\n        }`}>\n          {panel.status}\n        </span>\n      </div>\n    </div>\n  );\n}\n\ninterface PanelGridProps {\n  panels: Panel[];\n  onReorder: (newOrder: Panel[]) => void;\n}\n\nexport function PanelGrid({ panels, onReorder }: PanelGridProps) {\n  const sensors = useSensors(\n    useSensor(PointerSensor),\n    useSensor(KeyboardSensor, { coordinateGetter: sortableKeyboardCoordinates })\n  );\n\n  const handleDragEnd = (event: any) => {\n    const { active, over } = event;\n    if (over && active.id !== over.id) {\n      const oldIndex = panels.findIndex(p => p.id === active.id);\n      const newIndex = panels.findIndex(p => p.id === over.id);\n      const newPanels = [...panels];\n      [newPanels[oldIndex], newPanels[newIndex]] = [newPanels[newIndex], newPanels[oldIndex]];\n      onReorder(newPanels);\n    }\n  };\n\n  return (\n    <DndContext sensors={sensors} collisionDetection={closestCenter} onDragEnd={handleDragEnd}>\n      <SortableContext items={panels.map(p => p.id)} strategy={verticalListSortingStrategy}>\n        <div className=\"grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-4\">\n          {panels.map(panel => (\n            <SortablePanel key={panel.id} panel={panel} />\n          ))}\n        </div>\n      </SortableContext>\n    </DndContext>\n  );\n}\n```\n\n**ProgressBar.tsx:**\n```typescript\nimport { GenerationProgress } from '../types';\n\nexport function ProgressBar({ progress }: { progress: GenerationProgress }) {\n  return (\n    <div className=\"w-full max-w-2xl\">\n      <div className=\"mb-2 flex justify-between\">\n        <span className=\"text-sm font-semibold\">{progress.message}</span>\n        <span className=\"text-sm text-gray-600\">{Math.round(progress.percentage)}%</span>\n      </div>\n      <div className=\"w-full h-3 bg-gray-200 rounded-full overflow-hidden\">\n        <div\n          className=\"h-full bg-blue-600 transition-all duration-300\"\n          style={{ width: `${progress.percentage}%` }}\n        />\n      </div>\n    </div>\n  );\n}\n```\n\n#### 5. Pages\n\n**CreateMangaPage.tsx:**\n```typescript\nimport { useState } from 'react';\nimport { ImageUploader } from '../components/ImageUploader';\nimport { StoryPromptEditor } from '../components/StoryPromptEditor';\nimport { LayoutSelector } from '../components/LayoutSelector';\nimport { ProgressBar } from '../components/ProgressBar';\nimport { useMangaGeneration } from '../hooks/useMangaGeneration';\nimport { UploadedImage, LayoutConfig } from '../types';\n\nexport function CreateMangaPage() {\n  const [projectName, setProjectName] = useState('');\n  const [storyPrompt, setStoryPrompt] = useState('');\n  const [uploadedImages, setUploadedImages] = useState<UploadedImage[]>([]);\n  const [layoutConfig, setLayoutConfig] = useState<LayoutConfig>({\n    totalPanels: 4,\n    format: 'vertical',\n    readingOrder: 'japanese',\n    gutterSize: 10,\n    borderWidth: 2,\n    borderColor: '#000000',\n    backgroundColor: '#FFFFFF',\n    pageWidth: 800,\n    pageHeight: 1200\n  });\n\n  const { progress, error, generateManga } = useMangaGeneration();\n\n  const handleStart = async () => {\n    if (!projectName || !storyPrompt) {\n      alert('Please enter project name and story prompt');\n      return;\n    }\n\n    await generateManga(projectName, storyPrompt, uploadedImages, layoutConfig, {\n      imageStyle: 'manga style',\n      aspectRatio: 'square',\n      qualityLevel: 'standard'\n    });\n  };\n\n  return (\n    <div className=\"min-h-screen bg-gray-50 py-12 px-4\">\n      <div className=\"max-w-4xl mx-auto space-y-8\">\n        <h1 className=\"text-4xl font-bold text-center mb-2\">koma-fill</h1>\n        <p className=\"text-center text-gray-600\">AI-Powered Manga Panel Generator</p>\n\n        {error && <div className=\"bg-red-100 border border-red-400 text-red-700 px-4 py-3 rounded\">{error}</div>}\n\n        {progress.stage === 'idle' ? (\n          <div className=\"space-y-8\">\n            <div className=\"bg-white p-6 rounded-lg shadow\">\n              <label className=\"block text-lg font-semibold mb-2\">Project Name</label>\n              <input\n                type=\"text\"\n                value={projectName}\n                onChange={e => setProjectName(e.target.value)}\n                className=\"input-field\"\n                placeholder=\"My Awesome Manga\"\n              />\n            </div>\n\n            <div className=\"bg-white p-6 rounded-lg shadow\">\n              <StoryPromptEditor value={storyPrompt} onChange={setStoryPrompt} />\n            </div>\n\n            <div className=\"bg-white p-6 rounded-lg shadow\">\n              <ImageUploader onImagesSelected={setUploadedImages} />\n            </div>\n\n            <div className=\"bg-white p-6 rounded-lg shadow\">\n              <LayoutSelector config={layoutConfig} onChange={setLayoutConfig} />\n            </div>\n\n            <button onClick={handleStart} className=\"btn-primary w-full text-lg py-3\">\n              Generate Manga\n            </button>\n          </div>\n        ) : (\n          <div className=\"bg-white p-6 rounded-lg shadow\">\n            <ProgressBar progress={progress} />\n          </div>\n        )}\n      </div>\n    </div>\n  );\n}\n```\n\n**PreviewPage.tsx:**\n```typescript\nimport { useParams, useNavigate } from 'react-router-dom';\nimport { useEffect, useState } from 'react';\nimport { apiClient } from '../services/apiClient';\nimport { PanelGrid } from '../components/PanelGrid';\nimport { ExportOptions } from '../components/ExportOptions';\nimport { MangaProject } from '../types';\n\nexport function PreviewPage() {\n  const { projectId } = useParams<{ projectId: string }>();\n  const navigate = useNavigate();\n  const [project, setProject] = useState<MangaProject | null>(null);\n  const [loading, setLoading] = useState(true);\n\n  useEffect(() => {\n    if (projectId) {\n      apiClient.getProject(projectId).then(setProject).finally(() => setLoading(false));\n    }\n  }, [projectId]);\n\n  if (loading) return <div className=\"flex justify-center py-12\">Loading...</div>;\n  if (!project) return <div className=\"text-center py-12\">Project not found</div>;\n\n  return (\n    <div className=\"min-h-screen bg-gray-50 py-12 px-4\">\n      <div className=\"max-w-6xl mx-auto\">\n        <button onClick={() => navigate('/')} className=\"btn-secondary mb-6\"> Back</button>\n\n        <h1 className=\"text-3xl font-bold mb-2\">{project.name}</h1>\n        <p className=\"text-gray-600 mb-6\">Project Status: {project.status}</p>\n\n        {project.panels.length > 0 && (\n          <div className=\"bg-white p-6 rounded-lg shadow mb-8\">\n            <h2 className=\"text-2xl font-semibold mb-4\">Panels</h2>\n            <PanelGrid panels={project.panels} onReorder={() => {}} />\n          </div>\n        )}\n\n        <div className=\"bg-white p-6 rounded-lg shadow\">\n          <h2 className=\"text-2xl font-semibold mb-4\">Export</h2>\n          <ExportOptions projectId={project.id} />\n        </div>\n      </div>\n    </div>\n  );\n}\n```\n\n#### 6. Update App.tsx\n\n```typescript\nimport { BrowserRouter as Router, Routes, Route, Navigate } from 'react-router-dom';\nimport { CreateMangaPage } from './pages/CreateMangaPage';\nimport { PreviewPage } from './pages/PreviewPage';\nimport './index.css';\n\nexport default function App() {\n  return (\n    <Router>\n      <Routes>\n        <Route path=\"/\" element={<CreateMangaPage />} />\n        <Route path=\"/project/:projectId\" element={<PreviewPage />} />\n        <Route path=\"*\" element={<Navigate to=\"/\" />} />\n      </Routes>\n    </Router>\n  );\n}\n```\n\n### package.json Updates\n\nAdd dependencies:\n```bash\nnpm install -D tailwindcss postcss autoprefixer\nnpm install react-router-dom @dnd-kit/core @dnd-kit/sortable @dnd-kit/utilities\n```\n\n### Testing Requirements\n\n```bash\n# 1. Start backend (from Task 1)\ncd backend && npm run dev\n\n# 2. In another terminal, start frontend\ncd frontend && npm run dev\n\n# 3. Open browser: http://localhost:3000\n\n# 4. Test workflow:\n# - Enter project name and story\n# - Upload reference images\n# - Configure layout\n# - Click \"Generate Manga\"\n# - Watch progress bar\n# - See panel grid with images\n# - Export to PNG/JPG/PDF\n```\n\n### Files This Task Uses from Other Agents\n\n- **API endpoints** from Task 1 (database & routes)\n- **Analysis data** from Task 2 (character consistency)\n- **Generated images** from Task 3 (panel images)\n- **Composed layouts** from Task 4 (final manga)\n\n### Output Validation Checklist\n\n- [ ] Tailwind CSS configured and working\n- [ ] ImageUploader component with drag-drop works\n- [ ] react-dropzone integration functional\n- [ ] StoryPromptEditor displays with sample prompts\n- [ ] Sample prompt insertion works\n- [ ] PanelGrid displays with drag-and-drop reordering\n- [ ] @dnd-kit integration functional\n- [ ] useMangaGeneration hook orchestrates full workflow\n- [ ] SSE progress streaming displays correctly\n- [ ] ProgressBar updates in real-time\n- [ ] apiClient makes correct API calls\n- [ ] All components have TypeScript types\n- [ ] CreateMangaPage workflow complete\n- [ ] PreviewPage shows generated manga\n- [ ] ExportOptions functional (PNG/JPG/PDF)\n- [ ] Routing works (create  preview)\n- [ ] Error handling displays user-friendly messages\n- [ ] npm run dev starts without errors\n- [ ] No TypeScript compilation errors\n\n---\n\n## Integration Testing (After All Tasks Complete)\n\nAfter all 5 agents finish their implementations, run the following integration tests:\n\n```bash\n# 1. Start backend\ncd /mnt/Projects/koma-fill/backend\nnpm install\nnpm run dev\n# Expected: \" koma-fill server running on http://localhost:5000\"\n\n# 2. Start frontend (new terminal)\ncd /mnt/Projects/koma-fill/frontend\nnpm install\nnpm run dev\n# Expected: \"VITE  ready in XXX ms\"\n\n# 3. Complete workflow test\n# Open http://localhost:3000 in browser\n# - Create project\n# - Upload 2 reference images\n# - Enter story prompt\n# - Select layout (4 panels)\n# - Click \"Generate Manga\"\n# - Wait for completion\n# - View generated panels\n# - Export to PNG\n# - Verify PNG file created in uploads/\n\n# 4. Verify database\nsqlite3 /mnt/Projects/koma-fill/data/koma-fill.db\n> SELECT COUNT(*) FROM projects;\n> SELECT COUNT(*) FROM panels;\n> SELECT COUNT(*) FROM keyImages;\n\n# 5. Check file structure\nls -la /mnt/Projects/koma-fill/uploads/\nls -la /mnt/Projects/koma-fill/data/\n\n# 6. API health check\ncurl http://localhost:5000/api/health\n# Expected: {\"status\":\"ok\",\"timestamp\":\"...\"}\n```\n\n### Known Integration Points to Verify\n\n- Task 1  Task 2: Panel prompts saved in DB, readable by frontend\n- Task 2  Task 3: Vision analysis influences character consistency in prompts\n- Task 3  Task 4: Generated images saved to disk, paths in database\n- Task 4  Task 5: Layout images served via `/uploads/` static directory\n- Task 5  All: Frontend calls all backend API endpoints successfully\n\n---\n\n## Success Criteria Summary\n\nAll 5 tasks completed when:\n\n1. **Backend (Task 1)**: Express server with SQLite database, all CRUD routes working\n2. **Vision & Prompts (Task 2)**: OpenAI Vision API analyzes images, GPT-4o generates DALL-E prompts\n3. **Image Generation (Task 3)**: DALL-E 3 generates 4+ images with retry logic, SSE progress works\n4. **Layout & Export (Task 4)**: Sharp composes panels into manga layout, exports PNG/JPG/PDF\n5. **Frontend (Task 5)**: React UI allows workflow from story  generated manga  export\n\n**Total Expected Time**: 4-5 hours per agent (can run in parallel)\n**Minimum Test Time**: 30 minutes for integration testing\n\nGood luck, KAMUI agents! \n\n---\n\n*Last Updated: 2025-02-12*\n*For issues or questions, refer to the specific task prompts above*",
        "tooltip": ": ClaudeCode3: # KAMUI-4D Parallel Task Prompts for koma-fill\n## Manga Generation AI System - Multi-Agent Implementation Guide\n\n**Version:** 1.0\n**Project:** koma-fill - AI-powered manga panel generation system\n**Target:** KAMUI-4D Editor (Multi-AI CLI parallel execution)\n\n---\n\n## How to Use These Prompts in KAMUI-4D\n\nThis document contains **5 independent task prompts** designed to run in parallel across multiple AI coding agents. Each prompt is self-contained and can be executed independently without blocking other tasks.\n\n### Setup Instructions\n\n1. **Install dependencies** (run once before starting tasks):\n   ```bash\n   cd /mnt/Projects/koma-fill/backend\n   npm install\n\n   cd /mnt/Projects/koma-fill/frontend\n   npm install\n   ```\n\n2. **Environment Configuration**:\n   Create `/mnt/Projects/koma-fill/.env`:\n   ```\n   NODE_ENV=development\n   PORT=5000\n   BASE_URL=http://localhost:5000\n   OPENAI_API_KEY=your_openai_api_key_here\n   OPENAI_ORG_ID=your_org_id_optional\n   DATABASE_PATH=./data/koma-fill.db\n   STORAGE_PATH=./uploads\n   MAX_IMAGE_SIZE_MB=20\n   DALLE_RATE_LIMIT_PER_MINUTE=5\n   VISION_RATE_LIMIT_PER_MINUTE=30\n   MAX_RETRIES_PER_PANEL=3\n   ALLOWED_ORIGINS=http://localhost:3000\n   ```\n\n3. **Execution Strategy**:\n   - Copy each task prompt below into a separate KAMUI-4D session/agent\n   - **Tasks 1-5 can ALL start simultaneously** (no blocking dependencies)\n   - Each task should run independently in its own AI CLI session\n   - Monitor each agent's progress via console output\n   - **Integration testing** should happen after all 5 tasks complete (see bottom of doc)\n\n4. **Task Dependencies**:\n   ```\n   Task 1 (Backend)  provides database & API contracts\n   Task 2 (Vision)  uses Task 1's API, reads backend/src/models/types.ts\n   Task 3 (Images)  uses Task 1's API, reads backend/src/models/types.ts\n   Task 4 (Layout)  uses Task 1's API, reads backend/src/models/types.ts\n   Task 5 (Frontend)  calls Tasks 1-4 via REST API\n   ```\n   **All tasks can start immediately** - they communicate via file system and API contracts.\n\n---\n\n## Task 1: Backend (Agent A)\n### Express Server, SQLite Database & CRUD Routes Foundation\n\n**Time Estimate:** 45-60 minutes\n**Difficulty:** Intermediate\n**Dependencies:** None (this is the foundation layer)\n\n### Objective\nSet up a fully functional Express.js backend with SQLite database, implement CRUD operations for manga projects and panels, configure file upload handling with multer, and provide a solid API foundation for other agents to build upon.\n\n### Target Files to Create/Modify\n\n```\nbackend/\n src/\n    database/\n       connection.ts          [NEW] SQLite connection & initialization\n       schema.ts              [NEW] Table schema definitions\n    index.ts                   [MODIFY] Add DB initialization\n    app.ts                     [COMPLETE] Already done - verify middleware\n    routes/\n       manga.ts               [IMPLEMENT] Route handlers with DB calls\n    middleware/\n        errorHandler.ts        [VERIFY] Already complete\n uploads/                        [CREATE] Directory for image storage\n data/                           [CREATE] Directory for SQLite DB\n```\n\n### TypeScript Interfaces (from `/mnt/Projects/koma-fill/backend/src/models/types.ts`)\n\nKey types you'll use:\n```typescript\n// Core entities\nMangaProject {\n  id: string;                    // UUID\n  name: string;\n  description?: string;\n  status: ProjectStatus;         // 'draft' | 'analyzing' | 'generating' | 'complete' | 'exported'\n  layoutConfig: LayoutConfig;\n  generationSettings: GenerationSettings;\n  panels: Panel[];\n  keyImages: KeyImage[];\n  totalCost: number;\n  createdAt: string;             // ISO datetime\n  updatedAt: string;\n}\n\nPanel {\n  id: string;                    // UUID\n  projectId: string;\n  panelIndex: number;            // 0-based\n  imageUrl?: string;\n  imageFilePath?: string;\n  prompt?: string;\n  storyBeat?: string;\n  speechBubbleText?: string;\n  status: PanelStatus;           // 'pending' | 'generated' | 'failed' | 'placeholder'\n  retryCount: number;\n  generatedAt?: string;\n  createdAt: string;\n}\n\nKeyImage {\n  id: string;                    // UUID\n  projectId: string;\n  imageFilePath: string;\n  position: ImagePosition;       // 'start' | 'end' | number\n  analysis?: ImageAnalysis;\n  createdAt: string;\n}\n\nLayoutConfig {\n  totalPanels: number;           // 4, 6, 8, etc.\n  format: LayoutFormat;          // 'vertical' | 'horizontal' | 'square'\n  readingOrder: ReadingOrder;    // 'japanese' | 'western'\n  gutterSize: number;            // px\n  borderWidth: number;           // px\n  borderColor: string;           // hex #RRGGBB\n  backgroundColor: string;       // hex\n  pageWidth: number;             // px\n  pageHeight: number;            // px\n}\n\nGenerationSettings {\n  imageStyle: string;            // e.g., \"manga style, black and white ink\"\n  aspectRatio: 'square' | 'wide' | 'tall';\n  qualityLevel: 'standard' | 'hd';\n  negativePrompt?: string;\n  seed?: number;\n}\n```\n\n### Implementation Checklist\n\n#### 1. Create Database Connection Module (`backend/src/database/connection.ts`)\n```typescript\n// Requirements:\n- Initialize better-sqlite3 connection\n- Create/open database at DATABASE_PATH from .env\n- Export initDatabase() async function\n- Enable foreign keys constraint\n- Handle database file creation if needed\n- Connection should be cached/singleton\n```\n\n#### 2. Create Database Schema Module (`backend/src/database/schema.ts`)\n```typescript\n// SQL Schema Requirements:\nCREATE TABLE projects (\n  id TEXT PRIMARY KEY,\n  name TEXT NOT NULL,\n  description TEXT,\n  status TEXT NOT NULL,\n  layoutConfig JSON NOT NULL,\n  generationSettings JSON NOT NULL,\n  totalCost REAL DEFAULT 0,\n  createdAt TEXT NOT NULL,\n  updatedAt TEXT NOT NULL\n);\n\nCREATE TABLE panels (\n  id TEXT PRIMARY KEY,\n  projectId TEXT NOT NULL,\n  panelIndex INTEGER NOT NULL,\n  imageUrl TEXT,\n  imageFilePath TEXT,\n  prompt TEXT,\n  storyBeat TEXT,\n  speechBubbleText TEXT,\n  status TEXT NOT NULL,\n  retryCount INTEGER DEFAULT 0,\n  generatedAt TEXT,\n  createdAt TEXT NOT NULL,\n  FOREIGN KEY (projectId) REFERENCES projects(id)\n);\n\nCREATE TABLE keyImages (\n  id TEXT PRIMARY KEY,\n  projectId TEXT NOT NULL,\n  imageFilePath TEXT NOT NULL,\n  position TEXT NOT NULL,\n  analysis JSON,\n  createdAt TEXT NOT NULL,\n  FOREIGN KEY (projectId) REFERENCES projects(id)\n);\n\nCREATE INDEX idx_project_status ON projects(status);\nCREATE INDEX idx_panel_project ON panels(projectId);\nCREATE INDEX idx_panel_status ON panels(status);\n```\n\n#### 3. Modify `backend/src/index.ts`\n```typescript\n// Add:\n- Import { initDatabase } from './database/connection'\n- Call await initDatabase() before app.listen()\n- Log database initialization success\n```\n\n#### 4. Create Repository Layer (`backend/src/repositories/`)\n```typescript\n// Create:\n- ProjectRepository with methods:\n  - createProject(data: CreateMangaRequest): Promise<MangaProject>\n  - getProject(id: string): Promise<MangaProject | null>\n  - listProjects(limit: number, offset: number): Promise<MangaProject[]>\n  - updateProject(id: string, updates: Partial<MangaProject>): Promise<MangaProject>\n  - deleteProject(id: string): Promise<void>\n\n- PanelRepository with methods:\n  - createPanel(projectId: string, data: Panel): Promise<Panel>\n  - getPanelsByProject(projectId: string): Promise<Panel[]>\n  - getPanel(panelId: string): Promise<Panel | null>\n  - updatePanel(panelId: string, updates: Partial<Panel>): Promise<Panel>\n  - updatePanelStatus(panelId: string, status: PanelStatus): Promise<void>\n\n- KeyImageRepository with methods:\n  - createKeyImage(projectId: string, data: KeyImage): Promise<KeyImage>\n  - getKeyImages(projectId: string): Promise<KeyImage[]>\n  - updateKeyImageAnalysis(imageId: string, analysis: ImageAnalysis): Promise<void>\n```\n\n#### 5. Implement Routes in `backend/src/routes/manga.ts`\nReplace TODO comments with actual implementations:\n\n- **POST /api/manga/create**\n  - Validate CreateMangaRequest using Joi\n  - Generate unique project ID (uuid)\n  - Create project in database with 'draft' status\n  - Create initial panel records (count = layoutConfig.totalPanels)\n  - Return created MangaProject with 201 status\n\n- **POST /api/manga/:projectId/upload**\n  - Files already handled by multer middleware\n  - Save KeyImage records to database with file paths\n  - Store position information\n  - Return array of KeyImage objects\n\n- **GET /api/manga/:projectId**\n  - Fetch project + panels + key images from database\n  - Return complete MangaProject object\n  - Throw NotFoundError if project doesn't exist\n\n- **GET /api/manga**\n  - Implement pagination (limit/offset query params)\n  - Return array of projects\n  - Include total count header\n\n- **PUT /api/manga/:projectId/reorder**\n  - Parse ReorderPanelsRequest body\n  - Update panelIndex for each panel based on new order\n  - Return updated panels array\n\n### Testing Requirements\n\nAfter implementation, verify:\n\n```bash\n# 1. Database initialization\nnpm run dev\n# Check console: \" configured\" for database\n\n# 2. Create project\ncurl -X POST http://localhost:5000/api/manga/create \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\n    \"projectName\": \"Test Manga\",\n    \"storyPrompt\": \"A hero on a quest\",\n    \"layoutConfig\": { \"totalPanels\": 4 }\n  }'\n\n# 3. Get project\ncurl http://localhost:5000/api/manga/{projectId}\n\n# 4. Upload images\ncurl -X POST http://localhost:5000/api/manga/{projectId}/upload \\\n  -F \"images=@test1.jpg\" \\\n  -F \"images=@test2.jpg\"\n\n# 5. Check database\nsqlite3 data/koma-fill.db \"SELECT * FROM projects; SELECT * FROM panels;\"\n```\n\n### Files This Task Provides to Other Agents\n\n- **Database schema** - Tasks 2, 3, 4, 5 will read/write to these tables\n- **API contracts** - manga.ts route signatures that Tasks 2-4 will call\n- **File storage structure** - uploads/ directory path that Task 3 will use\n- **Type definitions** - already in backend/src/models/types.ts (reference only)\n\n### Output Validation Checklist\n\n- [ ] Database file created at `data/koma-fill.db`\n- [ ] All 3 tables created with correct schema\n- [ ] Repositories implement CRUD operations\n- [ ] All route handlers work without TODO comments\n- [ ] multer uploads save files to `uploads/` directory\n- [ ] POST /create returns 201 with MangaProject object\n- [ ] GET /:projectId returns full project with panels\n- [ ] Error handler catches and responds appropriately\n- [ ] No TypeScript compilation errors\n- [ ] npm run dev starts without errors\n\n---\n\n## Task 2: + (Agent B)\n### Vision API Integration & DALL-E Prompt Generation\n\n**Time Estimate:** 50-60 minutes\n**Difficulty:** Intermediate\n**Dependencies:** Task 1 (needs database & API routes available)\n\n### Objective\nImplement OpenAI Vision API integration to analyze uploaded key images and extract character/style information. Then implement story-to-panel prompt generation using GPT-4o to create DALL-E 3 compatible prompts that maintain consistency across panels.\n\n### Target Files to Create/Modify\n\n```\nbackend/\n src/\n     services/\n         imageAnalysisService.ts      [IMPLEMENT] Vision API analysis\n         promptGenerationService.ts   [CREATE] Story  panel prompts\n```\n\n### System Prompts (Already Provided)\n\nBoth vision analysis prompts are defined in `imageAnalysisService.ts`:\n- `QUICK_ANALYSIS_PROMPT` - fast, ~500 tokens\n- `DETAILED_ANALYSIS_PROMPT` - thorough, ~2000 tokens\n\nThese guide the Vision API to return structured JSON matching the `ImageAnalysis` interface.\n\n### TypeScript Interfaces\n\n```typescript\n// Input: Key image file path (from Task 1)\n// Output: ImageAnalysis object\n\nImageAnalysis {\n  description: string;\n  characters: CharacterInfo[];\n  objects: string[];\n  colors: string[];\n  composition: string;\n  mood: string;\n  artStyle: string;\n  suggestedTransitions: string[];\n}\n\nCharacterInfo {\n  name?: string;\n  appearance: string;        // detailed physical description\n  emotion: string;\n  position: string;          // screen position (e.g., \"center-left\")\n}\n\n// Panel prompt generation\nPanelPrompt {\n  panelIndex: number;\n  dallePrompt: string;       // Full DALL-E 3 prompt (100-300 words)\n  storyBeat: string;         // What happens in this panel\n  visualFocus: string;       // Main visual element\n  transitionType: TransitionType;  // 'cut' | 'pan' | 'zoom_in' | 'zoom_out' | 'fade' | 'action'\n  suggestedDialogue?: string;\n}\n```\n\n### Implementation Details\n\n#### ImageAnalysisService (`backend/src/services/imageAnalysisService.ts`)\n\n**Constructor:**\n```typescript\nconstructor() {\n  this.openai = new OpenAI({\n    apiKey: CONFIG.OPENAI_API_KEY,\n    organization: CONFIG.OPENAI_ORG_ID\n  });\n}\n```\n\n**Method: analyzeImage(imageBase64: string, depth: 'quick' | 'detailed')**\n- Input: Base64-encoded image data from KeyImage file\n- Implementation:\n  1. Read image file and convert to Base64 (if not already)\n  2. Call `this.openai.chat.completions.create()`:\n     - model: CONFIG.VISION_MODEL ('gpt-4o')\n     - messages: [\n       { role: 'system', content: QUICK_ANALYSIS_PROMPT or DETAILED_ANALYSIS_PROMPT }\n       { role: 'user', content: [\n         { type: 'image_url', image_url: { url: `data:image/png;base64,${imageBase64}` } }\n       ]}\n     ]\n     - response_format: { type: 'json_object' }\n     - max_tokens: depth === 'quick' ? 500 : 2000\n  3. Parse response.choices[0].message.content as JSON\n  4. Validate against ImageAnalysis schema\n  5. Return ImageAnalysis object\n\n**Method: analyzeMultiple(images, depth)**\n- Input: Array of { base64, position } objects\n- Use Promise.all with rate limiting (max CONFIG.VISION_RATE_LIMIT_PER_MINUTE calls/min)\n- Implement backoff if rate limited\n- Return array of ImageAnalysis objects\n\n**Method: extractCharacters(analysis)**\n- Optional: Deep-dive character extraction\n- Can call another Vision API pass if needed for more detail\n\n#### PromptGenerationService (NEW FILE - `backend/src/services/promptGenerationService.ts`)\n\n**Constructor:**\n```typescript\nconstructor() {\n  this.openai = new OpenAI({ apiKey: CONFIG.OPENAI_API_KEY });\n}\n```\n\n**Method: generatePanelPrompts(request: GeneratePromptsRequest)**\n\nInput:\n```typescript\nGeneratePromptsRequest {\n  storyPrompt: string;           // User's story\n  panelCount: number;            // Total panels to generate\n  characterConsistency: boolean; // Whether to maintain character consistency\n}\n```\n\nImplementation:\n1. **Story Breakdown Phase:**\n   - Call GPT-4o to split story into N panel beats\n   - System prompt should guide structure like:\n   ```\n   \"You are a manga story expert. Break the provided story into exactly {panelCount}\n    distinct visual beats. Each beat should be 1-2 sentences describing what happens\n    visually in that panel. Format as JSON array of objects with 'panelIndex' and 'beat' fields.\"\n   ```\n\n2. **Character Consistency Analysis:**\n   - If characterConsistency=true and keyImages were analyzed:\n     - Retrieve stored ImageAnalysis for key images\n     - Create character consistency profile (appearance, emotion arcs, etc.)\n     - Include in subsequent prompts\n\n3. **DALL-E 3 Prompt Generation:**\n   - For each story beat, create detailed DALL-E 3 prompt\n   - System prompt pattern:\n   ```\n   \"You are a DALL-E 3 prompt expert specializing in manga panels.\n    Given a story beat, generate a detailed visual prompt (100-300 words) that:\n    - Specifies art style: {generationSettings.imageStyle}\n    - Maintains character consistency: {characterProfile}\n    - Follows manga composition principles\n    - Uses specific visual terms (angle, lighting, pose, emotion)\n    - Avoids abstract concepts; be concrete and visual\n    - Follows DALL-E 3 content policy\n\n    Return JSON with: { dallePrompt, visualFocus, transitionType, suggestedDialogue }\"\n   ```\n\n4. **Transition Logic:**\n   - Analyze flow between consecutive beats\n   - Suggest transition type ('cut', 'pan', 'zoom_in', etc.)\n   - Update imageUrl in previous panel to support transitions\n\n5. **Return Value:**\n   - Array of PanelPrompt objects, one per panel\n   - Each with populated dallePrompt, storyBeat, visualFocus, transitionType\n\n### Database Integration\n\nAfter generating prompts, save to Panel table:\n- Update each panel's `prompt` field with `dallePrompt`\n- Update `storyBeat` field\n- Update `status` to 'pending' (ready for image generation)\n\n### API Integration\n\nImplement route handlers in `backend/src/routes/manga.ts`:\n\n**POST /api/manga/:projectId/analyze**\n```typescript\n// 1. Fetch project and keyImages from DB\n// 2. Read image files and convert to Base64\n// 3. Call imageAnalysisService.analyzeMultiple()\n// 4. Store analysis results in DB (keyImages.analysis)\n// 5. Update project status to 'analyzing'  'complete'\n// 6. Return analysis results\n```\n\n**POST /api/manga/:projectId/generate-prompts**\n```typescript\n// 1. Validate GeneratePromptsRequest\n// 2. Fetch project and keyImages analyses from DB\n// 3. Call promptGenerationService.generatePanelPrompts()\n// 4. Update panel records with generated prompts\n// 5. Update project status to 'generating'\n// 6. Return array of PanelPrompt objects\n```\n\n### Testing Requirements\n\n```bash\n# 1. Prepare test image\n# (Use any PNG/JPG with a character or scene)\n\n# 2. Create project and upload image (Task 1)\nPROJECT_ID=$(curl -s -X POST http://localhost:5000/api/manga/create \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"projectName\":\"Test\",\"storyPrompt\":\"A hero finds treasure\"}' | jq -r '.id')\n\n# 3. Upload test image\ncurl -X POST http://localhost:5000/api/manga/$PROJECT_ID/upload \\\n  -F \"images=@test_image.jpg\"\n\n# 4. Analyze images\ncurl -X POST http://localhost:5000/api/manga/$PROJECT_ID/analyze \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"analysisDepth\":\"quick\"}'\n\n# 5. Generate prompts\ncurl -X POST http://localhost:5000/api/manga/$PROJECT_ID/generate-prompts \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\n    \"storyPrompt\": \"A hero finds treasure in a dark cave\",\n    \"panelCount\": 4,\n    \"characterConsistency\": true\n  }'\n\n# 6. Verify output\ncurl http://localhost:5000/api/manga/$PROJECT_ID | jq '.panels[].prompt'\n```\n\n### Files This Task Provides to Other Agents\n\n- **Panel prompt data** - Stored in DB panels table, used by Task 3 for image generation\n- **Character analysis** - Used by Task 5 frontend for display\n- **Art style consistency** - Guides Task 3's image generation\n\n### Output Validation Checklist\n\n- [ ] ImageAnalysisService.analyzeImage() calls Vision API successfully\n- [ ] Vision API responses parse correctly to ImageAnalysis\n- [ ] PromptGenerationService generates DALL-E-compatible prompts\n- [ ] Panel prompts maintain character consistency (if enabled)\n- [ ] Transition types are correctly assigned\n- [ ] All panel records updated in database with prompts\n- [ ] /analyze endpoint returns ImageAnalysis array\n- [ ] /generate-prompts endpoint returns PanelPrompt array\n- [ ] Error handling for API failures (rate limits, auth, etc.)\n- [ ] No TypeScript compilation errors\n\n---\n\n## Task 3: DALL-E 3 (Agent C)\n### Image Generation with Retry Logic & Progress Streaming\n\n**Time Estimate:** 50-70 minutes\n**Difficulty:** Intermediate-Advanced\n**Dependencies:** Task 1 (DB & API), Task 2 (panel prompts)\n\n### Objective\nImplement DALL-E 3 image generation with robust error handling, exponential backoff retry logic, local image storage, Server-Sent Events (SSE) streaming for real-time progress updates, and cost tracking per API call.\n\n### Target Files to Create/Modify\n\n```\nbackend/\n src/\n     services/\n         imageGenerationService.ts    [IMPLEMENT] DALL-E 3 API integration\n         (imageProcessor.ts)          [REFERENCE] Utility for image processing\n```\n\n### TypeScript Interfaces\n\n```typescript\nGeneratedPanel {\n  panelIndex: number;\n  imageUrl: string;              // DALL-E public URL (temporary)\n  localFilePath: string;         // /uploads/{projectId}/panel_{index}.png\n  prompt: string;                // Original prompt sent\n  revisedPrompt?: string;        // DALL-E 3's revised prompt (if modified)\n  costUsd: number;               // API call cost\n}\n\n// Request type\nGenerateImagesRequest {\n  panelIndices?: number[];       // undefined = all panels\n  batchMode: 'sequential' | 'parallel';\n}\n\n// Progress event (sent via SSE)\nProgressEvent {\n  type: 'progress' | 'complete' | 'error';\n  stage: string;                 // 'generating_images'\n  currentStep: number;           // Current panel index\n  totalSteps: number;            // Total panels\n  percentage: number;            // 0-100\n  message: string;               // Human-readable status\n  panelId?: string;\n  panelIndex?: number;\n  error?: string;                // Error message if type='error'\n}\n```\n\n### Implementation Details\n\n#### ImageGenerationService (`backend/src/services/imageGenerationService.ts`)\n\n**Constructor & Initialization:**\n```typescript\nconstructor() {\n  this.openai = new OpenAI({ apiKey: CONFIG.OPENAI_API_KEY });\n  this.uploadDir = path.resolve(CONFIG.STORAGE_PATH);\n}\n```\n\n**Method: generatePanel() - Single Panel Generation**\n\n```typescript\nasync generatePanel(\n  prompt: string,\n  panelIndex: number,\n  projectId: string,\n  settings?: GenerationSettings\n): Promise<GeneratedPanel>\n```\n\nImplementation:\n1. **Image Size Calculation:**\n   - Map aspectRatio to DALL-E 3 size:\n     - 'square'  '1024x1024'\n     - 'wide'  '1792x1024'\n     - 'tall'  '1024x1792'\n\n2. **API Call (with retry logic in wrapper):**\n   ```typescript\n   const response = await this.openai.images.generate({\n     model: CONFIG.DALLE_MODEL,           // 'dall-e-3'\n     prompt: prompt,\n     n: 1,\n     size: size,\n     quality: settings?.qualityLevel === 'hd' ? 'hd' : 'standard',\n     style: 'natural',                    // or 'vivid' for more dramatic\n   });\n   ```\n\n3. **Extract Response Data:**\n   - imageUrl = response.data[0].url\n   - revisedPrompt = response.data[0].revised_prompt\n   - Calculate cost based on settings.qualityLevel:\n     - standard: $0.040 per image\n     - hd: $0.080 per image\n\n4. **Download & Save Image:**\n   - Call this.downloadAndSave(imageUrl, projectId, panelIndex)\n   - Saves as PNG: `{STORAGE_PATH}/{projectId}/panel_{panelIndex}.png`\n   - Returns localFilePath\n\n5. **Return GeneratedPanel object**\n\n**Method: generateBatch() - Batch Generation with Mode Selection**\n\n```typescript\nasync generateBatch(\n  panelPrompts: PanelPrompt[],\n  projectId: string,\n  batchMode: 'sequential' | 'parallel',\n  settings?: GenerationSettings,\n  onProgress?: (event: ProgressEvent) => void\n): Promise<GeneratedPanel[]>\n```\n\nImplementation:\n1. Validate inputs\n2. Route to sequential or parallel handler\n3. Call onProgress callback with progress events\n4. Return array of GeneratedPanel\n\n**Method: generateSequential() - Rate-Limit Friendly**\n\n```typescript\nprivate async generateSequential(\n  panelPrompts: PanelPrompt[],\n  projectId: string,\n  settings?: GenerationSettings,\n  onProgress?: (event: ProgressEvent) => void\n): Promise<GeneratedPanel[]>\n```\n\nImplementation:\n1. Initialize results array\n2. For each panelPrompt (with index):\n   a. Call generatePanelWithRetry(panelPrompt, projectId, settings)\n   b. On success:\n      - Add to results array\n      - Call onProgress with percentage = (index + 1) / total * 100\n   c. On failure (after max retries):\n      - Update panel status to 'failed' in DB\n      - Log error\n      - Continue to next panel\n\n3. Return results array (may include failed panels with status='failed')\n\n**Method: generateParallel() - High Speed (Rate Limit Aware)**\n\n```typescript\nprivate async generateParallel(\n  panelPrompts: PanelPrompt[],\n  projectId: string,\n  settings?: GenerationSettings,\n  onProgress?: (event: ProgressEvent) => void\n): Promise<GeneratedPanel[]>\n```\n\nImplementation:\n1. **Batch Control:**\n   - Max concurrent = Math.floor(CONFIG.DALLE_RATE_LIMIT_PER_MINUTE / 2)\n   - Split panelPrompts into batches of max concurrent\n\n2. **For each batch:**\n   - Create Promise.allSettled() for batch\n   - Wait for all to settle\n   - Process results\n   - Send progress update to onProgress\n   - Delay before next batch (respect rate limits)\n\n3. **Failure Handling:**\n   - Collect failed panels\n   - Retry failed panels sequentially (exponential backoff)\n   - Update onProgress for retries\n\n4. **Return results array**\n\n**Method: generatePanelWithRetry() - Core Retry Logic**\n\n```typescript\nprivate async generatePanelWithRetry(\n  panelPrompt: PanelPrompt,\n  projectId: string,\n  settings?: GenerationSettings,\n  retryCount: number = 0\n): Promise<GeneratedPanel>\n```\n\nImplementation:\n1. Try to generate panel via generatePanel()\n2. On success: Return GeneratedPanel\n3. On failure:\n   - If retryCount < CONFIG.MAX_RETRIES_PER_PANEL:\n     - Calculate backoff delay: 2^retryCount * 1000ms (exponential)\n     - Wait for delay\n     - Recursively call with retryCount++\n   - If max retries exceeded:\n     - Throw error with panel index info\n\n**Exponential Backoff Formula:**\n```\ndelay(attempt) = base_delay * (2 ^ attempt) + random jitter\ndelay(0) = 1000ms (1 second)\ndelay(1) = 2000ms (2 seconds)\ndelay(2) = 4000ms (4 seconds)\n+ add random(0, 500ms) jitter to avoid thundering herd\n```\n\n**Method: downloadAndSave() - Store Images Locally**\n\n```typescript\nprivate async downloadAndSave(\n  imageUrl: string,\n  projectId: string,\n  panelIndex: number\n): Promise<string>\n```\n\nImplementation:\n1. Create project uploads directory if not exists: `{STORAGE_PATH}/{projectId}/`\n2. Fetch image from URL using axios or native fetch:\n   ```typescript\n   const response = await fetch(imageUrl);\n   const arrayBuffer = await response.arrayBuffer();\n   const buffer = Buffer.from(arrayBuffer);\n   ```\n3. Save to disk:\n   ```typescript\n   const filePath = path.join(this.uploadDir, projectId, `panel_${panelIndex}.png`);\n   await fs.writeFile(filePath, buffer);\n   ```\n4. Return relative or absolute path\n\n**Method: getImageSize() - Aspect Ratio to DALL-E Size**\n\n```typescript\nprivate getImageSize(\n  aspectRatio: string\n): '1024x1024' | '1792x1024' | '1024x1792'\n```\n\nSelf-explanatory mapping function.\n\n### Route Handler Integration\n\nImplement in `backend/src/routes/manga.ts`:\n\n**POST /api/manga/:projectId/generate-images - SSE Streaming**\n\n```typescript\nrouter.post('/:projectId/generate-images', async (req, res, next) => {\n  try {\n    const { projectId } = req.params;\n    const { panelIndices, batchMode } = req.body as GenerateImagesRequest;\n\n    // Set up SSE response\n    res.setHeader('Content-Type', 'text/event-stream');\n    res.setHeader('Cache-Control', 'no-cache');\n    res.setHeader('Connection', 'keep-alive');\n\n    // Fetch project and panels from DB\n    const project = await getProject(projectId);\n    if (!project) throw new NotFoundError('Project');\n\n    // Filter panels (all or specific indices)\n    const panelsToGenerate = project.panels.filter(\n      p => !panelIndices || panelIndices.includes(p.panelIndex)\n    );\n\n    // Generate prompts array\n    const panelPrompts: PanelPrompt[] = panelsToGenerate.map(p => ({\n      panelIndex: p.panelIndex,\n      dallePrompt: p.prompt!,\n      storyBeat: p.storyBeat!,\n      visualFocus: 'main subject',  // Extract from context if available\n      transitionType: 'cut',        // Default, could be from DB\n    }));\n\n    // Call imageGenerationService\n    imageGenService.generateBatch(\n      panelPrompts,\n      projectId,\n      batchMode,\n      project.generationSettings,\n      (progressEvent) => {\n        // Send progress as SSE\n        res.write(`data: ${JSON.stringify(progressEvent)}\\n\\n`);\n      }\n    ).then(generatedPanels => {\n      // Update database with generated images\n      for (const panel of generatedPanels) {\n        updatePanelImage(panel.panelIndex, {\n          imageUrl: panel.imageUrl,\n          imageFilePath: panel.localFilePath,\n          revisedPrompt: panel.revisedPrompt,\n          status: panel.revisedPrompt ? 'generated' : 'generated',\n        });\n      }\n\n      // Send completion event\n      res.write(`data: ${JSON.stringify({\n        type: 'complete',\n        message: 'Image generation complete',\n        totalCost: generatedPanels.reduce((sum, p) => sum + p.costUsd, 0),\n      })}\\n\\n`);\n\n      res.end();\n    }).catch(err => {\n      res.write(`data: ${JSON.stringify({\n        type: 'error',\n        message: err.message,\n      })}\\n\\n`);\n      res.end();\n    });\n  } catch (err) {\n    next(err);\n  }\n});\n```\n\n### Cost Tracking\n\n**Implementation:**\n- Track cost per API call in GeneratedPanel.costUsd\n- Sum across all panels: `totalCost = sum(generatedPanels.map(p => p.costUsd))`\n- Update project.totalCost in DB: `project.totalCost += generatedPanels totalCost`\n- Log costs for each call (useful for budget monitoring)\n\n**Cost Constants (from types.ts):**\n```typescript\nAPI_COSTS = {\n  VISION_PER_CALL: 0.025,    // GPT-4V\n  DALLE3_STANDARD: 0.040,    // per image\n  DALLE3_HD: 0.080,          // per image\n}\n```\n\n### Testing Requirements\n\n```bash\n# 1. Set up test project (with prompts from Task 2)\nPROJECT_ID=\"test-project-id\"\n# Or use output from Task 2 test\n\n# 2. Generate images (sequential mode)\ncurl -X POST http://localhost:5000/api/manga/$PROJECT_ID/generate-images \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"batchMode\": \"sequential\"}' \\\n  -H \"Accept: text/event-stream\"\n\n# 3. Verify local image files created\nls -la uploads/$PROJECT_ID/\n\n# 4. Check database for updated image URLs\nsqlite3 data/koma-fill.db \"SELECT panelIndex, imageFilePath, status FROM panels WHERE projectId='$PROJECT_ID';\"\n\n# 5. Verify cost tracking\ncurl http://localhost:5000/api/manga/$PROJECT_ID | jq '.totalCost'\n```\n\n### Files This Task Provides to Other Agents\n\n- **Generated panel images** - Stored in uploads/{projectId}/, used by Task 4\n- **Image file paths** - Updated in DB, used by Task 4 for layout composition\n- **Cost tracking** - Used by frontend for budget display\n\n### Output Validation Checklist\n\n- [ ] DALL-E 3 API calls succeed with valid prompts\n- [ ] Retry logic works with exponential backoff\n- [ ] Images download and save to {STORAGE_PATH}/{projectId}/\n- [ ] SSE streaming sends progress events correctly\n- [ ] onProgress callback fires with accurate percentage\n- [ ] Cost calculation correct (0.04 standard, 0.08 HD)\n- [ ] Panel records updated with imageUrl and imageFilePath\n- [ ] Sequential and parallel modes both work\n- [ ] Rate limiting respected (max 5 calls/min by default)\n- [ ] Error handling for network issues, API failures\n- [ ] No TypeScript compilation errors\n\n---\n\n## Task 4: + (Agent D)\n### Manga Layout Composition & Multi-Format Export\n\n**Time Estimate:** 45-60 minutes\n**Difficulty:** Intermediate (Sharp library learning curve)\n**Dependencies:** Task 1 (DB), Task 3 (generated images)\n\n### Objective\nImplement Sharp-based manga layout composition with grid calculation, panel resizing and positioning, border/gutter rendering, speech bubble overlay, and PNG/JPG/PDF export functionality.\n\n### Target Files to Create/Modify\n\n```\nbackend/\n src/\n     services/\n        layoutEngine.ts          [IMPLEMENT] Panel composition & layout\n        exportService.ts         [CREATE] PNG/JPG/PDF export\n     utils/\n         imageProcessor.ts        [HELPER] Image processing utilities\n```\n\n### TypeScript Interfaces\n\n```typescript\n// Layout composition result\nComposedLayout {\n  buffer: Buffer;                    // PNG image buffer\n  width: number;                     // Page width (px)\n  height: number;                    // Page height (px)\n  format: 'png';\n  panelPositions: PanelPosition[];   // Position data for each panel\n}\n\nPanelPosition {\n  panelIndex: number;\n  x: number;                         // Offset from top-left (px)\n  y: number;\n  width: number;                     // Panel width (px)\n  height: number;                    // Panel height (px)\n}\n\n// Input to layout engine\nLayoutConfig {\n  totalPanels: number;               // 4, 6, 8, etc.\n  format: LayoutFormat;              // 'vertical' | 'horizontal' | 'square'\n  readingOrder: ReadingOrder;        // 'japanese' | 'western'\n  gutterSize: number;                // Space between panels (px)\n  borderWidth: number;               // Panel border thickness (px)\n  borderColor: string;               // Hex color\n  backgroundColor: string;           // Hex color\n  pageWidth: number;                 // Canvas width (px)\n  pageHeight: number;                // Canvas height (px)\n}\n```\n\n### Implementation Details\n\n#### LayoutEngine (`backend/src/services/layoutEngine.ts`)\n\n**Method: composePanels() - Main Composition Function**\n\n```typescript\nasync composePanels(\n  panelImagePaths: string[],\n  config: LayoutConfig = DEFAULT_LAYOUT_CONFIG\n): Promise<ComposedLayout>\n```\n\nImplementation Steps:\n\n1. **Calculate Grid:**\n   ```typescript\n   const grid = this.calculateGrid(panelImagePaths.length, config);\n   // Returns { cols: number, rows: number }\n   ```\n   Already implemented - use it.\n\n2. **Calculate Panel Positions:**\n   ```typescript\n   const positions = this.calculatePanelPositions(grid, config);\n   // Returns: PanelPosition[] with x, y, width, height for each panel\n   ```\n   Already implemented - use it.\n\n3. **Create Background Canvas:**\n   ```typescript\n   import sharp from 'sharp';\n\n   let canvas = sharp({\n     create: {\n       width: config.pageWidth,\n       height: config.pageHeight,\n       channels: 4,                    // RGBA\n       background: config.backgroundColor,  // Parsed from hex\n     }\n   });\n   ```\n\n4. **Load & Resize Panel Images:**\n   ```typescript\n   const composites = await Promise.all(\n     panelImagePaths.map(async (imgPath, i) => {\n       if (!fs.existsSync(imgPath)) {\n         throw new Error(`Panel image not found: ${imgPath}`);\n       }\n\n       const position = positions[i];\n       const resized = await sharp(imgPath)\n         .resize(position.width, position.height, {\n           fit: 'cover',              // Fill panel, crop if needed\n           withoutEnlargement: false\n         })\n         .toBuffer();\n\n       return {\n         input: resized,\n         left: position.x,\n         top: position.y\n       };\n     })\n   );\n   ```\n\n5. **Composite Panels Onto Canvas:**\n   ```typescript\n   let result = await canvas.composite(composites).png();\n   ```\n\n6. **Add Borders (Optional - if borderWidth > 0):**\n   - Use SVG overlay to draw rectangles around each panel\n   - Create SVG:\n     ```svg\n     <svg width=\"800\" height=\"1200\">\n       <!-- For each panel position -->\n       <rect x=\"10\" y=\"10\" width=\"390\" height=\"590\"\n             fill=\"none\" stroke=\"black\" stroke-width=\"2\" />\n     </svg>\n     ```\n   - Composite SVG overlay:\n     ```typescript\n     const borderSvg = this.generateBorderSvg(positions, config);\n     result = await result.composite([{\n       input: borderSvg,\n       top: 0,\n       left: 0\n     }]);\n     ```\n\n7. **Return ComposedLayout:**\n   ```typescript\n   const buffer = await result.toBuffer();\n   return {\n     buffer,\n     width: config.pageWidth,\n     height: config.pageHeight,\n     format: 'png',\n     panelPositions: positions\n   };\n   ```\n\n**Method: addSpeechBubbles() - Overlay Speech Bubbles**\n\n```typescript\nasync addSpeechBubbles(\n  layout: ComposedLayout,\n  bubbles: SpeechBubble[]\n): Promise<ComposedLayout>\n```\n\nImplementation:\n\n1. **For each speech bubble:**\n   - Get panel position from layout.panelPositions[bubble.panelIndex]\n   - Calculate bubble position within panel:\n     - 'top'  y = panel.y + 30\n     - 'middle'  y = panel.y + panel.height/2 - 30\n     - 'bottom'  y = panel.y + panel.height - 60\n\n2. **Create SVG speech bubble:**\n   ```typescript\n   const svg = this.generateSpeechBubbleSvg(bubble, position, style);\n   // Generates SVG with text, shape varies by style:\n   // 'rounded', 'cloud', 'spiked', 'rectangular'\n   ```\n\n3. **Composite all bubble SVGs:**\n   ```typescript\n   let result = sharp(layout.buffer);\n   const bubbleSvgs = bubbles.map((bubble, idx) =>\n     this.generateSpeechBubbleSvg(bubble, panelPositions[bubble.panelIndex])\n   );\n\n   result = await result.composite(\n     bubbleSvgs.map((svg, i) => ({ input: svg }))\n   );\n   ```\n\n4. **Return updated ComposedLayout**\n\n**Helper: generateBorderSvg()**\n```typescript\nprivate generateBorderSvg(\n  positions: PanelPosition[],\n  config: LayoutConfig\n): Buffer\n```\n\nGenerate SVG with rectangle borders around each panel:\n```svg\n<svg width=\"800\" height=\"1200\">\n  <rect x=\"10\" y=\"10\" width=\"390\" height=\"590\"\n        fill=\"none\" stroke=\"#000000\" stroke-width=\"2\" />\n  <!-- repeated for each panel -->\n</svg>\n```\n\nConvert to Buffer and return.\n\n**Helper: generateSpeechBubbleSvg()**\n```typescript\nprivate generateSpeechBubbleSvg(\n  bubble: SpeechBubble,\n  panelPosition: PanelPosition,\n  targetY: number  // top/middle/bottom\n): Buffer\n```\n\nGenerate SVG with speech bubble shape. Example for 'rounded':\n```svg\n<svg width=\"300\" height=\"100\">\n  <!-- Rounded rectangle -->\n  <path d=\"M 10,10 Q 10,10 20,10 L 270,10 Q 280,10 280,20 L 280,70 Q 280,80 270,80 L 30,80 Q 20,80 20,70 L 20,40 L 0,60 L 20,50 L 20,20 Q 20,10 10,10\"\n        fill=\"white\" stroke=\"black\" stroke-width=\"1\" />\n  <text x=\"20\" y=\"50\" font-family=\"Arial\" font-size=\"14\">Your text here</text>\n</svg>\n```\n\nReturn SVG as Buffer via:\n```typescript\nconst svgBuffer = Buffer.from(svgString, 'utf-8');\n```\n\n### ExportService (`backend/src/services/exportService.ts`) - NEW FILE\n\nImplement export to PNG, JPG, PDF formats.\n\n```typescript\nexport class ExportService {\n  async exportPNG(\n    layout: ComposedLayout,\n    filepath: string,\n    compression: 'low' | 'medium' | 'high'\n  ): Promise<void>\n\n  async exportJPG(\n    layout: ComposedLayout,\n    filepath: string,\n    quality: number  // 60-95\n  ): Promise<void>\n\n  async exportPDF(\n    layout: ComposedLayout,\n    filepath: string,\n    metadata: { title?: string; author?: string }\n  ): Promise<void>\n}\n```\n\n**exportPNG():**\n```typescript\nasync exportPNG(layout, filepath, compression) {\n  const compressionLevel = compression === 'high' ? 9 : compression === 'medium' ? 6 : 1;\n  await sharp(layout.buffer)\n    .png({ compressionLevel })\n    .toFile(filepath);\n}\n```\n\n**exportJPG():**\n```typescript\nasync exportJPG(layout, filepath, quality = 80) {\n  await sharp(layout.buffer)\n    .jpeg({ quality, mozjpeg: true })\n    .toFile(filepath);\n}\n```\n\n**exportPDF():**\nRequires pdfkit library:\n```typescript\nimport PDFDocument from 'pdfkit';\nimport { createWriteStream } from 'fs';\n\nasync exportPDF(layout, filepath, metadata = {}) {\n  const doc = new PDFDocument({\n    size: [layout.width, layout.height]\n  });\n\n  if (metadata.title) doc.title(metadata.title);\n  if (metadata.author) doc.author(metadata.author);\n\n  // Add image to PDF\n  doc.image(layout.buffer, 0, 0, {\n    width: layout.width,\n    height: layout.height\n  });\n\n  doc.pipe(createWriteStream(filepath));\n  doc.end();\n}\n```\n\n### Route Handler Integration\n\nImplement in `backend/src/routes/manga.ts`:\n\n**POST /api/manga/:projectId/layout**\n```typescript\nrouter.post('/:projectId/layout', async (req: Request, res: Response, next: NextFunction) => {\n  try {\n    const { projectId } = req.params;\n    const { speechBubbles } = req.body as GenerateLayoutRequest;\n\n    // Fetch project and panels from DB\n    const project = await getProject(projectId);\n    if (!project) throw new NotFoundError('Project');\n\n    // Get panel image paths\n    const panelPaths = project.panels\n      .sort((a, b) => a.panelIndex - b.panelIndex)\n      .map(p => p.imageFilePath)\n      .filter(path => path !== undefined);\n\n    // Compose layout\n    const layoutEngine = new LayoutEngine();\n    let layout = await layoutEngine.composePanels(panelPaths, project.layoutConfig);\n\n    // Add speech bubbles if provided\n    if (speechBubbles && speechBubbles.length > 0) {\n      layout = await layoutEngine.addSpeechBubbles(layout, speechBubbles);\n    }\n\n    // Save layout buffer to temporary file for preview\n    const layoutPath = path.join(CONFIG.STORAGE_PATH, projectId, 'layout.png');\n    await fs.writeFile(layoutPath, layout.buffer);\n\n    // Update project status\n    await updateProject(projectId, { status: 'complete' });\n\n    // Return layout info\n    res.json({\n      message: 'Layout composed successfully',\n      projectId,\n      layoutPath: `/uploads/${projectId}/layout.png`,\n      panelPositions: layout.panelPositions,\n      dimensions: { width: layout.width, height: layout.height }\n    });\n  } catch (err) {\n    next(err);\n  }\n});\n```\n\n**POST /api/manga/:projectId/export**\n```typescript\nrouter.post('/:projectId/export', async (req: Request, res: Response, next: NextFunction) => {\n  try {\n    const { projectId } = req.params;\n    const { format, compression, resolution, title, author } = req.body as ExportRequest;\n\n    // Fetch project layout\n    const layoutPath = path.join(CONFIG.STORAGE_PATH, projectId, 'layout.png');\n    if (!fs.existsSync(layoutPath)) {\n      throw new Error('Layout not yet generated. Call /layout endpoint first.');\n    }\n\n    const layoutBuffer = await fs.promises.readFile(layoutPath);\n    const layout: ComposedLayout = {\n      buffer: layoutBuffer,\n      width: 800,  // From project.layoutConfig\n      height: 1200,\n      format: 'png',\n      panelPositions: []  // Could fetch from DB if needed\n    };\n\n    // Export to requested format\n    const exportService = new ExportService();\n    const timestamp = Date.now();\n    const exportPath = path.join(CONFIG.STORAGE_PATH, projectId, `manga_${timestamp}.${format}`);\n\n    if (format === 'png') {\n      await exportService.exportPNG(layout, exportPath, compression as 'low' | 'medium' | 'high');\n    } else if (format === 'jpg') {\n      const qualityMap = { low: 60, medium: 80, high: 95 };\n      await exportService.exportJPG(layout, exportPath, qualityMap[compression]);\n    } else if (format === 'pdf') {\n      await exportService.exportPDF(layout, exportPath, { title, author });\n    }\n\n    // Update project status\n    await updateProject(projectId, { status: 'exported' });\n\n    res.json({\n      message: 'Export successful',\n      projectId,\n      format,\n      downloadUrl: `/uploads/${projectId}/manga_${timestamp}.${format}`,\n      filePath: exportPath\n    });\n  } catch (err) {\n    next(err);\n  }\n});\n```\n\n### Testing Requirements\n\n```bash\n# 1. Generate layout from Task 3 images\nPROJECT_ID=\"test-project-id\"\ncurl -X POST http://localhost:5000/api/manga/$PROJECT_ID/layout \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\n    \"speechBubbles\": [\n      {\n        \"panelIndex\": 0,\n        \"text\": \"Wow!\",\n        \"position\": \"top\",\n        \"style\": \"rounded\"\n      }\n    ]\n  }'\n\n# 2. View composed layout\nopen http://localhost:5000/uploads/$PROJECT_ID/layout.png\n\n# 3. Export to PNG\ncurl -X POST http://localhost:5000/api/manga/$PROJECT_ID/export \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\n    \"format\": \"png\",\n    \"compression\": \"medium\",\n    \"resolution\": \"web\",\n    \"title\": \"My Manga\"\n  }'\n\n# 4. Export to PDF\ncurl -X POST http://localhost:5000/api/manga/$PROJECT_ID/export \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\n    \"format\": \"pdf\",\n    \"compression\": \"medium\",\n    \"title\": \"My Manga\",\n    \"author\": \"AI Creator\"\n  }'\n\n# 5. Verify files exist\nls -lh uploads/$PROJECT_ID/\n```\n\n### Files This Task Provides to Other Agents\n\n- **Composed layout image** - Used by frontend for preview\n- **Export files** - PNG/JPG/PDF outputs for download\n- **Layout metadata** - Panel positions for debugging/display\n\n### Output Validation Checklist\n\n- [ ] calculateGrid() and calculatePanelPositions() methods work correctly\n- [ ] composePanels() successfully combines images with sharp\n- [ ] Borders render correctly around panels\n- [ ] Speech bubbles overlay without distortion\n- [ ] Multiple speech bubble styles work ('rounded', 'cloud', 'spiked', 'rectangular')\n- [ ] Layout PNG saved and readable\n- [ ] exportPNG() produces valid PNG files\n- [ ] exportJPG() produces valid JPG files with quality control\n- [ ] exportPDF() produces valid PDF with metadata\n- [ ] /layout endpoint returns correct panel positions\n- [ ] /export endpoint returns download URLs\n- [ ] Compression settings affect file size appropriately\n- [ ] No TypeScript compilation errors\n\n---\n\n## Task 5: React (Agent E)\n### Complete React UI with Component Implementation\n\n**Time Estimate:** 60-80 minutes\n**Difficulty:** Intermediate (React component patterns)\n**Dependencies:** Tasks 1-4 (backend API must be running)\n\n### Objective\nComplete all React components for the koma-fill frontend including image upload with drag-drop, story prompt editor, panel grid with drag-and-drop reordering, complete manga generation workflow orchestration, real-time SSE progress updates, and multi-format export options. Configure Tailwind CSS for styling.\n\n### Target Files to Create/Modify\n\n```\nfrontend/\n src/\n    components/\n       ImageUploader.tsx           [IMPLEMENT] Dropzone with position selector\n       StoryPromptEditor.tsx       [ENHANCE] Add sample prompts\n       PanelGrid.tsx               [IMPLEMENT] Drag-and-drop reordering\n       LayoutSelector.tsx          [VERIFY] Layout config UI\n       ExportOptions.tsx           [VERIFY] Export format selection\n       ProgressBar.tsx             [CREATE] Real-time progress display\n    hooks/\n       useMangaGeneration.ts       [IMPLEMENT] Full workflow orchestration\n    services/\n       apiClient.ts                [IMPLEMENT] API client with SSE support\n    pages/\n       CreateMangaPage.tsx         [IMPLEMENT] Main workflow page\n       PreviewPage.tsx             [IMPLEMENT] Result preview & download\n    App.tsx                         [UPDATE] Routing\n    main.tsx                        [VERIFY] Entry point\n    index.css                       [UPDATE] Tailwind directives\n tailwind.config.js                  [CREATE] Tailwind configuration\n postcss.config.js                   [CREATE] PostCSS configuration\n package.json                        [UPDATE] Add Tailwind dependencies\n tsconfig.json                       [VERIFY] TypeScript config\n```\n\n### TypeScript Interfaces (from `frontend/src/types/index.ts`)\n\nAlready defined - reference for component props.\n\n### Implementation Details\n\n#### 1. Tailwind CSS Setup\n\n**Install Dependencies:**\n```bash\ncd frontend\nnpm install -D tailwindcss postcss autoprefixer\nnpx tailwindcss init -p\n```\n\n**tailwind.config.js:**\n```javascript\nexport default {\n  content: [\n    './index.html',\n    './src/**/*.{js,ts,jsx,tsx}',\n  ],\n  theme: {\n    extend: {\n      colors: {\n        manga: {\n          dark: '#1a1a1a',\n          light: '#f5f5f5',\n        }\n      }\n    },\n  },\n  plugins: [],\n}\n```\n\n**postcss.config.js:**\n```javascript\nexport default {\n  plugins: {\n    tailwindcss: {},\n    autoprefixer: {},\n  },\n}\n```\n\n**frontend/src/index.css:**\n```css\n@tailwind base;\n@tailwind components;\n@tailwind utilities;\n\n@layer components {\n  .btn-primary {\n    @apply px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700 transition;\n  }\n  .btn-secondary {\n    @apply px-4 py-2 bg-gray-300 text-gray-800 rounded-lg hover:bg-gray-400 transition;\n  }\n  .input-field {\n    @apply w-full px-3 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500;\n  }\n}\n```\n\n#### 2. API Client (`frontend/src/services/apiClient.ts`)\n\n```typescript\nimport { MangaProject, Panel, GenerationProgress, ProgressEvent } from '../types';\n\nconst API_BASE = import.meta.env.VITE_API_URL || 'http://localhost:5000/api';\n\nexport class APIClient {\n  /**\n   * Create new manga project\n   */\n  async createProject(name: string, storyPrompt: string, layoutConfig?: any) {\n    const response = await fetch(`${API_BASE}/manga/create`, {\n      method: 'POST',\n      headers: { 'Content-Type': 'application/json' },\n      body: JSON.stringify({\n        projectName: name,\n        storyPrompt,\n        layoutConfig\n      })\n    });\n    if (!response.ok) throw new Error(await response.text());\n    return response.json() as Promise<MangaProject>;\n  }\n\n  /**\n   * Upload key images\n   */\n  async uploadImages(projectId: string, files: File[]) {\n    const formData = new FormData();\n    files.forEach(file => formData.append('images', file));\n\n    const response = await fetch(`${API_BASE}/manga/${projectId}/upload`, {\n      method: 'POST',\n      body: formData\n    });\n    if (!response.ok) throw new Error(await response.text());\n    return response.json();\n  }\n\n  /**\n   * Analyze images using Vision API\n   */\n  async analyzeImages(projectId: string, depth: 'quick' | 'detailed' = 'quick') {\n    const response = await fetch(`${API_BASE}/manga/${projectId}/analyze`, {\n      method: 'POST',\n      headers: { 'Content-Type': 'application/json' },\n      body: JSON.stringify({ analysisDepth: depth })\n    });\n    if (!response.ok) throw new Error(await response.text());\n    return response.json();\n  }\n\n  /**\n   * Generate panel prompts\n   */\n  async generatePrompts(projectId: string, storyPrompt: string, panelCount: number) {\n    const response = await fetch(`${API_BASE}/manga/${projectId}/generate-prompts`, {\n      method: 'POST',\n      headers: { 'Content-Type': 'application/json' },\n      body: JSON.stringify({\n        storyPrompt,\n        panelCount,\n        characterConsistency: true\n      })\n    });\n    if (!response.ok) throw new Error(await response.text());\n    return response.json() as Promise<Panel[]>;\n  }\n\n  /**\n   * Generate images via DALL-E 3 (SSE streaming)\n   */\n  streamImageGeneration(\n    projectId: string,\n    batchMode: 'sequential' | 'parallel',\n    onProgress: (event: ProgressEvent) => void,\n    onError: (error: Error) => void\n  ): () => void {\n    const eventSource = new EventSource(\n      `${API_BASE}/manga/${projectId}/generate-images?batchMode=${batchMode}`\n    );\n\n    eventSource.onmessage = (event) => {\n      try {\n        const data = JSON.parse(event.data);\n        onProgress(data);\n      } catch (e) {\n        console.error('Failed to parse SSE message:', e);\n      }\n    };\n\n    eventSource.onerror = () => {\n      onError(new Error('Generation failed or connection lost'));\n      eventSource.close();\n    };\n\n    // Return cleanup function\n    return () => eventSource.close();\n  }\n\n  /**\n   * Compose layout with speech bubbles\n   */\n  async composeLayout(projectId: string, speechBubbles?: any) {\n    const response = await fetch(`${API_BASE}/manga/${projectId}/layout`, {\n      method: 'POST',\n      headers: { 'Content-Type': 'application/json' },\n      body: JSON.stringify({ speechBubbles })\n    });\n    if (!response.ok) throw new Error(await response.text());\n    return response.json();\n  }\n\n  /**\n   * Export to PNG/JPG/PDF\n   */\n  async exportManga(\n    projectId: string,\n    format: 'png' | 'jpg' | 'pdf',\n    compression: 'low' | 'medium' | 'high' = 'medium',\n    title?: string,\n    author?: string\n  ) {\n    const response = await fetch(`${API_BASE}/manga/${projectId}/export`, {\n      method: 'POST',\n      headers: { 'Content-Type': 'application/json' },\n      body: JSON.stringify({\n        format,\n        compression,\n        resolution: 'web',\n        title,\n        author\n      })\n    });\n    if (!response.ok) throw new Error(await response.text());\n    return response.json();\n  }\n\n  /**\n   * Fetch project details\n   */\n  async getProject(projectId: string) {\n    const response = await fetch(`${API_BASE}/manga/${projectId}`);\n    if (!response.ok) throw new Error(await response.text());\n    return response.json() as Promise<MangaProject>;\n  }\n\n  /**\n   * Reorder panels\n   */\n  async reorderPanels(projectId: string, panelOrder: number[]) {\n    const response = await fetch(`${API_BASE}/manga/${projectId}/reorder`, {\n      method: 'PUT',\n      headers: { 'Content-Type': 'application/json' },\n      body: JSON.stringify({ panelOrder })\n    });\n    if (!response.ok) throw new Error(await response.text());\n    return response.json();\n  }\n}\n\nexport const apiClient = new APIClient();\n```\n\n#### 3. useMangaGeneration Hook (`frontend/src/hooks/useMangaGeneration.ts`)\n\n```typescript\nimport { useState, useCallback } from 'react';\nimport { apiClient } from '../services/apiClient';\nimport { MangaProject, GenerationProgress, UploadedImage } from '../types';\n\nexport function useMangaGeneration() {\n  const [project, setProject] = useState<MangaProject | null>(null);\n  const [progress, setProgress] = useState<GenerationProgress>({\n    stage: 'idle',\n    currentStep: 0,\n    totalSteps: 0,\n    percentage: 0,\n    message: ''\n  });\n  const [error, setError] = useState<string | null>(null);\n\n  /**\n   * Complete workflow: Create  Upload  Analyze  Generate Prompts  Generate Images  Layout\n   */\n  const generateManga = useCallback(async (\n    projectName: string,\n    storyPrompt: string,\n    uploadedImages: UploadedImage[],\n    layoutConfig: any,\n    generationSettings: any\n  ) => {\n    try {\n      setError(null);\n\n      // Stage 1: Create project\n      setProgress({\n        stage: 'uploading',\n        currentStep: 0,\n        totalSteps: 5,\n        percentage: 20,\n        message: 'Creating project...'\n      });\n      const newProject = await apiClient.createProject(projectName, storyPrompt, layoutConfig);\n      setProject(newProject);\n\n      // Stage 2: Upload images\n      setProgress({\n        stage: 'uploading',\n        currentStep: 1,\n        totalSteps: 5,\n        percentage: 40,\n        message: 'Uploading reference images...'\n      });\n      const files = uploadedImages.map(img => img.file);\n      await apiClient.uploadImages(newProject.id, files);\n\n      // Stage 3: Analyze images\n      setProgress({\n        stage: 'analyzing',\n        currentStep: 2,\n        totalSteps: 5,\n        percentage: 60,\n        message: 'Analyzing images with Vision API...'\n      });\n      await apiClient.analyzeImages(newProject.id, 'detailed');\n\n      // Stage 4: Generate prompts\n      setProgress({\n        stage: 'generating_prompts',\n        currentStep: 3,\n        totalSteps: 5,\n        percentage: 70,\n        message: 'Generating panel prompts...'\n      });\n      await apiClient.generatePrompts(\n        newProject.id,\n        storyPrompt,\n        layoutConfig.totalPanels\n      );\n\n      // Stage 5: Generate images (with SSE streaming)\n      setProgress({\n        stage: 'generating_images',\n        currentStep: 4,\n        totalSteps: 5,\n        percentage: 75,\n        message: 'Starting image generation...'\n      });\n\n      await new Promise<void>((resolve, reject) => {\n        const cleanup = apiClient.streamImageGeneration(\n          newProject.id,\n          'sequential',  // or 'parallel' based on user preference\n          (progressEvent) => {\n            if (progressEvent.type === 'complete') {\n              setProgress(prev => ({\n                ...prev,\n                percentage: 90,\n                message: 'Image generation complete!'\n              }));\n              resolve();\n            } else if (progressEvent.type === 'error') {\n              reject(new Error(progressEvent.error || 'Generation failed'));\n            } else {\n              setProgress({\n                stage: 'generating_images',\n                currentStep: 4 + (progressEvent.currentStep || 0) * 0.1,\n                totalSteps: 5,\n                percentage: 75 + (progressEvent.percentage || 0) * 0.15,\n                message: progressEvent.message,\n                currentPanelIndex: progressEvent.panelIndex\n              });\n            }\n          },\n          reject\n        );\n      });\n\n      // Stage 6: Compose layout\n      setProgress({\n        stage: 'composing_layout',\n        currentStep: 5,\n        totalSteps: 5,\n        percentage: 95,\n        message: 'Composing final layout...'\n      });\n      await apiClient.composeLayout(newProject.id);\n\n      // Complete\n      const finalProject = await apiClient.getProject(newProject.id);\n      setProject(finalProject);\n      setProgress({\n        stage: 'idle',\n        currentStep: 5,\n        totalSteps: 5,\n        percentage: 100,\n        message: 'Manga generation complete!'\n      });\n\n    } catch (err) {\n      const errorMsg = err instanceof Error ? err.message : 'Unknown error';\n      setError(errorMsg);\n      setProgress({\n        stage: 'idle',\n        currentStep: 0,\n        totalSteps: 0,\n        percentage: 0,\n        message: `Error: ${errorMsg}`\n      });\n    }\n  }, []);\n\n  const exportManga = useCallback(async (\n    projectId: string,\n    format: 'png' | 'jpg' | 'pdf',\n    compression: 'low' | 'medium' | 'high' = 'medium'\n  ) => {\n    try {\n      setError(null);\n      setProgress({\n        stage: 'exporting',\n        currentStep: 0,\n        totalSteps: 1,\n        percentage: 50,\n        message: `Exporting as ${format.toUpperCase()}...`\n      });\n\n      const result = await apiClient.exportManga(projectId, format, compression);\n\n      setProgress({\n        stage: 'idle',\n        currentStep: 1,\n        totalSteps: 1,\n        percentage: 100,\n        message: 'Export complete!'\n      });\n\n      return result;\n    } catch (err) {\n      const errorMsg = err instanceof Error ? err.message : 'Export failed';\n      setError(errorMsg);\n      throw err;\n    }\n  }, []);\n\n  return {\n    project,\n    progress,\n    error,\n    generateManga,\n    exportManga,\n    setError\n  };\n}\n```\n\n#### 4. Components\n\n**ImageUploader.tsx:**\n```typescript\nimport { useCallback, useState } from 'react';\nimport { UploadedImage, ImagePosition } from '../types';\n\ninterface ImageUploaderProps {\n  onImagesSelected: (images: UploadedImage[]) => void;\n}\n\nexport function ImageUploader({ onImagesSelected }: ImageUploaderProps) {\n  const [images, setImages] = useState<UploadedImage[]>([]);\n  const [selectedPosition, setSelectedPosition] = useState<ImagePosition>('start');\n\n  const handleDrop = useCallback((e: React.DragEvent) => {\n    e.preventDefault();\n    const files = Array.from(e.dataTransfer.files).filter(f => f.type.startsWith('image/'));\n    addImages(files);\n  }, []);\n\n  const handleFileInput = (e: React.ChangeEvent<HTMLInputElement>) => {\n    if (e.target.files) {\n      addImages(Array.from(e.target.files));\n    }\n  };\n\n  const addImages = (files: File[]) => {\n    const newImages = files.map(file => ({\n      file,\n      previewUrl: URL.createObjectURL(file),\n      position: selectedPosition\n    }));\n    setImages(prev => [...prev, ...newImages]);\n    onImagesSelected([...images, ...newImages]);\n  };\n\n  const removeImage = (index: number) => {\n    const updated = images.filter((_, i) => i !== index);\n    setImages(updated);\n    onImagesSelected(updated);\n  };\n\n  return (\n    <div className=\"w-full max-w-2xl\">\n      <div\n        onDrop={handleDrop}\n        onDragOver={e => e.preventDefault()}\n        className=\"border-2 border-dashed border-gray-300 rounded-lg p-8 text-center cursor-pointer hover:border-blue-500 transition\"\n      >\n        <p className=\"text-gray-600 mb-4\">Drag and drop images here or click to select</p>\n        <input\n          type=\"file\"\n          multiple\n          accept=\"image/*\"\n          onChange={handleFileInput}\n          className=\"hidden\"\n          id=\"image-input\"\n        />\n        <label htmlFor=\"image-input\" className=\"btn-primary cursor-pointer\">\n          Select Images\n        </label>\n      </div>\n\n      <div className=\"mt-4\">\n        <label className=\"block mb-2\">Position in Story:</label>\n        <select\n          value={selectedPosition}\n          onChange={e => setSelectedPosition(e.target.value as ImagePosition)}\n          className=\"input-field\"\n        >\n          <option value=\"start\">Start (Reference)</option>\n          <option value=\"end\">End (Reference)</option>\n          <option value={1}>Panel 1</option>\n          <option value={2}>Panel 2</option>\n        </select>\n      </div>\n\n      {images.length > 0 && (\n        <div className=\"mt-6 grid grid-cols-2 gap-4\">\n          {images.map((img, idx) => (\n            <div key={idx} className=\"relative\">\n              <img src={img.previewUrl} alt={`Preview ${idx}`} className=\"rounded-lg w-full h-48 object-cover\" />\n              <button\n                onClick={() => removeImage(idx)}\n                className=\"absolute top-2 right-2 bg-red-500 text-white rounded-full w-6 h-6 flex items-center justify-center hover:bg-red-600\"\n              >\n                \n              </button>\n            </div>\n          ))}\n        </div>\n      )}\n    </div>\n  );\n}\n```\n\n**StoryPromptEditor.tsx (Enhanced):**\n```typescript\nimport { useState } from 'react';\n\ninterface StoryPromptEditorProps {\n  value: string;\n  onChange: (value: string) => void;\n}\n\nconst SAMPLE_PROMPTS = [\n  'A young ninja discovers their hidden powers and must save their village from a mysterious threat.',\n  'Two rival chefs compete in a cooking tournament, discovering they have more in common than they thought.',\n  'A time traveler must prevent a catastrophic event by gathering clues from different eras.',\n];\n\nexport function StoryPromptEditor({ value, onChange }: StoryPromptEditorProps) {\n  const [isExpanded, setIsExpanded] = useState(false);\n\n  return (\n    <div className=\"w-full max-w-2xl\">\n      <label className=\"block text-lg font-semibold mb-2\">Your Story Prompt</label>\n\n      <textarea\n        value={value}\n        onChange={e => onChange(e.target.value)}\n        placeholder=\"Write your manga story here. Be descriptive about characters, setting, and plot...\"\n        className=\"input-field h-32 resize-none\"\n      />\n\n      <div className=\"mt-4\">\n        <button\n          onClick={() => setIsExpanded(!isExpanded)}\n          className=\"text-blue-600 hover:underline text-sm\"\n        >\n          {isExpanded ? 'Hide' : 'Show'} Sample Prompts\n        </button>\n\n        {isExpanded && (\n          <div className=\"mt-3 space-y-2\">\n            {SAMPLE_PROMPTS.map((prompt, idx) => (\n              <button\n                key={idx}\n                onClick={() => onChange(prompt)}\n                className=\"block w-full text-left p-3 bg-gray-100 hover:bg-gray-200 rounded-lg text-sm transition\"\n              >\n                {prompt}\n              </button>\n            ))}\n          </div>\n        )}\n      </div>\n    </div>\n  );\n}\n```\n\n**PanelGrid.tsx (with Drag-and-Drop):**\n```typescript\nimport { useState } from 'react';\nimport { Panel } from '../types';\nimport { DndContext, closestCenter, KeyboardSensor, PointerSensor, useSensor, useSensors } from '@dnd-kit/core';\nimport { SortableContext, sortableKeyboardCoordinates, verticalListSortingStrategy, useSortable } from '@dnd-kit/sortable';\nimport { CSS } from '@dnd-kit/utilities';\n\nfunction SortablePanel({ panel }: { panel: Panel }) {\n  const { attributes, listeners, setNodeRef, transform, transition } = useSortable({ id: panel.id });\n  const style = { transform: CSS.Transform.toString(transform), transition };\n\n  return (\n    <div ref={setNodeRef} style={style} {...attributes} {...listeners} className=\"p-4\">\n      <div className=\"bg-white rounded-lg shadow p-4 cursor-grab active:cursor-grabbing\">\n        <img\n          src={panel.imageUrl}\n          alt={`Panel ${panel.panelIndex}`}\n          className=\"w-full h-auto rounded mb-2\"\n        />\n        <p className=\"text-sm text-gray-600\">{panel.storyBeat}</p>\n        <span className={`inline-block mt-2 px-2 py-1 rounded text-xs text-white ${\n          panel.status === 'generated' ? 'bg-green-500' :\n          panel.status === 'pending' ? 'bg-blue-500' :\n          'bg-red-500'\n        }`}>\n          {panel.status}\n        </span>\n      </div>\n    </div>\n  );\n}\n\ninterface PanelGridProps {\n  panels: Panel[];\n  onReorder: (newOrder: Panel[]) => void;\n}\n\nexport function PanelGrid({ panels, onReorder }: PanelGridProps) {\n  const sensors = useSensors(\n    useSensor(PointerSensor),\n    useSensor(KeyboardSensor, { coordinateGetter: sortableKeyboardCoordinates })\n  );\n\n  const handleDragEnd = (event: any) => {\n    const { active, over } = event;\n    if (over && active.id !== over.id) {\n      const oldIndex = panels.findIndex(p => p.id === active.id);\n      const newIndex = panels.findIndex(p => p.id === over.id);\n      const newPanels = [...panels];\n      [newPanels[oldIndex], newPanels[newIndex]] = [newPanels[newIndex], newPanels[oldIndex]];\n      onReorder(newPanels);\n    }\n  };\n\n  return (\n    <DndContext sensors={sensors} collisionDetection={closestCenter} onDragEnd={handleDragEnd}>\n      <SortableContext items={panels.map(p => p.id)} strategy={verticalListSortingStrategy}>\n        <div className=\"grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-4\">\n          {panels.map(panel => (\n            <SortablePanel key={panel.id} panel={panel} />\n          ))}\n        </div>\n      </SortableContext>\n    </DndContext>\n  );\n}\n```\n\n**ProgressBar.tsx:**\n```typescript\nimport { GenerationProgress } from '../types';\n\nexport function ProgressBar({ progress }: { progress: GenerationProgress }) {\n  return (\n    <div className=\"w-full max-w-2xl\">\n      <div className=\"mb-2 flex justify-between\">\n        <span className=\"text-sm font-semibold\">{progress.message}</span>\n        <span className=\"text-sm text-gray-600\">{Math.round(progress.percentage)}%</span>\n      </div>\n      <div className=\"w-full h-3 bg-gray-200 rounded-full overflow-hidden\">\n        <div\n          className=\"h-full bg-blue-600 transition-all duration-300\"\n          style={{ width: `${progress.percentage}%` }}\n        />\n      </div>\n    </div>\n  );\n}\n```\n\n#### 5. Pages\n\n**CreateMangaPage.tsx:**\n```typescript\nimport { useState } from 'react';\nimport { ImageUploader } from '../components/ImageUploader';\nimport { StoryPromptEditor } from '../components/StoryPromptEditor';\nimport { LayoutSelector } from '../components/LayoutSelector';\nimport { ProgressBar } from '../components/ProgressBar';\nimport { useMangaGeneration } from '../hooks/useMangaGeneration';\nimport { UploadedImage, LayoutConfig } from '../types';\n\nexport function CreateMangaPage() {\n  const [projectName, setProjectName] = useState('');\n  const [storyPrompt, setStoryPrompt] = useState('');\n  const [uploadedImages, setUploadedImages] = useState<UploadedImage[]>([]);\n  const [layoutConfig, setLayoutConfig] = useState<LayoutConfig>({\n    totalPanels: 4,\n    format: 'vertical',\n    readingOrder: 'japanese',\n    gutterSize: 10,\n    borderWidth: 2,\n    borderColor: '#000000',\n    backgroundColor: '#FFFFFF',\n    pageWidth: 800,\n    pageHeight: 1200\n  });\n\n  const { progress, error, generateManga } = useMangaGeneration();\n\n  const handleStart = async () => {\n    if (!projectName || !storyPrompt) {\n      alert('Please enter project name and story prompt');\n      return;\n    }\n\n    await generateManga(projectName, storyPrompt, uploadedImages, layoutConfig, {\n      imageStyle: 'manga style',\n      aspectRatio: 'square',\n      qualityLevel: 'standard'\n    });\n  };\n\n  return (\n    <div className=\"min-h-screen bg-gray-50 py-12 px-4\">\n      <div className=\"max-w-4xl mx-auto space-y-8\">\n        <h1 className=\"text-4xl font-bold text-center mb-2\">koma-fill</h1>\n        <p className=\"text-center text-gray-600\">AI-Powered Manga Panel Generator</p>\n\n        {error && <div className=\"bg-red-100 border border-red-400 text-red-700 px-4 py-3 rounded\">{error}</div>}\n\n        {progress.stage === 'idle' ? (\n          <div className=\"space-y-8\">\n            <div className=\"bg-white p-6 rounded-lg shadow\">\n              <label className=\"block text-lg font-semibold mb-2\">Project Name</label>\n              <input\n                type=\"text\"\n                value={projectName}\n                onChange={e => setProjectName(e.target.value)}\n                className=\"input-field\"\n                placeholder=\"My Awesome Manga\"\n              />\n            </div>\n\n            <div className=\"bg-white p-6 rounded-lg shadow\">\n              <StoryPromptEditor value={storyPrompt} onChange={setStoryPrompt} />\n            </div>\n\n            <div className=\"bg-white p-6 rounded-lg shadow\">\n              <ImageUploader onImagesSelected={setUploadedImages} />\n            </div>\n\n            <div className=\"bg-white p-6 rounded-lg shadow\">\n              <LayoutSelector config={layoutConfig} onChange={setLayoutConfig} />\n            </div>\n\n            <button onClick={handleStart} className=\"btn-primary w-full text-lg py-3\">\n              Generate Manga\n            </button>\n          </div>\n        ) : (\n          <div className=\"bg-white p-6 rounded-lg shadow\">\n            <ProgressBar progress={progress} />\n          </div>\n        )}\n      </div>\n    </div>\n  );\n}\n```\n\n**PreviewPage.tsx:**\n```typescript\nimport { useParams, useNavigate } from 'react-router-dom';\nimport { useEffect, useState } from 'react';\nimport { apiClient } from '../services/apiClient';\nimport { PanelGrid } from '../components/PanelGrid';\nimport { ExportOptions } from '../components/ExportOptions';\nimport { MangaProject } from '../types';\n\nexport function PreviewPage() {\n  const { projectId } = useParams<{ projectId: string }>();\n  const navigate = useNavigate();\n  const [project, setProject] = useState<MangaProject | null>(null);\n  const [loading, setLoading] = useState(true);\n\n  useEffect(() => {\n    if (projectId) {\n      apiClient.getProject(projectId).then(setProject).finally(() => setLoading(false));\n    }\n  }, [projectId]);\n\n  if (loading) return <div className=\"flex justify-center py-12\">Loading...</div>;\n  if (!project) return <div className=\"text-center py-12\">Project not found</div>;\n\n  return (\n    <div className=\"min-h-screen bg-gray-50 py-12 px-4\">\n      <div className=\"max-w-6xl mx-auto\">\n        <button onClick={() => navigate('/')} className=\"btn-secondary mb-6\"> Back</button>\n\n        <h1 className=\"text-3xl font-bold mb-2\">{project.name}</h1>\n        <p className=\"text-gray-600 mb-6\">Project Status: {project.status}</p>\n\n        {project.panels.length > 0 && (\n          <div className=\"bg-white p-6 rounded-lg shadow mb-8\">\n            <h2 className=\"text-2xl font-semibold mb-4\">Panels</h2>\n            <PanelGrid panels={project.panels} onReorder={() => {}} />\n          </div>\n        )}\n\n        <div className=\"bg-white p-6 rounded-lg shadow\">\n          <h2 className=\"text-2xl font-semibold mb-4\">Export</h2>\n          <ExportOptions projectId={project.id} />\n        </div>\n      </div>\n    </div>\n  );\n}\n```\n\n#### 6. Update App.tsx\n\n```typescript\nimport { BrowserRouter as Router, Routes, Route, Navigate } from 'react-router-dom';\nimport { CreateMangaPage } from './pages/CreateMangaPage';\nimport { PreviewPage } from './pages/PreviewPage';\nimport './index.css';\n\nexport default function App() {\n  return (\n    <Router>\n      <Routes>\n        <Route path=\"/\" element={<CreateMangaPage />} />\n        <Route path=\"/project/:projectId\" element={<PreviewPage />} />\n        <Route path=\"*\" element={<Navigate to=\"/\" />} />\n      </Routes>\n    </Router>\n  );\n}\n```\n\n### package.json Updates\n\nAdd dependencies:\n```bash\nnpm install -D tailwindcss postcss autoprefixer\nnpm install react-router-dom @dnd-kit/core @dnd-kit/sortable @dnd-kit/utilities\n```\n\n### Testing Requirements\n\n```bash\n# 1. Start backend (from Task 1)\ncd backend && npm run dev\n\n# 2. In another terminal, start frontend\ncd frontend && npm run dev\n\n# 3. Open browser: http://localhost:3000\n\n# 4. Test workflow:\n# - Enter project name and story\n# - Upload reference images\n# - Configure layout\n# - Click \"Generate Manga\"\n# - Watch progress bar\n# - See panel grid with images\n# - Export to PNG/JPG/PDF\n```\n\n### Files This Task Uses from Other Agents\n\n- **API endpoints** from Task 1 (database & routes)\n- **Analysis data** from Task 2 (character consistency)\n- **Generated images** from Task 3 (panel images)\n- **Composed layouts** from Task 4 (final manga)\n\n### Output Validation Checklist\n\n- [ ] Tailwind CSS configured and working\n- [ ] ImageUploader component with drag-drop works\n- [ ] react-dropzone integration functional\n- [ ] StoryPromptEditor displays with sample prompts\n- [ ] Sample prompt insertion works\n- [ ] PanelGrid displays with drag-and-drop reordering\n- [ ] @dnd-kit integration functional\n- [ ] useMangaGeneration hook orchestrates full workflow\n- [ ] SSE progress streaming displays correctly\n- [ ] ProgressBar updates in real-time\n- [ ] apiClient makes correct API calls\n- [ ] All components have TypeScript types\n- [ ] CreateMangaPage workflow complete\n- [ ] PreviewPage shows generated manga\n- [ ] ExportOptions functional (PNG/JPG/PDF)\n- [ ] Routing works (create  preview)\n- [ ] Error handling displays user-friendly messages\n- [ ] npm run dev starts without errors\n- [ ] No TypeScript compilation errors\n\n---\n\n## Integration Testing (After All Tasks Complete)\n\nAfter all 5 agents finish their implementations, run the following integration tests:\n\n```bash\n# 1. Start backend\ncd /mnt/Projects/koma-fill/backend\nnpm install\nnpm run dev\n# Expected: \" koma-fill server running on http://localhost:5000\"\n\n# 2. Start frontend (new terminal)\ncd /mnt/Projects/koma-fill/frontend\nnpm install\nnpm run dev\n# Expected: \"VITE  ready in XXX ms\"\n\n# 3. Complete workflow test\n# Open http://localhost:3000 in browser\n# - Create project\n# - Upload 2 reference images\n# - Enter story prompt\n# - Select layout (4 panels)\n# - Click \"Generate Manga\"\n# - Wait for completion\n# - View generated panels\n# - Export to PNG\n# - Verify PNG file created in uploads/\n\n# 4. Verify database\nsqlite3 /mnt/Projects/koma-fill/data/koma-fill.db\n> SELECT COUNT(*) FROM projects;\n> SELECT COUNT(*) FROM panels;\n> SELECT COUNT(*) FROM keyImages;\n\n# 5. Check file structure\nls -la /mnt/Projects/koma-fill/uploads/\nls -la /mnt/Projects/koma-fill/data/\n\n# 6. API health check\ncurl http://localhost:5000/api/health\n# Expected: {\"status\":\"ok\",\"timestamp\":\"...\"}\n```\n\n### Known Integration Points to Verify\n\n- Task 1  Task 2: Panel prompts saved in DB, readable by frontend\n- Task 2  Task 3: Vision analysis influences character consistency in prompts\n- Task 3  Task 4: Generated images saved to disk, paths in database\n- Task 4  Task 5: Layout images served via `/uploads/` static directory\n- Task 5  All: Frontend calls all backend API endpoints successfully\n\n---\n\n## Success Criteria Summary\n\nAll 5 tasks completed when:\n\n1. **Backend (Task 1)**: Express server with SQLite database, all CRUD routes working\n2. **Vision & Prompts (Task 2)**: OpenAI Vision API analyzes images, GPT-4o generates DALL-E prompts\n3. **Image Generation (Task 3)**: DALL-E 3 generates 4+ images with retry logic, SSE progress works\n4. **Layout & Export (Task 4)**: Sharp composes panels into manga layout, exports PNG/JPG/PDF\n5. **Frontend (Task 5)**: React UI allows workflow from story  generated manga  export\n\n**Total Expected Time**: 4-5 hours per agent (can run in parallel)\n**Minimum Test Time**: 30 minutes for integration testing\n\nGood luck, KAMUI agents! \n\n---\n\n*Last Updated: 2025-02-12*\n*For issues or questions, refer to the specific task prompts above*\n: \nID: task-1770909069269-afb680\nBranch: task/task-1770909069269-afb680\nWorktree: Users/yuyafujita/Projects/koma-fill/.worktrees/task-1770909069269-afb680",
        "branchColor": "#4fe84f",
        "index": 28
      },
      {
        "type": "commit",
        "label": "Implement manga backend foundation, vision/prompt services, ",
        "commit": {
          "hash": "1515fedca072442ad0656037229bce50b2e341f3",
          "subject": "Implement manga backend foundation, vision/prompt services, and image generation SSE routes",
          "author": "Yuya Fujita",
          "timestamp": 1770908791,
          "parents": [
            "8c4744d51c510fcc1be333b0221792cf33ee728c"
          ],
          "parent": "8c4744d51c510fcc1be333b0221792cf33ee728c",
          "refs": "task/task-1770909072180-65bb97, task/task-1770909069269-afb680, task/task-1770909069061-f69cf1, task/task-1770909068862-42049e, task/task-1770909068675-7f6691, task/task-1770909068262-a5d61b",
          "branches": [
            "task/task-1770909072180-65bb97",
            "task/task-1770909069269-afb680",
            "task/task-1770909069061-f69cf1",
            "task/task-1770909068862-42049e",
            "task/task-1770909068675-7f6691",
            "task/task-1770909068262-a5d61b",
            "main",
            "task/task-1770918400673-d21f34",
            "task/task-1770909068463-2984dc",
            "task/task-1770918401380-e8add6",
            "task/task-1770918400875-2630f2",
            "task/task-1770918401073-c21f64",
            "task/task-1770918401534-118872",
            "task/task-1770918401706-38620f",
            "task/task-1770918405559-058889"
          ]
        },
        "commitHash": "1515fedca072442ad0656037229bce50b2e341f3",
        "lane": 0,
        "parentLinks": [
          {
            "hash": "8c4744d51c510fcc1be333b0221792cf33ee728c",
            "lane": 0
          }
        ],
        "primaryBranchName": "main",
        "branchColor": "#4f85e8",
        "branchTags": [
          "task/task-1770909072180-65bb97"
        ],
        "worktrees": [
          {
            "path": "/Users/yuyafujita/Projects/koma-fill/.worktrees/task-1770909068262-a5d61b",
            "head": "1515fedca072442ad0656037229bce50b2e341f3",
            "branch": "task/task-1770909068262-a5d61b",
            "isMerged": false,
            "mergeCommitHash": null,
            "status": {
              "staged": [],
              "unstaged": [],
              "untracked": [
                {
                  "path": "backend/data/.gitkeep",
                  "status": "untracked",
                  "rawPath": "backend/data/.gitkeep",
                  "timestamp": 1770921960568
                }
              ],
              "capturedAt": 1770921960568
            },
            "normalizedPath": "/Users/yuyafujita/Projects/koma-fill/.worktrees/task-1770909068262-a5d61b",
            "lane": 9
          },
          {
            "path": "/Users/yuyafujita/Projects/koma-fill/.worktrees/task-1770909068675-7f6691",
            "head": "1515fedca072442ad0656037229bce50b2e341f3",
            "branch": "task/task-1770909068675-7f6691",
            "isMerged": false,
            "mergeCommitHash": null,
            "status": {
              "staged": [
                {
                  "path": "ackend/src/routes/manga.ts",
                  "originalPath": null,
                  "status": "modified",
                  "rawPath": "ackend/src/routes/manga.ts",
                  "timestamp": 1770921960581
                }
              ],
              "unstaged": [],
              "untracked": [],
              "capturedAt": 1770921960581
            },
            "normalizedPath": "/Users/yuyafujita/Projects/koma-fill/.worktrees/task-1770909068675-7f6691",
            "lane": 10
          },
          {
            "path": "/Users/yuyafujita/Projects/koma-fill/.worktrees/task-1770909068862-42049e",
            "head": "1515fedca072442ad0656037229bce50b2e341f3",
            "branch": "task/task-1770909068862-42049e",
            "isMerged": false,
            "mergeCommitHash": null,
            "status": {
              "staged": [],
              "unstaged": [],
              "untracked": [],
              "capturedAt": 1770921960593
            },
            "normalizedPath": "/Users/yuyafujita/Projects/koma-fill/.worktrees/task-1770909068862-42049e",
            "lane": 11
          },
          {
            "path": "/Users/yuyafujita/Projects/koma-fill/.worktrees/task-1770909069061-f69cf1",
            "head": "1515fedca072442ad0656037229bce50b2e341f3",
            "branch": "task/task-1770909069061-f69cf1",
            "isMerged": false,
            "mergeCommitHash": null,
            "status": {
              "staged": [],
              "unstaged": [],
              "untracked": [],
              "capturedAt": 1770921960593
            },
            "normalizedPath": "/Users/yuyafujita/Projects/koma-fill/.worktrees/task-1770909069061-f69cf1",
            "lane": 12
          },
          {
            "path": "/Users/yuyafujita/Projects/koma-fill/.worktrees/task-1770909069269-afb680",
            "head": "1515fedca072442ad0656037229bce50b2e341f3",
            "branch": "task/task-1770909069269-afb680",
            "isMerged": false,
            "mergeCommitHash": null,
            "status": {
              "staged": [],
              "unstaged": [],
              "untracked": [],
              "capturedAt": 1770921960605
            },
            "normalizedPath": "/Users/yuyafujita/Projects/koma-fill/.worktrees/task-1770909069269-afb680",
            "lane": 13
          }
        ],
        "index": 29
      },
      {
        "type": "commit",
        "label": "first commit",
        "commit": {
          "hash": "8c4744d51c510fcc1be333b0221792cf33ee728c",
          "subject": "first commit",
          "author": "Yuya Fujita",
          "timestamp": 1770896882,
          "parents": [],
          "parent": null,
          "refs": "",
          "branches": [
            "main",
            "task/task-1770918400673-d21f34",
            "task/task-1770909068463-2984dc",
            "task/task-1770909069061-f69cf1",
            "task/task-1770909068862-42049e",
            "task/task-1770909068675-7f6691",
            "task/task-1770909068262-a5d61b",
            "task/task-1770909069269-afb680",
            "task/task-1770918401380-e8add6",
            "task/task-1770918400875-2630f2",
            "task/task-1770918401073-c21f64",
            "task/task-1770918401534-118872",
            "task/task-1770918401706-38620f",
            "task/task-1770918405559-058889"
          ]
        },
        "commitHash": "8c4744d51c510fcc1be333b0221792cf33ee728c",
        "lane": 0,
        "parentLinks": [],
        "primaryBranchName": "main",
        "branchColor": "#4f85e8",
        "branchTags": [],
        "index": 30
      },
      {
        "type": "empty",
        "label": " ()",
        "files": [],
        "marker": "pre-history",
        "index": 31
      }
    ]
  },
  "projectRoot": "/Users/yuyafujita/Projects/koma-fill",
  "savedAt": 1770922005748
}